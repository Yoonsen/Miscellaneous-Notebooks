
;;; -*- Mode: TDL; Package: LKB -*-
;;;
;;;  HPSG Grammar Matrix Version 0.6
;;;
;;;  Copyright Emily M. Bender 2002
;;;  All Rights Reserved.
;;;  No use or redistribution without permission.
;;;  
;;;  Based on:
;;;
;;;  LinGO Grammar: fundamentals.tdl 
;;;  Copyright Daniel Flickinger 1994-2001
;;;  Initial development Rob Malouf, 3-Nov-1994
;;;
;;;  JACY Grammar: fundamentals.tdl, mrsbasic.tdl
;;;  Developed by Melanie Siegel, Emily M. Bender

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
;;
;;  Top-level feature geometry
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Types for Sign, Word, Phrase, and Lex-Entry

sign-min := avm &
  [ STEM list ].

basic-sign := sign-min &
  [ KEY-ARG bool ].

sign := basic-sign &
  [ SYNSEM synsem,
    ARGS list,
    INFLECTED bool,
    ROOT bool,
    RULE card-sensitive,
    GENRE genre,
    FRONT-TO-FILL bool,
    EXTRACTED-FROM bool,
    RESUMPTIVE bool,
    PHON phon,
    INFL-MORPH inflection,
    MORPH-SPLIT list,
    DISC-MODE discmode ].


;;;;;;;;;;;;;;;;;;;;;;;;;;
; Genre

genre := *top*.

wellfrmd-or-nochange := genre.
wellfrmd-or-noflect := genre.
wellfrmd-or-nodrop := genre.
wellfrmd-or-noperm := genre.

wellfrmd := wellfrmd-or-nochange & wellfrmd-or-noflect & wellfrmd-or-nodrop & wellfrmd-or-noperm.
nochange := wellfrmd-or-nochange &
[ MALCHANGE no-change ].
noflect := wellfrmd-or-noflect &
[ MALFLECT no-flect ].
nodrop := wellfrmd-or-nodrop & robust &
[ MALDROP no-drop ].
noperm := wellfrmd-or-noperm & robust & 
[ MALPERM no-perm ].

robust := genre &
[ MALDROP maldrop,
  MALFLECT flect,
  MALCHANGE malchange,
  MALPERM permute ].

maldrop := *top*.
flect := *top*.
malchange := *top*.
permute := *top*.


no-perm := permute.
perm := permute.
mal-invert := perm.

no-drop := maldrop.
drop := maldrop.

gen-drop := drop.

no-verbal-drop := drop.
obj-drop := no-verbal-drop.
obj-in-sel-pp-drop := no-verbal-drop.
refl-obj-drop := no-verbal-drop.
subj-drop := no-verbal-drop.
prep-drop := no-verbal-drop.


no-gf-drop := drop.
pass-drop := no-gf-drop.
perf-drop := no-gf-drop.
cop-drop := no-gf-drop.
inf-drop := no-gf-drop.

no-change := malchange.
subcat-change := malchange.

pp-for-np-change := subcat-change.
np-for-pp-change := subcat-change.

no-flect := flect.
mal-flect := flect. 

; C-CONT encodes the semantic contribution of the rule (phrasal
; or lexical).

phrase-or-lexrule := sign &
  [ SYNSEM canonical-synsem &
           [ LOCAL.CONT.HOOK #hook],
    GENRE #genre,
    C-CONT mrs-min & [ HOOK #hook],
    ARGS.FIRST.GENRE #genre ].

#|
; LH160412 - tracking contribution of wh added to the general definition. See also basic-binary rule, which redundantly imposes the ARGS.FIRST effect.
phrase-or-lexrule := sign &
  [ SYNSEM canonical-synsem &
           [ LOCAL.CONT.HOOK #hook,
	     LOCAL.CONT.HOOK.INDEX.WH #wh],
    SYNSEM.LOCAL.INHER-WH #wh,
    GENRE #genre,
    C-CONT mrs-min & [ HOOK #hook],
    ARGS.FIRST.SYNSEM.LOCAL.INHER-WH #wh,
    ARGS.FIRST.GENRE #genre ].
|#

word-or-lexrule-min := sign-min.

; PH 16-dec-03: NKL-ID keeps track of ID in the NKL lexicon.

word-or-lexrule := word-or-lexrule-min & sign &
  [ NKL-ID string,
    INFLECTION inflection ].


; Not all words have lex-synsem - e.g. lexical PPs like "tomorrow" are
; phr-synsem since they can be post-nominal modifiers.

word := word-or-lexrule &
  [ ROOT - ].

lex-item := word-or-lexrule.
norm-lex-item := lex-item &
  [ SYNSEM [ LOCAL.CONT [ HOOK [ LTOP #ltop,
                                 INDEX #index ],
                          RELS.LIST.FIRST #keyrel ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop,
                                      ARG0 #index ] ] ].

; PH 15-dec-03: I add the feature INFLECTION to deal with inflectional
; patterns.

lexeme := norm-lex-item &
  [ INFLECTED - ].

;; Not all phrases have SYNSEM phr-synsem, since we need to allow the
;; head-comp rules to build signs which are still p[ SYNSEM lex-synsem
;; ], for constructions like "twenty-two" and "five fifteen p.m.".  So
;; most phrases will assign the type phr-synsem to the value of
;; SYNSEM, but not all.

; Phrases don't have argument structure, but ARG-S is a feature
; of local, not sign.  So rather than have subtypes of local for
; phrases and lexical items, constrain phrases to have empty ARG-S.

phrase := phrase-or-lexrule &
  [ SYNSEM.LOCAL.ARG-S < >,
    ROOT bool ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Affixation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

non-affix-bearing := word-or-lexrule &
  [ INFLECTED +,
    SYNSEM.LKEYS.KEYREL.WLINK cons ].

; Rule
; LH with EXTRINSIC Jan05
rule := sign &
  [ RULE-NAME string,
    EXTRINSIC-ORD sort ].

card-sensitive := avm &
  [ NEEDS-CARD bool,
    NOMORE-CARD bool ].

card-ok := card-sensitive &
  [ NEEDS-CARD -,
    NOMORE-CARD bool ].

; LABEL-NAME and META used for labeling nodes in parse trees

tree-node-label := *top* &
  [ NODE sign ].

label := sign &
  [ LABEL-NAME string ].

;; see lkbpatches
meta := sign &
  [ META-PREFIX string,
    META-SUFFIX string ]. 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; SYNSEM values

synsem-min := avm &
  [ LOCAL mod-local,
    NON-LOCAL non-local-min,
    IDIOMOD bool,
    UNDERGOER-OPEN bool,
    CMPAR-SAT bool,
    BIND bind-min,
    CAN-WTOW bool,
    DERIV-POT avm ].
bind-min := avm.
bind := bind-min.
unbnd-min := bind.
unbnd := unbnd-min.


lex-or-phrase-synsem := synsem-min &
  [ LEX bool ].

synsem := synsem-min.

expressed-synsem := synsem.

canonical-synsem := expressed-synsem &
  [ MODIFIED xmod].

lex-synsem := canonical-synsem & lex-or-phrase-synsem &
  [ LOCAL local-min,
    LEX +,
    LKEYS lexkeys ].

phr-synsem := canonical-synsem & lex-or-phrase-synsem &
  [ LOCAL local-min,
    LEX - ].

non-canonical := synsem &
  [ LOCAL.CONT.HOOK.INDEX event-or-ref-index ].

expressed-non-canonical := non-canonical & expressed-synsem.

gap := expressed-non-canonical &
  [ LOCAL #local,
    NON-LOCAL [ REL 0-dlist,
                QUE 0-dlist,
                SLASH 1-dlist &
                    [ LIST < #local > ] ] ].

unexpressed := synsem-min &
  [ NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
                REL 0-dlist,
                QUE 0-dlist ] ].

unexpressed-reg := unexpressed & non-canonical.

anti-synsem := unexpressed.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LOCAL & NON-LOCAL values

; The feature AGR is introduced on LOCAL rather than on CAT (or on HEAD) since
; coordination schema unify the CAT value of the daughters with that of then
; mother, but need to be able to change AGR on the mother (to get plural 
; agreement on verb when subject is a coordinated NP with "and" vs. "or").  

mod-local := avm.

local-min := mod-local &
  [ CAT cat-min,
    CONT mrs-min,
    AGR individual,
    BINDING binding,
    BND-RESP list,
    BND-MOUNTABLE list,
    WAIT-BND-RESP list,
    XCAT cat-min ].


local := local-min &
  [ CTXT ctxt-min,
    ARG-S list,
    KEY-SPEC predsort,
    ALT-SPEC predsort,
    XSORT semsort,
    XLBL handle,
    ADJ-SITE-OPEN bool,
    ADJ-SITE-SUBORD-OPEN bool,
    INVERT-SITE-OPEN bool,
    CLIT-SITE-OPEN bool,
    CLIT-PRON-CONFIRMED bool,
    COMPS-BEGUN bool,
    ADV-MODIFIED bool,
    DELIMTELFIXED bool,
    PATHTELFIXED bool,
    INCRTELFIXED bool,
    DELIMTELACTV bool,
    PATHTELACTV bool,
    INCRTELACTV bool,
    IS-A-COMPLEMENT bool,
    HAS-A-V-COMPLEMENT bool,
    CAN-CMB-FIXPT bool,
    CAN-CMB-NONFIXPT-DIR bool,
    CAN-CMB-INDEX-SIT bool,
    CAN-CMB-V bool,
    HAS-PUNCT bool,
    HAS-PERIOD bool,
    RIGHT-ADJ-SITE-OPEN bool,
    REL-CL-SOM-INIT bool,
    CAN-NP-MOD bool,
    NEED-IMP-UNARY bool,
    DERIVED-HEAD bool,
    DERIVED-BARE-N-FROM-ADJ bool,
    SPEC-TO-BARE-N bool,
    CARD-TO-BARE-N bool,
    POSSPRON-TO-BARE-N bool,
    CAN-PASTPART-ADJ bool,
    CAN-ADV-DERIV-ADJ bool,
    HAS-REL-CL bool,
    COORD-RELEASED bool,
    COORD-POL bool,
    APPOSITION-COMPLEX bool,
    MUST-APP bool,
    HAS-INTERJECTION bool,
    CAN-APP bool,
    SUBJ-ONLY bool,
    CORRCOORD-CLOSED bool,
    CAN-COORD-COMP bool,
    OBJ-DEL-APPLIED bool,
    HEAD-SUBJ-APPLIED bool,
    CAN-RELATIVE-ADJOIN bool,
    INHER-WH bool,
    CAN-MODIFY bool,
    CMPAR-PENDING bool,
    MUST-COORD-PROJECT bool,
    MUST-CONNECT-PROJECT bool,
    MUST-COORDINATE bool,
    HAS-WH-MOVED bool,
    WH-ISLAND bool ].


binding := avm &
  [ BOUND bool,
    REFL-I bool,
    REFL-II bool,
    LEX-TAME bool ].

non-bound := binding &
  [ BOUND -,
    REFL-I -,
    REFL-II - ].

seg-bare := binding &
  [ BOUND +,
    REFL-I +,
    REFL-II - ].

nontamed := binding &
  [ LEX-TAME - ].

seg-selv := nontamed &
  [ BOUND +,
    REFL-I +,
    REFL-II + ].

bindee := avm &
  [ ANAPH-TYPE binding,
    ANAPH-INDX individual ].


; Types for distinguishing scopal v. intersective modifiers.
; (These types are used in the MOD value of modifiers, and 
; references by the scopal/intersective head-adjunct rules.)

scopal-mod := local.
intersective-mod := local.

non-local-min := avm.

non-local := non-local-min &
  [ SLASH 0-1-dlist,
    QUE 0-1-dlist,
    REL 0-1-dlist ].

non-local-none := non-local &
  [ SLASH 0-dlist & [ LIST < > ],
    QUE 0-dlist,
    REL 0-dlist ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  CAT values

cat-min := avm.

cat := cat-min &
  [ HEAD head-min,
    VAL valence-min,
    POSTHEAD bool ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  HEAD & VAL 

head-min := avm.

; It is expected that head will have many more features, but it
; is not yet clear which are relevant crosslinguistically.  In
; the English grammar, HEAD features include CASE, PRD, AUX, INV,
; TAM, and VFORM.  (Re: TAM --- it is sometimes useful to have the
; semantic information encoded in EVENT.E accessible via the head
; path.)

; Which subtypes of head are necessary and which head features are
; declared for which subtypes is also a language-specific question.



head := head-min &
  [ MOD list,
    KEYS keys_min,
    INV bool,
    ACCUSATIVE bool,
    EXPLETIVE bool,
    COORDINABLE bool ].



valence-min := avm.

valence := valence-min &
  [ SUBJ list,
    SPR list,
    COMPS list,
    ICOMPS list,
    SPEC list,
    --KEYCOMP avm ].

keys_min := avm.
keys := keys_min &
  [ KEY predsort,
    ALTKEY predsort ].

; One of a grammatically salient inventory of semantic sorts, such as
; 'animate' or 'time'

semsort :< sort.

inflection := sort.
;phon := inflection.
discmode := sort.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; CONT values
;
;   HOOK                   : Externally visible attributes of a sign
;   RELS diff-list         ; List of semantic relations
;   HCONS diff-list        ; Scope constraints: list of qeq's

mrs-min := avm.
;,
;    MSG basic_message
mrs := mrs-min &
  [ HOOK super-hook,
    RELS diff-list,
    HCONS diff-list ].

; HOOK values include
;    LTOP                  ; Local top handle
;    INDEX                 ; The salient nominal instance or event
;    XARG                  ; The external (controlled) argument of a phrase
; LH leg and LEG
leg := individual.
super-hook := avm &
  [ GTOP handle,
    LTOP handle,
    INDEX individual,
    XLEG leg,
    XARG semarg,
    VARG semarg,
    CMPAR-ARG individual,
    CMPAR-PRED predsort,
    XPRED predsort ].

hook := super-hook.
comp-hook := hook.
dir-hook := super-hook &
  [ DIRARG ref-ind ].

; MRSs are divided into psoas (with a distinguished event) and
; nom-objs (with a distinguished index).  We use a polymorphic
; attribute name INDEX for both of these, to simplify manipulation of
; these objects; for example, modifying PPs assign as their ARG's
; value the INDEX of the phrase they modify, whether it's an N-bar
; (with a ref-ind value) or a VP (with an event value).  (In NorSource,
; this picture is more complex - see README, section 'Prepositions')
;; Similarly
; useful for coordination.

psoa := mrs &
  [ HOOK.INDEX event ].

nom-obj := mrs &
  [ HOOK.INDEX index ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LKEYS attributes, providing pointers to semantic relations and complement
; predsorts in lexical types:
;  KEYREL relation         ; Pointer to main relation in RELS
;  ALTKEYREL relation      ; Pointer to an alternate relation in RELS
;  --COMPKEY predsort      ; Pointer to the first complement's KEY predsort
;  --OCOMPKEY predsort     ; Pointer to the oblique complement's KEY predsort

lexkeys := avm &
  [ KEYREL relation,
    ALTKEYREL relation,
    --COMPKEY predsort,
    --OCOMPKEY predsort ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  CTXT values 

ctxt-min := avm.

ctxt := ctxt-min &
  [ PRESUP diff-list ].

disc-boundedness := ctxt-min &
  [ DISC-BOUND bool ].

pron-discbnd := disc-boundedness &
  [ DISC-BOUND + ].

non-pron-discbnd := disc-boundedness &
  [ DISC-BOUND bool ].



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Basic semantic types

; The message represents the semantic type of a clause (cf. Ginzburg &
; Sag 2000).  All clauses have messages.  Elements that take clauses
; as semantic arguments should end up with the LBL of the clause as
; the value of ARGn, L/R-HNDL, etc.  The MARG (message argument) of a 
; message is a handle that qeqs the LBL of the main verb in the clause.
; This leaves room for quantifiers to scope at each clause without
; allowing scope ambiguity between quanitifers and messages, as it is
; not clear what that would mean.




iforce := avm.
prop-or-ques := iforce.
prop-or-comm := iforce.
prop := prop-or-ques & prop-or-comm.
ques := prop-or-ques.
comm := prop-or-comm.            

; Constrains handle of scopable argument HARG relative to one 
; outscoped LARG handle (the "H" is mnemonic for either "higher" or
; "hole" argument, while the "L" is mnemonic for either "lower" or 
; "label" argument.

qeq := avm &
  [ HARG handle,
    LARG handle ].        

semarg := avm &
  [ INSTLOC string,
    ROLE role ].
instloc := *top*.

handle := semarg.

individual := semarg &
  [ SORT semsort,
    WH bool ].

; The INDEX value of a nom-obj is an index (expletive or
; referential).
; for adjective agreement, necessary to assign also expletives the png values (LHﺰ

index := individual &
  [ PNG png ].

; This is the type of the index of the phrase modified by predicative
; PPs, which can either modify a ref-ind nominal or an event VP.

event-or-ref-index := individual.

; Expletives get distinguished index type so they can be
; selected semantically.  In English, this type has subtypes
; for it and there.  Most languages have at most one expletive,
; so those aren't included here.

expl-ind := index.
ref-ind := index & event-or-ref-index.

; Types encoding agreement information, analyzed as a part of the
; index, following Pollard & Sag 1994.  Which subtypes and features
; are appropriate seems highly language dependent.  The agreement
; system of English doesn't justify a full cross-classification of
; number and gender, so the features of png are PN and GENDER in the
; English grammar.  (See Flickinger 2000.) Sag & Wasow 1999 declare
; GENDER as a feature of the png type 3sg.

; see 'norsk'
;png := avm.

; Create subtypes of tense, aspect and mood as appropriate.

tense := sort.
mood := sort.

tam := avm &
 [  TENSE tense,
    ASPECT semsort,
    MOOD mood,
    DELIMITED bool ]. 

super-event := event-or-ref-index.
event := super-event &
  [ SORT verb-act-specification,
    SF iforce ].
ad-event := super-event.
;ad-event := super-event &
; [ TARG class-specified ].
loc-event := ad-event.
orient-event := ad-event &
  [ ORIENT orient ].
event-verb := event &
  [ E tam,
    PATH-TELIC bool,
    SIT-TYPE semsort,
    DISC-MOVE discmode ].


event-min := event.

; Coordinated phrases have conjoined indices as their INDEX
; values.  These are meant to be interpreted as pointers to 
; the set of indices the conjunction conjoins.

conj-index := event-or-ref-index.
conj-event := conj-index & event.
conj-ref-ind := conj-index & ref-ind.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Basic relation types

; Relations are classified according to the types of arguments they take.  All
; relations have a handle.  In addition, quantifier relations have a bound
; variable and a restriction, nominal relations have an instance, and event
; relations have an event.  Furthermore, nominal relations and event relations
; can have additional roles, depending on their meaning.

; WLINK links semantic relation to input string elements, more or less.
; This becomes useful whenever a grammar is used in some application.

;; !!! (bmw) added CFROM/CTO for characterization support !!!
;; thanks - but it makes mrs'es unreadable
;; (bmw) *ignored-sem-features* needs to be set to include CFROM/CTO

relation := avm &
  [ LBL handle,
    WLINK list,
    PRED predsort,
    CFROM *top*,
    CTO *top*].

; Abstract relation subtypes.  We recommend not positing a type
; for each lexical relation, but rather using the feature PRED
; to distinguish different lexical relations of the same type.
; Relation types are modified in one of two circumstances:
;
; (i) A feature needs to be introduced that is relevant for some
; relations and not others, or
;
; (ii) Something in the grammar needs to make reference to a family
; of relations that are not otherwise distinguished by a type.



; LH Apr06.04: to keep in line with the old NorSource
; strategy, = old ERG strat, I make arg2-rel and arg3-rel, not
; going via arg1-rel. Next version will harmonize with Matrix,
; and express th-roles in a different way.
#|
arg12-relation := arg1-relation &
  [ ARG2 semarg ].

arg123-relation := arg12-relation &
  [ ARG3 semarg ].
|#


arg0-relation := relation &
  [ ARG0 semarg ].

arg0bare-relation := arg0-relation.

arg1-relation := arg0-relation &
  [ ARG1 semarg ].

arg2-relation := arg0-relation &
  [ ARG2 semarg].

arg12-relation := arg1-relation & arg2-relation.

arg3-relation := arg0-relation &
  [ ARG3 semarg].

arg13-relation := arg1-relation & arg3-relation.

arg123-relation := arg12-relation & arg3-relation.


arg1234-relation := arg123-relation &
  [ ARG4 semarg ].

event-relation := arg0-relation &
  [ ARG0 event ].

event-min-relation := arg0-relation &
[ ARG0 event-min ].

arg1-ev-relation := arg1-relation & event-relation.
arg1-ev-min-relation := arg1-relation & event-min-relation.
arg12-ev-relation := arg1-ev-relation & arg12-relation.
arg12-ev-min-relation := arg1-ev-min-relation & arg12-relation.
arg123-ev-relation := arg12-ev-relation & arg123-relation.
arg1234-ev-relation := arg123-ev-relation & arg1234-relation.

verb-ellipsis-relation := arg1-relation.





; Noun relations

noun-relation := arg0-relation &
  [ ARG0 ref-ind ].

; Relational nouns like 'picture' or 'claim' take an additional semantic 
; argument
noun-arg1-relation := noun-relation & arg1-relation.

;EXPER-CARD
;const-relation := noun-relation &
;  [ CARG string ].

const-relation := arg0-relation &
  [ CARG string ].

named-relation := const-relation &
  [ PRED named_rel ].


; Preposition relations

;prep-mod-relation := arg12-ev-min-relation.

; adverb relations
; NB: Negation is represented not as a subtype of adv-relation, but as an 
; adv-relation with the PRED value neg_rel.

adv-relation := arg0-relation.
; LH Dec04


; coordinating and subordinating conjunctions

subord-or-conj-relation := relation &
  [ L-HNDL handle,
    R-HNDL handle ].
#|
conjunction-relation := subord-or-conj-relation &
  [ C-ARG conj-index,
    PRED "_conjunction_q_rel",
    L-INDEX index,
    R-INDEX index ].
|#
;PRED "_conjunction_q_rel",
conjunction-relation := subord-or-conj-relation &
  [ C-ARG individual,
    L-INDEX individual,
    R-INDEX individual ].

; NB: "if_then_rel" is now a PRED value of subord-relation.
subord-relation := subord-or-conj-relation.

; noun noun compounds

unspec-compound-relation := arg12-relation &
  [ ARG0 event,
    ARG1 ref-ind,
    ARG2 ref-ind ].

; quantifier relation
quant-relation-sup := arg0-relation &
  [ ARG0 individual,
    RSTR handle,
    BODY handle ].

quant-relation := quant-relation-sup &
  [ ARG0 ref-ind,
    RSTR handle,
    BODY handle ].

quant-event-relation := quant-relation-sup.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; predsorts

norm_rel := predsort.
named_rel := norm_rel.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Head types

; Values for head features such as CASE, VFORM, ...

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Sorts for atomic values

; person, number and gender

; clause mode

; voice

; mood

; pronoun type

; Three-valued sort evoking Polish logician Jan Lukasiewicz

luk := sort.

; These types allow the statement of constraints (e.g., in 
; subcategorization) of the form:  If you care, you must have
; the value + (-), but you don't have to care.  Useful for keeping
; down the number of constructions and subcategorization types.

na-or-+ := luk.
na-or-- := luk.
+-or-- := luk.

na := na-or-+ & na-or--.
bool := luk.
+ := bool & na-or-+ & +-or--.
- := bool & na-or-- & +-or--.

; Three-valued sort for distinguishing unmodified signs from both
; left-modified and right-modified signs PERIPH indicates whether this
; modifier is left- or right-peripheral in its phrase - e.g., "the IBM
; temporary employees" but "*the IBM five employees"

xmod := sort &
  [ PERIPH luk ].
notmod-or-rmod := xmod.
notmod-or-lmod := xmod.
notmod := notmod-or-rmod & notmod-or-lmod.

hasmod := xmod.
lmod := hasmod & notmod-or-lmod.
rmod := hasmod & notmod-or-rmod.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  Basic types

sort := *top*.
predsort := sort.
atom := predsort.
avm := *top*.
list := avm.

cons := list &
  [ FIRST *top*,
    REST *top* ].

0-1-list := list.
1-list := 0-1-list & cons &
  [ REST null ].
null := 0-1-list.
1-plus-list := cons &
  [ REST cons ].

diff-list := avm &
  [ LIST list,
    LAST list ].

0-1-dlist := diff-list &
  [ LIST 0-1-list ].
0-dlist := 0-1-dlist &
  [ LIST #list,
    LAST #list ].
1-dlist := 0-1-dlist &
  [ LIST 1-list &
	 [ REST #rest & null ],
    LAST #rest ].


;;; DPF 020411

antilist := list.

anticons := antilist & ocons &
  [ FIRST anti-synsem,
    REST  antilist ].

antinull := antilist & onull.


; This type shows the basic form for diff-list appends.
; It is not meant to be used as a supertype.  Actual instances
; of diff-list append will involve different features in different
; relationships to each other & the feature geometry.

dl-append := avm & [APPARG1 [LIST #first,       
                             LAST #between],
                    APPARG2 [LIST #between,
                             LAST #last],
                    RESULT  [LIST #first,
                             LAST #last]].

integer := atom.

; NB: strings should be enclosed in double quotes, e.g., [PRED "named_rel"].

string := atom.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Some useful kinds of lists

; A list of optional arguments.

olist := list.

ocons := olist & cons &
  [ FIRST unexpressed,
    REST  olist ].

onull := olist & null.

 

; The LinGO grammar also makes use of a prolist -- or list
; of synsems of type pro-ss. 


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Lexical rules

lex-rule := phrase-or-lexrule & word-or-lexrule &
  [ NEEDS-AFFIX bool,
    SYNSEM.LOCAL.CONT.RELS [ LIST #first,
			     LAST #last ],
    DTR #dtr & word-or-lexrule &
	[ SYNSEM.LOCAL.CONT.RELS [ LIST #first,
		  		   LAST #middle ] ],
    C-CONT.RELS [ LIST #middle,
		  LAST #last ],
    ARGS < #dtr > ].

; Lexical rules vary on two dimensions: whether they are lexeme-to-lexeme
; or lexeme-to-word and whether or not they involve spelling changes.
; Accordingly, we define four subtypes of lex-rule, which have
; four cross-classified glb subtypes:

; Note that the lexeme/word distinction is represented via a feature
; [INFLECTED bool] rather than as a type.  We find this more convenient,
; as it allows certain words to be [INFLECTED +] from the start without
; having to twist the hierarchy too much (especially if one makes use
; of defaults).

; Lexeme-to-word rules are hypothesized to monotonically add synsem
; information.

lexeme-to-word-rule := lex-rule &
  [ INFLECTED +,
    KEY-ARG #keyarg,   
    SYNSEM #synsem,
    ROOT #root,
    INFL-MORPH #inflection,
    DTR [ INFLECTED -,
          KEY-ARG #keyarg,   
          SYNSEM #synsem,
          INFL-MORPH #inflection,
          ROOT #root ],
    C-CONT.RELS <! !> ].

; Lexeme-to-lexeme rules can make more radical changes to the SYNSEM value.

lexeme-to-lexeme-rule := lex-rule & lexeme &
  [ INFLECTED #infl,
    INFLECTION #2,
    INFL-MORPH #inflection,
    DTR [ INFLECTED #infl,
          INFLECTION #2,
          INFL-MORPH #inflection ] ].

; LH
word-to-word-rule := lex-rule & word &
  [ INFLECTED #infl,
    DTR word & [ INFLECTED #infl ] ].

; Spelling changing rules.  The LKB identifies these rules based
; on the NEEDS-AFFIX value. 

inflecting-lex-rule := lex-rule &
  [ NEEDS-AFFIX + ].

; Spelling-preserving rules copy up the STEM (orthography) of
; the daughter.

constant-lex-rule := lex-rule &
  [ STEM #stem,
    DTR [ STEM #stem ]].

; Cross-classified glb types

const-ltol-rule := lexeme-to-lexeme-rule & constant-lex-rule.
infl-ltol-rule := lexeme-to-lexeme-rule & inflecting-lex-rule.
const-ltow-rule := lexeme-to-word-rule & constant-lex-rule.
infl-ltow-rule := lexeme-to-word-rule & inflecting-lex-rule.
const-wtow-rule := word-to-word-rule & constant-lex-rule.
infl-wtow-rule := word-to-word-rule & inflecting-lex-rule.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Phrase structure rules

; Headed phrases must obey the Head Feature Principle and the Revised
; Marking Principle.  They do not all obey the NLFP with respect to
; QUE, but it appears that all CLAUSE phrases account for QUE on
; mother and non-head-dtr.  Hence moved the QUE coreference to
; NON-CLAUSE.  Headed phrases also identify the value of AGR on mother
; and head daughter, unlike e.g. the coordination schemata which
; identify HEAD but not AGR.

headed-phrase := phrase & 
  [ ROOT -,
    SYNSEM.LOCAL [ CAT.HEAD head & #head,
                   AGR #agr ],
    HEAD-DTR.SYNSEM.LOCAL local &
		 [ CAT.HEAD #head,
                   AGR #agr ] ].

non-headed-phrase := phrase &
  [ ROOT - ].

; Most but not all phrases have SYNSEM phr-synsem; head-complement
; constructions have their SYNSEM type determined by the head-dtr.

phrasal := phrase &
  [ SYNSEM phr-synsem ].

; Head/nexus phrases pass up the REL and QUE values of the head daughter
; (which has amalgamated the REL and QUE values of its arguments as in
; Sag 1997) to the mother.  

head-nexus-rel-phrase := headed-phrase &
  [ SYNSEM.NON-LOCAL.REL #rel,
    HEAD-DTR.SYNSEM.NON-LOCAL.REL #rel ].

head-nexus-que-phrase := headed-phrase &
  [ SYNSEM.NON-LOCAL.QUE #que,
    HEAD-DTR.SYNSEM.NON-LOCAL.QUE #que ].

head-nexus-phrase := head-nexus-rel-phrase & head-nexus-que-phrase.

; In a head/local dependent phrase, the SLASH feature of the mother is
; token-identical to that of the head daughter, which has already amalgamated
; the SLASH values of its arguments.  See discussion of head-nexus-phrase for
; treatment of REL and QUE.

head-valence-phrase := head-nexus-phrase &
  [ SYNSEM.NON-LOCAL.SLASH #slash,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash ].

; All phrases are either unary or binary.

basic-unary-phrase := phrase &
  [ STEM #stem,
    SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
        		       LAST #last ],
			HCONS [ LIST #scfirst,
				LAST #sclast ] ],
    C-CONT [ RELS [ LIST #middle,
		    LAST #last ],
	     HCONS [ LIST #scmiddle,
		     LAST #sclast ] ],
    ARGS < sign & [ STEM #stem,
                    SYNSEM.LOCAL local &
				 [ CONT [ RELS [ LIST #first,
						 LAST #middle ],
					  HCONS [ LIST #scfirst,
						  LAST #scmiddle ] ] ],
                    ROOT - ] > ].

unary-phrase := basic-unary-phrase &
  [ INFLECTED +,
    ARGS < [ INFLECTED + ] > ].

; LH160412 - possibly omit the INHER-WH, since reduplicated by lex-or-pharse-rule
basic-binary-phrase := phrase &
  [ SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
			       LAST #last ],
			HCONS [ LIST #scfirst,
				LAST #sclast ] ],
;    SYNSEM.LOCAL.INHER-WH #wh,
    GENRE #genre,
    C-CONT [ RELS [ LIST #middle2,
		    LAST #last ],
	     HCONS [ LIST #scmiddle2,
		     LAST #sclast ] ],
    ARGS < sign & [ SYNSEM.LOCAL local &
				 [ CONT [ RELS [ LIST #first,
						 LAST #middle1 ],
					  HCONS [ LIST #scfirst,
						  LAST #scmiddle1 ] ] ],
                    ROOT -,
;		    SYNSEM.LOCAL.INHER-WH #wh,
		    GENRE #genre  ],
	   sign & [ SYNSEM.LOCAL local &
				 [ CONT [ RELS [ LIST #middle1,
						 LAST #middle2 ],
					  HCONS [ LIST #scmiddle1,
						  LAST #scmiddle2 ] ] ],
                    ROOT -,
		    GENRE #genre ] > ].

binary-phrase := basic-binary-phrase &
  [ INFLECTED +,
    ARGS < [ INFLECTED + ],
           [ INFLECTED + ] > ].
    
;LH new
gap-licensed := basic-binary-phrase &
  [ EXTRACTED-FROM +,
    ARGS < [ EXTRACTED-FROM bool],
           [ EXTRACTED-FROM bool ] > ].

binary-phr-gaplicensed-left := binary-phrase &
  [ EXTRACTED-FROM +,
    ARGS < [ EXTRACTED-FROM +],
           [ EXTRACTED-FROM - ] > ].

binary-phr-gaplicensed-right := binary-phrase &
  [ EXTRACTED-FROM +,
    ARGS < [ EXTRACTED-FROM -],
           [ EXTRACTED-FROM + ] > ].

binary-phr-nogaplicensed := binary-phrase &
  [ EXTRACTED-FROM -,
    ARGS < [ EXTRACTED-FROM -],
           [ EXTRACTED-FROM - ] > ].



basic-binary-headed-phrase := headed-phrase & basic-binary-phrase &
  [ NON-HEAD-DTR sign ].

binary-headed-phrase := basic-binary-headed-phrase & binary-phrase.

; For more effecient parsing, designate one argument or the other
; as the KEY-ARG: that which should be unified with first.

binary-rule-left-to-right := rule &
  [ ARGS < [ KEY-ARG + ] , [ KEY-ARG bool ] > ].

binary-rule-right-to-left := rule &
  [ ARGS < [ KEY-ARG bool ], [ KEY-ARG + ] > ].

head-only := unary-phrase & headed-phrase &
  [ HEAD-DTR #head,
    ARGS < #head > ].

head-initial := binary-headed-phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head,
    ARGS < #head, #non-head > ].

basic-head-final := basic-binary-headed-phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head,
    ARGS < #non-head, #head > ].

head-final := basic-head-final & binary-headed-phrase.

; C-CONT is the semantic contribution of the phrase itself.  The hook 
; of the phrase is identified with the hook of C-CONT (which is possibly
; but not necessarily identified with the hook of one of the daughters.
; The rels of the phrase result from appending the rels of C-CONT and the
; rels of the daughters.

; Head-compositional phrases identify the syntactic head daughter as the
; semantic head.

head-compositional := headed-phrase &
  [ C-CONT.HOOK #hook,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook ].

; Clauses have message types as values, non-clauses have the value no-msg.
; Constrain the HEAD value of clause to verb or whatever type is
; appropriate.  Clauses have empty QUE values.
; Later versions of the matrix might have clause v. non-clause as
; an independent dimension from headed v. non-headed phrase, as in
; Ginzburg & Sag 2000.  The phrase types are meant to cross-classify
; with the clause types to give e.g., decl-head-subj from decl-clause
; and head-subj-phrase.  

;non-clause := head-nexus-phrase &
;  [ SYNSEM.LOCAL [ CAT.MC na,
;                   CONT.MSG no-msg ] ].

clause := phrasal &
  [ SYNSEM [ LOCAL.CAT.VAL.COMPS < >,
	     NON-LOCAL.QUE 0-dlist ] ].

; The following subtypes of clause will need more constraints,
; as appropriate:

; Relative clauses are propositions, but depending on the analysis
; of the construction, the message may actually come from the daughter.

relative-clause := clause.
  
non-rel-clause := headed-phrase & clause.

#|
interrogative-clause := clause &
  [ SYNSEM.LOCAL.CONT.MSG.PRED question_m_rel ].

declarative-clause := clause &
  [ SYNSEM.LOCAL.CONT.MSG.PRED proposition_m_rel ].

imperative-clause := clause &
  [ SYNSEM.LOCAL.CONT.MSG.PRED command_m_rel ].
|#

; lh: SPR < anti-synsem >
basic-head-filler-phrase := binary-phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ COMPS < >,
                                 SPR < > ],
			   POSTHEAD + ] ],
	     LOCAL.HAS-WH-MOVED +,
	     NON-LOCAL.SLASH 0-dlist ],
    FRONT-TO-FILL -,
    ARGS < [ SYNSEM [ LOCAL #slash & local &
			    [ CAT.VAL [ SUBJ olist,
					COMPS olist,
					SPR olist ] ],
		      NON-LOCAL.SLASH 0-dlist ] ],
	   [ SYNSEM [ LOCAL.CAT [ VAL.COMPS olist],
		      LOCAL.WH-ISLAND -,
		      NON-LOCAL [ SLASH 1-dlist &
					[ LIST [ FIRST #slash,
						 REST < > & #last ],
					  LAST #last ],
				  QUE 0-dlist,
				  REL 0-dlist ] ] ] > ].




; LH July05 - relatives like "ballen du traff"
basic-unary-head-filler-phrase := unary-phrase & phrasal &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ COMPS < >,
                                 SPR < anti-synsem > ],
			   POSTHEAD + ] ],
	     NON-LOCAL.SLASH 0-dlist ],
    FRONT-TO-FILL -,
    ARGS < [ SYNSEM [ LOCAL.CAT [ VAL.COMPS olist ],
		      NON-LOCAL [ SLASH 1-dlist &
					[ LIST [ REST < > & #last ],
					  LAST #last ],
				  QUE 0-dlist,
				  REL 0-dlist ] ] ] > ].

; These phrase types should all inherit from head-final or head-initial,
; as appropriate, replacing binary-headed-phrase.

basic-head-subj-phrase-sup := basic-head-subj-phrase-super & head-valence-phrase.
basic-head-subj-phrase-super := head-nexus-phrase & binary-headed-phrase & phrasal &
  [ SYNSEM.LOCAL.CAT [ POSTHEAD +,
                       VAL [ SUBJ olist & < anti-synsem >,
                             COMPS <>,
                             ICOMPS <>,
                             SPR #spr ],
		       QVAL #3 ],
    SYNSEM.LOCAL.HAS-WH-MOVED #front,
    SYNSEM.LOCAL.WAIT-BND-RESP #4,
    HEAD-DTR.SYNSEM.LOCAL.CAT [ VAL [ SUBJ < #synsem >,
                                      SPR #spr,
                                      COMPS olist,
                                      ICOMPS <> ],
				QVAL #3],
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP.FIRST [ ANAPH-INDX #1 ],
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #4,
    HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED #front,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem &
		 [ LOCAL [ CAT [ VAL [ SUBJ antilist, ;; MHS 020411 Changed from onull to antilist
				       COMPS olist,
				       SPR olist,
				       SPEC olist,
                                       ICOMPS <> ] ],
                           COORD-RELEASED +,
                           MUST-APP - ],
		   NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
			       REL 0-dlist,
			       QUE 0-dlist ] ] ].

basic-head-subj-phrase := basic-head-subj-phrase-sup &
[ SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -].

#|

;; ALTERED for mal rules

basic-head-subj-phrase := head-valence-phrase & binary-headed-phrase & phrasal &
  [ SYNSEM.LOCAL.CAT [ POSTHEAD +,
                       VAL [ SUBJ olist & < anti-synsem >,
                             COMPS <>,
                             ICOMPS <>,
                             SPR #spr ],
		       QVAL #3 ],
    SYNSEM.LOCAL.WAIT-BND-RESP #4,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CAT [ VAL [ SUBJ < #synsem >,
                                      SPR #spr,
                                      COMPS olist,
                                      ICOMPS <> ],
				QVAL #3],
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP.FIRST [ANAPH-INDX #1],
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem &
		 [ LOCAL [ CAT [ VAL [ SUBJ antilist, ; MHS 020411 changed from onull to antilist
				       COMPS olist,
				       SPR olist,
                                       ICOMPS <> ] ],
                           COORD-RELEASED +,
                           MUST-APP - ],
		   NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
			       REL 0-dlist,
			       QUE 0-dlist ] ] ].



; LH May05: added 'phrasal'
basic-head-subj-phrase := head-valence-phrase & binary-headed-phrase & phrasal &
  [ SYNSEM.LOCAL.CAT [ POSTHEAD +,
                       VAL [ SUBJ olist & < anti-synsem >,
                             COMPS <>,
                             ICOMPS <>,
                             SPR #spr ] ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ VAL [ SUBJ < #synsem >,
                                      SPR #spr,
                                      COMPS olist,
                                      ICOMPS <> ]],
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem &
		 [ LOCAL [ CAT [ VAL [ SUBJ onull,
				       COMPS olist,
				       SPR olist,
                                       ICOMPS <> ] ],
                           COORD-RELEASED +,
                           MUST-APP - ],
		   NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
			       REL 0-dlist,
			       QUE 0-dlist ] ] ].
|#

; LH orig, top COMPS be empty and HEAD-DTR COMPS olist; but to make 
; head-invertsubject-phrase work, both COMPS are now 'list'
; temp commented out

another-basic-head-subj-phrase := head-valence-phrase & binary-headed-phrase & phrasal &
  [ SYNSEM.LOCAL.CAT [ HEAD.KEYS.KEY #key,
                       POSTHEAD +,
                       VAL [ SUBJ antilist,
                             COMPS #comps,
                             ICOMPS #icomps,
			     SPEC #spec,
                             SPR #spr ],
		       QVAL #3  ],
    SYNSEM.LOCAL.CONT.HOOK #hook,
    HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.KEYS.KEY #key,
                                VAL [ SUBJ < #synsem >,
                                      SPR #spr,
                                      COMPS #comps,
				       SPEC #spec,
                                      ICOMPS #icomps ],
				QVAL #3],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP.FIRST.ANAPH-TYPE.BOUND -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem &
		 [ LOCAL [ CAT [ VAL [ SUBJ antilist,
				       COMPS < >,
				       ICOMPS < >,
				       SPR < >,
				       SPEC < > ] ] ],
		   NON-LOCAL [ SLASH 0-dlist, ; & [ LIST < > ], ;; MHS 050713
			       REL 0-dlist,
			       QUE 0-dlist ] ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].

#|
; exp SUBJ olist & < anti-synsem >
another-basic-head-subj-phrase := head-valence-phrase & binary-headed-phrase & phrasal &
  [ SYNSEM.LOCAL.CAT [ POSTHEAD +,
                       VAL [ SUBJ antilist,
                             COMPS list,
                             ICOMPS list,
                             SPR #spr ] ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ VAL [ SUBJ < #synsem >,
                                      SPR #spr,
                                      COMPS list,
                                      ICOMPS list ]],
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    HEAD-DTR.SYNSEM.LOCAL.INVERT-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP.FIRST [ANAPH-INDX #1],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem &
		 [ LOCAL [ CAT [ VAL [ SUBJ antilist,
				       COMPS olist,
                                       ICOMPS <>,
				       SPEC <>,
				       SPR olist ] ],
                           COORD-RELEASED +,
                           MUST-APP - ],
		   NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
			       REL 0-dlist,
			       QUE 0-dlist ] ] ].
|#

; LH Feb22-06: added 'DERIVED-HEAD #2' (for "Ola er mer storvokst enn Per")
; replaced  COMPS olist & #comps  by  COMPS #comps, under HEAD-DTR.VAL, for the purpose of "ikke" construed as a specifier. Accompanying modification of the other COMPS values - see revised rule below

#|

basic-head-spec-phrase := head-valence-phrase & non-clause & phrasal &
			  binary-headed-phrase &
  [ INFLECTED +,
    SYNSEM [ LOCAL.CAT [ VAL [ SUBJ #subj,
                               COMPS #spcomps,
                               SPR #spr,
                               SPEC #spec ],
                         POSTHEAD #ph ],
             MODIFIED #modif ],
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR [ INFLECTED +,
               SYNSEM [ LOCAL [ CAT [ HEAD #head,
                                      VAL [ SUBJ #subj,
                                            COMPS #comps,
                                            SPR < #synsem & 
                                                  canonical-synsem . #spr >,
                                            SPEC #spec ],
                                      POSTHEAD #ph],
                                CONT.HOOK #hdhook,
                                DERIVED-HEAD #2 ],
                        MODIFIED #hmodif ] ],
    NON-HEAD-DTR.SYNSEM #synsem &
	 [ LOCAL [ CAT [ VAL [ SPEC < [ LOCAL [ CAT [ HEAD #head,
                                                      VAL.COMPS #comps ],
                                                CONT.HOOK #hdhook,
                                                DERIVED-HEAD #2],
                                        MODIFIED #hmodif ] >,
                               COMPS #spcomps ] ],
                   CONT.HOOK comp-hook ],
           MODIFIED #modif ],
    C-CONT [ HOOK super-hook ] ].
|#

mal-basic-head-spec-phrase := head-valence-phrase & phrasal &
			  binary-headed-phrase &
  [ INFLECTED +,
    SYNSEM [ LOCAL.CAT [ VAL [ SUBJ #subj,
                               COMPS #comps,
                               SPR #spr,
                               SPEC #spec ],
                         POSTHEAD #ph ],
             MODIFIED #modif ],
;    SYNSEM.LOCAL.MUST-CONNECT-PROJECT -,
    HEAD-DTR [ INFLECTED +,
               SYNSEM [ LOCAL [ CAT [ HEAD #head,
                                      VAL [ SUBJ #subj,
                                            COMPS #comps,
                                            SPR <  #synsem & canonical-synsem . #spr >,
                                            SPEC #spec ],				
                                      POSTHEAD #ph],
				CONT.HOOK.INDEX #index & [WH #bool],                             
                                DERIVED-HEAD #2 ],
                        MODIFIED #hmodif ] ],
    NON-HEAD-DTR.SYNSEM #synsem &
	                  [ LOCAL [ CAT [ VAL [ SPEC < [ LOCAL [ CAT [ HEAD #head,
								       VAL.COMPS #comps ],
								 CONT.HOOK.INDEX #index & [WH #bool],
                                               
                                                DERIVED-HEAD #2],
                                        MODIFIED #hmodif ] > ] ],
                   CONT.HOOK comp-hook ],
           MODIFIED #modif ],
    GENRE robust,
    C-CONT [ HOOK super-hook ] ].

;; Before it was HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #hdhook
;; 		 NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK #hdhook
;; Rather than 
;;		 HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index,
;;		 NON-HEAD-DTR.SYNSEM.LOCAL.AGR #index
;; EAA 020411


#|
basic-head-spec-phrase := head-valence-phrase & phrasal &
			  binary-headed-phrase &
  [ INFLECTED +,
    SYNSEM [ LOCAL.CAT [ VAL [ SUBJ #subj,
                               COMPS #comps,
                               SPR #spr,
                               SPEC #spec ],
                         POSTHEAD #ph ],
             MODIFIED #modif ],
    HEAD-DTR [ INFLECTED +,
               SYNSEM [ LOCAL [ CAT [ HEAD #head,
                                      VAL [ SUBJ #subj,
                                            COMPS #comps,
                                            SPR < #synsem & 
                                                  canonical-synsem . #spr >,
                                            SPEC #spec ],
                                      POSTHEAD #ph],
                                CONT.HOOK.INDEX #index & [WH #bool],
                                DERIVED-HEAD #2 ],
                        MODIFIED #hmodif ] ],
    NON-HEAD-DTR.SYNSEM #synsem &
	 [ LOCAL [ CAT [ VAL [ SPEC < [ LOCAL [ CAT [ HEAD #head,
                                                      VAL.COMPS #comps ],
						CONT.HOOK.INDEX.WH #bool,
                                                DERIVED-HEAD #2],
                                        MODIFIED #hmodif ] > ] ],
                   CONT.HOOK comp-hook & [INDEX #index],
		   AGR #index ],
           MODIFIED #modif ],
    C-CONT [ HOOK super-hook ] ].
|#

; SPEC list to enable coordination 'en mann og katten', using n-connect-spr-phrase
basic-head-spec-phrase-sup := head-valence-phrase & phrasal &
			  binary-headed-phrase &
  [ INFLECTED +,
    SYNSEM [ LOCAL.CAT [ VAL [ SUBJ #subj,
                               COMPS #comps,
                               SPR #spr,
                               SPEC list ],
                         POSTHEAD #ph ],
             MODIFIED #modif ],
;    SYNSEM.LOCAL.MUST-CONNECT-PROJECT -,
    HEAD-DTR [ INFLECTED +,
;               HEAD-DTR.SYNSEM.LOCAL.MUST-COORDINATE -,
	       SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ #subj,
                                            COMPS #comps,
                                            SPR < #synsem & 
                                                  canonical-synsem . #spr >,
                                            SPEC list ],
                                      POSTHEAD #ph],
                                CONT.HOOK #hdhook,
                                DERIVED-HEAD #2,
				HAS-PUNCT -,
				HAS-PERIOD -],
                        MODIFIED #hmodif ] ],
    NON-HEAD-DTR.SYNSEM #synsem &
	 [ LOCAL [ CAT [ VAL [ SPEC < [ LOCAL [ CAT.VAL.COMPS #comps,
                                                CONT.HOOK #hdhook,
                                                DERIVED-HEAD #2],
                                        MODIFIED #hmodif ] > ] ],
                   CONT.HOOK comp-hook ],
           LOCAL.HAS-INTERJECTION -,
           LOCAL.HAS-PUNCT -,
           LOCAL.HAS-PERIOD -,
	   MODIFIED #modif ],
    C-CONT [ HOOK super-hook ] ].
 
basic-head-spec-tweak-phrase := head-valence-phrase & phrasal &
			  binary-headed-phrase &
  [ INFLECTED +,
    SYNSEM [ LOCAL.CAT [ VAL [ SUBJ #subj,
                               COMPS #comps,
                               SPR #spr,
                               SPEC list ],
                         POSTHEAD #ph ],
             MODIFIED #modif ],
    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
;    SYNSEM.LOCAL.MUST-CONNECT-PROJECT -,
    HEAD-DTR [ INFLECTED +,
;               HEAD-DTR.SYNSEM.LOCAL.MUST-COORDINATE -,
	       SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ #subj,
                                            COMPS #comps,
                                            SPR < #synsem & 
                                                  canonical-synsem . #spr >,
                                            SPEC list ],
                                      POSTHEAD #ph],
                                CONT.HOOK.INDEX #hdhook,
                                CONT.HOOK.XARG #xarg,
                                DERIVED-HEAD #2 ],
                        MODIFIED #hmodif ] ],
    NON-HEAD-DTR.SYNSEM #synsem &
	 [ LOCAL [ CAT [ VAL [ SPEC < [ LOCAL [ CAT.VAL.COMPS #comps,
                                                CONT.HOOK.LTOP #ltop,
						CONT.HOOK.INDEX #hdhook,
						CONT.HOOK.XARG #xarg,
                                                DERIVED-HEAD #2],
                                        MODIFIED #hmodif ] > ] ],
                   CONT.HOOK comp-hook ],
	   LOCAL.HAS-INTERJECTION -,
	   LOCAL.HAS-PUNCT -,
	   LOCAL.HAS-PERIOD -,
           MODIFIED #modif ],
    C-CONT [ HOOK super-hook ] ].
 
basic-head-spec-phrase := basic-head-spec-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #head,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD #head ] > ].

; PH 2003-dec-17: Took out the LEX link between the mother and the head 
; daughter. Let the phrase inherit from phrasal.
basic-head-comp-phrase := head-valence-phrase & head-compositional &
			  binary-headed-phrase & phrasal &
  [ SYNSEM canonical-synsem &
	   [ LOCAL.CAT [ VAL [ SUBJ #subj,
                               COMPS #comps,
                               SPR #spr ],
                         QVAL #qval,
                         POSTHEAD #ph ],
	     LOCAL.COMPS-BEGUN +,
	     LOCAL.HAS-WH-MOVED #front,
             NON-LOCAL [ REL 0-dlist  ]
		       ],
    FRONT-TO-FILL #front,
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ VAL [ SUBJ #subj,
                                        COMPS < #synsem . #comps >,
                                        SPR #spr ],
                                  QVAL #qval,
                                  POSTHEAD #ph ],
		      LOCAL.HAS-WH-MOVED #front],
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    HEAD-DTR.FRONT-TO-FILL #front, 
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-INTERJECTION -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL [ QUE 0-dlist & [ LIST null ] ],
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem & [ LOCAL.COORD-RELEASED +,
                                                       LOCAL.MUST-APP -  ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

#|
basic-head-comp-phrase := head-valence-phrase & head-compositional &
			  binary-headed-phrase & phrasal &
  [ SYNSEM canonical-synsem &
	   [ LOCAL.CAT [VAL [ SUBJ #subj,
                               COMPS #comps,
                               SPR #spr ],
                         QVAL #qval,
                         POSTHEAD #ph ],
             NON-LOCAL #3 ],
    FRONT-TO-FILL #front,
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ VAL [ SUBJ #subj,
                                        COMPS < #synsem . #comps >,
                                        SPR #spr ],
                                  QVAL #qval,
                                  POSTHEAD #ph ] ],
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.FRONT-TO-FILL #front, 
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #3 ,
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem & [ LOCAL.COORD-RELEASED +,
                                                       LOCAL.MUST-APP -  ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].
|#


; Unary rules for extraction

basic-extracted-arg-phrase := head-valence-phrase & head-only &
  [ SYNSEM.LEX - ].

basic-extracted-comp-phrase := basic-extracted-arg-phrase & 
                               head-compositional &
  [ SYNSEM canonical-synsem &
	   [ LOCAL.CAT [ VAL [ SUBJ #subj,
                               SPR #spr,
                               COMPS #comps,
			       ICOMPS #icomps],
			 QVAL #qval] ],
    HEAD-DTR [ SYNSEM 
	       [ LOCAL.CAT [ VAL [ SUBJ #subj,
                                   SPR #spr,
				   ICOMPS #icomps,
                                   COMPS < gap &
                                           [ NON-LOCAL.SLASH #slash ]
                                           . #comps > ],
			     QVAL #qval],
		 NON-LOCAL.SLASH #slash ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

;LH300513 just experimenting
basic-extracted-comp-phrase-2 := basic-extracted-arg-phrase & 
                               head-compositional &
  [ SYNSEM canonical-synsem &
	   [ LOCAL.CAT [ VAL [ SUBJ #subj,
                               SPR #spr,
                               COMPS #comps,
			       ICOMPS #icomps]] ],
    HEAD-DTR [ SYNSEM 
	       [ LOCAL.CAT [ VAL [ SUBJ #subj,
                                   SPR #spr,
				   ICOMPS #icomps,
                                   COMPS <  #comps . gap &
                                           [ NON-LOCAL.SLASH #slash ] > ]],
		 NON-LOCAL.SLASH #slash ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

basic-extracted-icomp-phrase := basic-extracted-arg-phrase & 
                               head-compositional &
  [ SYNSEM canonical-synsem &
	   [ LOCAL.CAT [ VAL [ SUBJ #subj,
                               SPR #spr,
			       COMPS #comps,
                               ICOMPS #icomps ]] ],
    HEAD-DTR [ SYNSEM 
	       [ LOCAL.CAT [ VAL [ SUBJ #subj,
                                   SPR #spr,
				   COMPS #comps,
                                   ICOMPS < gap &
                                           [ NON-LOCAL.SLASH #slash ]
                                           . #icomps > ]],
		 NON-LOCAL.SLASH #slash ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

basic-extracted-subj-phrase := basic-extracted-arg-phrase &
  [ SYNSEM.LOCAL.CAT [ VAL [ SUBJ < anti-synsem >,
                             SPR < >,
			     COMPS < > ]],
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ VAL [ SUBJ < gap &
					       [ LOCAL #local & local &
						       [ CONT.HOOK.INDEX 
                                                                ref-ind ] ] >,
        				COMPS olist ]],
		      NON-LOCAL.SLASH.LIST < #local > ] ].

; PH 2003-dec-17: Took out the COMPS <> and the HEAD-DTR ... COMPS olist 
; constraints in order to make it possible for sentence adverbs to attach to 
; the verb before the complements. ("Kari ser ikke Jon")
head-mod-phrase := head-nexus-phrase &
  [ SYNSEM [ LOCAL.CAT.VAL [ SUBJ #subj,
                             SPR #spr ],
             MODIFIED hasmod ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT.VAL [ SUBJ #subj,
                                      SPR #spr ],
                      NON-LOCAL [ REL 0-dlist ] ] ].

basic-extracted-adj-phrase := head-mod-phrase & head-only & phrasal.

extracted-adj-phrase := basic-extracted-adj-phrase &
  [ SYNSEM [ LOCAL.CAT [ POSTHEAD #ph],
	     NON-LOCAL.SLASH 1-dlist &
		   <! [ CAT [ POSTHEAD +,
                              HEAD [ MOD < [ LOCAL intersective-mod &
                                                   [ CAT [ HEAD #head,
                                                           VAL #val,
                                                           POSTHEAD #ph],
                                                     CONT.HOOK #hook,
                                                     CTXT #ctxt ] ] > ],
                              VAL [ SUBJ olist,
                                    COMPS olist,
                                    SPR olist ] ] ] !> ],
    HEAD-DTR.SYNSEM canonical-synsem &
	   [ LOCAL local &
		   [ CAT [ HEAD #head,
                           VAL #val & [ SUBJ < synsem-min &
                                               [ NON-LOCAL.SLASH 0-dlist ] > ],
			   POSTHEAD #ph],
                     CONT.HOOK #hook,
                     CTXT #ctxt ],
             NON-LOCAL.SLASH 0-dlist,
	     MODIFIED notmod ],
    C-CONT [ HOOK #hook,
	     HCONS <! !> ] ].



;;; ALTERED MATRIX TYPE - removed #agr, removed #val

#|
basic-head-mod-phrase-simple-sup := head-mod-phrase & binary-headed-phrase &
  [ SYNSEM [ NON-LOCAL [ SLASH [ LIST #first,
				 LAST #last ],
			 REL 0-dlist ] ],
    HEAD-DTR.SYNSEM 
           [ LOCAL [ CAT [ POSTHEAD #ph]],
             NON-LOCAL #nonloc  &
                   [ SLASH [ LIST #first,
                             LAST #middle ] ],
          MODIFIED #modif ],
    NON-HEAD-DTR.SYNSEM 
           [ LOCAL.CAT [ HEAD [ MOD < [ LOCAL local & 
                                              [ CAT [ POSTHEAD #ph]],
                                        NON-LOCAL #nonloc,
                                        MODIFIED #modif ] > ],
                         VAL [ COMPS olist,
                               SPR olist ]],
             NON-LOCAL [ SLASH [ LIST #middle,
                                 LAST #last ],
                         QUE 0-dlist & [ LIST null ] ] ]].

|#



basic-head-mod-phrase-simple-sup := head-mod-phrase & binary-headed-phrase &
  [ SYNSEM [ NON-LOCAL [ SLASH [ LIST #first,
				 LAST #last ],
			 REL 0-dlist ] ],
    HEAD-DTR.SYNSEM 
           [ LOCAL [ CAT [ POSTHEAD #ph]],
             NON-LOCAL #nonloc  &
                   [ SLASH [ LIST #first,
                             LAST #middle ] ],
          MODIFIED #modif ],
    NON-HEAD-DTR.SYNSEM 
           [ LOCAL.CAT [ HEAD [ MOD < [ LOCAL local & 
                                              [ CAT [ POSTHEAD #ph]],
                                        NON-LOCAL #nonloc,
                                        MODIFIED #modif ] > ],
                         VAL [ COMPS olist,
                               SPR olist ]],
             NON-LOCAL [ SLASH [ LIST #middle,
                                 LAST #last ],
                         QUE 0-dlist & [ LIST null ] ] ]].


basic-head-mod-phrase-simple := basic-head-mod-phrase-simple-sup  &
  [ SYNSEM [ LOCAL.CONT.HOOK #hdhook],
    HEAD-DTR.SYNSEM 
           [ LOCAL [  CAT.VAL #val,
		      CAT.HEAD #head,
	              CONT.HOOK #hdhook,
		      AGR #agr]],
    NON-HEAD-DTR.SYNSEM 
           [ LOCAL.CAT [ HEAD [ MOD < [ LOCAL [ CAT.VAL #val, 
						CAT.HEAD #head,
						CONT.HOOK #hdhook, 
						AGR #agr ]] > ]]]].


; introduced  NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #htop
head-mod-phrase-simple-sup := basic-head-mod-phrase-simple-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #htop,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #htop,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #htop ] >].

head-mod-phrase-simple := head-mod-phrase-simple-sup & basic-head-mod-phrase-simple.


;; ALTERED MATRIX TYPE - FOR MAL RULES

adj-head-phrase-sup := basic-head-mod-phrase-simple-sup & head-final &
  [ SYNSEM [ LOCAL.CAT.POSTHEAD #ph,
	     MODIFIED lmod ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT.POSTHEAD #ph],
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT [ VAL.COMPS < > ],
                          LOCAL.COORD-RELEASED +,
			  NON-LOCAL [ SLASH 0-dlist,
				      REL 0-dlist ] ] ].


adj-head-phrase := adj-head-phrase-sup & head-mod-phrase-simple &
  [ C-CONT.RELS <! !>  ].

;LH020513
adj-head-phrase-2 := adj-head-phrase-sup & head-mod-phrase-simple &
  [ C-CONT.RELS <! [] !>  ].

; changed  'notmod-or-rmod' to 'xmod' (LH Aug05)
;,
;			  NON-LOCAL.QUE 0-dlist
head-adj-phrase-sup := head-mod-phrase-simple-sup & head-initial & phrasal &
  [ SYNSEM [ LOCAL.CAT.POSTHEAD +,
	     MODIFIED rmod ],
    HEAD-DTR.SYNSEM.MODIFIED xmod,
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT.POSTHEAD + ,
			  NON-LOCAL.QUE 0-dlist] ].

head-adj-phrase := head-adj-phrase-sup & head-mod-phrase-simple &
  [ C-CONT.RELS <! !> ].
;LH020513
head-adj-phrase-2 := head-adj-phrase-sup & head-mod-phrase-simple &
  [ C-CONT.RELS <! [] !> ].

; LH emergency comm-out - - var-m_noid-head-mod-phrase-simple is not defined in the norsource/matrix path
var-m_noid-head-adj-phrase := head-adj-phrase-sup & var-m_noid-head-mod-phrase-simple.

; We split head-adj-phrase and adj-head-phrase into two each,
; one for intersective modifiers and one for scopal modifiers, in order to
; get desired results for recursive modification as in "apparently difficult
; problem" (cf. Kasper '98).  This split is also used in generation, where
; we delay construction of intersective modification, but not scopal.

scopal-mod-phrase := head-mod-phrase-simple &
  [ NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL scopal-mod ] >,
                                CONT.HOOK #hook ],
    C-CONT [ HOOK #hook,
             HCONS <! !> ] ].

adj-head-scop-phrase := adj-head-phrase & scopal-mod-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.POSTHEAD - ].
head-adj-scop-phrase := head-adj-phrase & scopal-mod-phrase &
  [ NON-HEAD-DTR.SYNSEM.NON-LOCAL.REL 0-dlist ].
;adj-head-int-phrase := adj-head-phrase & isect-mod-phrase &
;  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ POSTHEAD - ] ].
;head-adj-int-phrase := head-adj-phrase & isect-mod-phrase.



;;; ADDENDUM to basic-head-filler-phrase

basic-head-filler-phrase :+ 
[ SYNSEM.LOCAL.CAT.VAL.SUBJ #subj,
  ARGS < [ ], [ SYNSEM.LOCAL.CAT.VAL.SUBJ #subj ] > ].

;;; MHS 040713 Thinking of adding some new restrictions on punctuation. Essentialy, in the mal-grammar, bon-inversion must be marked with a question mark.

local :+ 
[ NEED-Q-MARK bool ].


basic-unary-phrase :+
[ SYNSEM.LOCAL.NEED-Q-MARK #bool,
  ARGS < [ SYNSEM.LOCAL.NEED-Q-MARK #bool ] > ].

head-valence-phrase :+ 
[ SYNSEM.LOCAL.NEED-Q-MARK #bool,
  HEAD-DTR.SYNSEM.LOCAL.NEED-Q-MARK #bool ].

head-final :+
[ SYNSEM.LOCAL.NEED-Q-MARK #bool,
  ARGS < [], [ SYNSEM.LOCAL.NEED-Q-MARK #bool ] > ].

;;; MHS 120713 Adding in an attribute to be used in the mal-grammar to block certain bon-rules form being active. 


sign-min :+ 
[ --A bool ].

#|
;;; MHS 120713 It seems reasonable that the value of SYNSEM.LOCAL.IS-A-COMPLEMENT should be preserved along the head path. 

headed-phrase :+
[ SYNSEM.LOCAL.IS-A-COMPLEMENT #bool,
  HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT #bool ].
|#

;;; MHS 180713 As far as I can tell, FRONT-TO-FILL's value should only be altered by head final rules, and as such, it would not be unreasonable for the mother's FRONT-TO-FILL value to be indentical to the daughter's in head initial rules. 

head-initial :+ 
[  FRONT-TO-FILL #bool, 
   HEAD-DTR.FRONT-TO-FILL #bool ].
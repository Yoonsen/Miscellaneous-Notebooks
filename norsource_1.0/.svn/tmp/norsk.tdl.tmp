
;;; -*- Mode: tdl; Coding: utf-8; -*-
;;;

;;;              - NorSource -
;;; 
;;;    Copyright (c)  NorSource version 1.0
;;;
;;;    Lars Hellan, Mads H. Sand√∏y, Elias Aamot, Tore Bruland
;;;                         and
;;;                      Dan Flickinger
;;;                        2010-11
;;;
;;;            Earlier developments: 
;;;            2004-2008 Lars Hellan, Dorothee Beermann, Ben Waldron
;;;            2001-2003 Lars Hellan, Petter Haugereid
;;;    
;;;
;;;    Norwegian University of Science and Technology, 7491 Trondheim
;;;    ==================================================================
;;;
;;;    
;;;                   norsk.tdl
;
;;;              Basic definitions of types
;;;
;;;           based on HPSG Grammar Matrix 0.6

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  ORDER OF PRESENTATION:

;; 1. Relation types
;; 2. Specifications under HOOK
;;   a. dirhook - - DIRARG
;;   b. augm-ref-ind - - BOUNDED
;;   c. PNG values
;;   d. SORT values for nouns
;;   e. SORT values for verbs
;;   f. TENSE and MOOD values
;; 3. HEAD values
;; 4. Basic lex-item types
;; 5. WORD types
;; 6. LEXEME types
;; 7. PHRASE types
;; 8. SYNSEM types
;; 9. VAL, QVAL and CAT types
;; 10. Lexical rules, for Passive, V-to-A, A-to-N, Q-to-N,... 


;;;;;;; DPF addenda



sign-min :+
  [ STEM orthog ].

word-or-lexrule :+
  [ STEM.FORM #form,
    TOKENS tokens & [ +LIST < [ +FORM #form ], ... > ] ].

orthog := cons &
  [ FORM string,
    FROM string,
    TO string ].

never_unify_lr := lex-rule &
  [ INFLECTED -,
    STEM < "_never_unify" >,
    SYNSEM.LOCAL.CAT.HEAD no-head,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD no-head,
	     INFLECTED + ] > ].

no-head := head.

;;;;;;; 1. Relation types

def-q-rel := quant-relation &
 [PRED "_def_q_rel"].

indef-q-rel := quant-relation.

plurindef-q-rel := quant-relation &
 [PRED "_plurindef_q_rel"].

contextual-q-rel := quant-relation &
 [PRED "_pronoun_q_rel"].

reflexive-q-rel := quant-relation &
 [PRED "_reflpronoun_q_rel"].

interrog-q-rel := quant-relation.
; &
; [PRED "_interrog_q_rel"].

expletive-q-rel := quant-relation-sup &
 [PRED "_expletive_q_rel"].

card-relation := const-relation &
  [ PRED "_card_rel" ].

card-arg1-relation := card-relation & arg1-relation.

adj_rel := ad-rel & arg1-relation.
; for comparative-roles - but it created problems...
;adj_rel := ad-rel & arg1-relation &
; [ ARG0.ROLE #1,
;   ARG1.ROLE #1 ].
adj0_rel := ad-rel.

familiar-rel := noun-relation & [ PRED "_familiar_c_rel"].
asserted-id-rel := arg1-relation &
  [ PRED "_asserted_id_rel" ].
familiarity-rel := arg1-relation &
  [ PRED "_familiar_c_rel" ].

fpos_prom_rel := arg1-relation &
[ PRED "first_position_prominent"].

  
deictic-rel := noun-relation.

pron_rel := noun-relation.

pers-pron-rel := pron_rel.
res-pron-rel := pron_rel &
  [ PRED "_res_pron_rel" ].
rel_pron_rel := pron_rel &
  [ PRED "_rel_pron_rel" ].
vp-rel_pron_rel := event-relation &
  [ PRED "_rel_pron_rel" ].

#|
1st-pers-pron-rel := pers-pron-rel &
  [ ARG0.PNG.PERS firstpers ].
1st-sg-pers-pron-rel := 1st-pers-pron-rel &
  [PRED "_1sg_pron_rel" ].
1st-pl-pers-pron-rel := 1st-pers-pron-rel &
  [PRED "_1pl_pron_rel" ].

2nd-pers-pron-rel := pers-pron-rel &
  [ ARG0.PNG.PERS secpers ].
2nd-sg-pers-pron-rel := 2nd-pers-pron-rel &
  [PRED "_2sg_pron_rel" ].
2nd-pl-pers-pron-rel := 2nd-pers-pron-rel &
  [PRED "_2pl_pron_rel" ].

3rd-pers-pron-rel := pers-pron-rel &
  [ ARG0.PNG.PERS thirdpers ].
3rd-sg-pers-pron-rel := 3rd-pers-pron-rel &
  [PRED "_3sg_pron_rel",
   ARG0.PNG 3sg ].
3rd-pl-pers-pron-rel := 3rd-pers-pron-rel &
  [PRED "_3pl_pron_rel",
   ARG0.PNG 3pl ].
3rd-wh-pers-pron-rel := 3rd-pers-pron-rel &
  [PRED "_3wh_pron_rel" ].
|#

1st-pers-pron-rel := pers-pron-rel &
  [ ARG0.PNG.PERS firstpers ].
1st-sg-pers-pron-rel := 1st-pers-pron-rel &
  [PRED "_pron_rel" ].
1st-pl-pers-pron-rel := 1st-pers-pron-rel &
  [PRED "_pron_rel" ].

2nd-pers-pron-rel := pers-pron-rel &
  [ ARG0.PNG.PERS secpers ].
2nd-sg-pers-pron-rel := 2nd-pers-pron-rel &
  [PRED "_pron_rel" ].
2nd-pl-pers-pron-rel := 2nd-pers-pron-rel &
  [PRED "_pron_rel" ].

3rd-pers-pron-rel := pers-pron-rel &
  [ ARG0.PNG.PERS thirdpers ].
3rd-sg-pers-pron-rel := 3rd-pers-pron-rel &
  [PRED "_pron_rel",
   ARG0.PNG 3sg ].
3rd-pl-pers-pron-rel := 3rd-pers-pron-rel &
  [PRED "_pron_rel",
   ARG0.PNG 3pl ].
3rd-wh-pers-pron-rel := 3rd-pers-pron-rel &
  [PRED "_pron_rel" ].

refl-pron-rel := pron_rel.

1st-refl-pron-rel := refl-pron-rel.
1st-sg-refl-pron-rel := 1st-refl-pron-rel &
  [PRED "_1sg_refl_rel"].
1st-pl-refl-pron-rel := 1st-refl-pron-rel &
  [PRED "_1pl_refl_rel" ].

2nd-refl-pron-rel := refl-pron-rel.
2nd-sg-refl-pron-rel := 2nd-refl-pron-rel &
  [PRED "_2sg_refl_rel" ].
2nd-pl-refl-pron-rel := 2nd-refl-pron-rel &
  [PRED "_2pl_refl_rel" ].

3rd-refl-pron-rel := refl-pron-rel &
  [PRED "_3p_refl_rel",
   ARG0.PNG.PERS thirdpers ].

same-rel := arg1-relation &
  [PRED "_same-as-mntd_rel" ].

context_understood_pron_rel := pron_rel &
  [ PRED "zero_pron_context_corr_rel" ].

partitive-rel := arg12-relation &
  [ PRED "_member-of-set_rel",
    ARG0 individual,
    ARG1 ref-ind,
    ARG2 ref-ind ].

reside-in-rel := arg12-relation &
  [ PRED "_reside-in_c_rel",
    ARG0 individual,
    ARG1 individual,
    ARG2 individual ].

;partitive-ersatz-rel := arg65-rel &
;  [ PRED "_instantiate_c_rel" ].

poss-rel := arg12-ev-relation &
  [ PRED "_poss_c_rel",
    ARG1 ref-ind,
    ARG2 ref-ind ].

possessed-by-rel := prep-mod-relation &
  [ PRED "_possessed_by_rel",
    ARG1 ref-ind,
    ARG2 ref-ind ].

related-rel := arg12-ev-relation &
  [ PRED "_related_to_rel",
    ARG1 ref-ind,
    ARG2 ref-ind ].

measure-out-rel := arg12-relation &
  [ PRED "_measure_out_rel",
    ARG1 individual & [ ROLE #1 ],
    ARG2 individual & [ ROLE #1 ] ].

accumulate-rel := arg12-relation &
  [ PRED "_accumulate-unit-subunit_rel",
    ARG1 handle,
    ARG2 handle ].

compound-rel := arg12-relation &
  [ PRED "_compound_rel",
    ARG1 ref-ind,
    ARG2 ref-ind ].

compare-rel := arg12-relation &
  [ ARG1 individual & [ ROLE compare-top ],
    ARG2 individual & [ ROLE compare-ref ]].

cntxt-prpt-rel := arg1-relation &
  [ ARG1 ref-ind & [SORT cntxt-given ]].



agent-rel := arg12-ev-relation &
  [ PRED "_agent_of_rel",
    ARG1 ref-ind,
    ARG2 ref-ind ].

undergoer-rel := arg12-ev-relation &
  [ PRED "_undergoer_of_rel",
    ARG1 ref-ind,
    ARG2 ref-ind ].

conj-q-rel := quant-relation &
  [ PRED "_conjoined_q_rel" ].

conj-q-ev-rel := quant-event-relation &
  [ PRED "_conjoined_q_rel" ].
;conj-q-ev-rel := quant-event-relation.

argx-relation := event-relation &
  [ ARGX handle ].

arg2x-relation := arg12-relation & argx-relation.

arg1x-relation := arg1-relation & argx-relation.

arg12x-relation := arg12-relation & argx-relation.

arg123x-relation := arg123-relation & argx-relation.

; the following were used in the "Hit and dit" Trollheim grammar
#|
place-rel := prep-mod-relation & 
  [ARG0.SORT place,
   ARG1 individual ].

externrelated-place-rel := place-rel & 
  [ARG2 ref-ind & [SORT full-thing] ].

internrelated-place-rel := place-rel &
  [ARG2 ref-ind & [SORT correlate] ].

; 'correlate' is intended as a discourse-fixed value, such as a speaker
; in 'close-to-corr' and some landmark in 'lower-than-corr'

vertical-internrelated-place-rel := internrelated-place-rel &
  [ARG2.SORT landmark ].

proxim-internrelated-place-rel := internrelated-place-rel &
  [ARG2.SORT speaker ].
|#


ad-rel := arg0-relation &
  [ ARG0 ad-event].

orient-rel := ad-rel &
  [ ARG0 orient-event].
;orient-adv-rel := orient-rel & arg1-relation & 
;  [ ARG0.SORT verb-act-specification,
;    ARG0.ORIENT orient ].
orient-adv-rel := orient-rel & arg1-relation & 
  [ ARG0.ORIENT orient ].
iarg-orient-adv-relation := iarg-relation & orient-adv-rel.

loc-rel := ad-rel.

; of use if LEGs were also operative with adverbs - currently not
;leg-rel := loc-rel &
;  [ LEG individual ].

adv-mod-relation := arg1-relation & loc-rel.

prep-mod-relation := loc-rel & arg12-relation.

; to facilitate integration with predsort

;prep-path-rel :=  loc-rel & arg12-relation &
;  [ ARG1 ref-ind,
;    ARG2 ref-ind,
;    LEG individual].

prep-line-rel :=  loc-rel & arg12-relation.
prep-fixpoint-line-rel := prep-line-rel &
  [ ARG0.SORT fix-point-motion ].
prep-nonfixpoint-line-rel := prep-line-rel &
  [ ARG0.SORT non-fix-point ].

; this ARG0 specification makes visible both for adverbs like "hit" and
; PPs like "til skogen" that they have a property inducing telicity.
; No subtype of 'prep-path-rel' fixes a PRED value, since in principle, we want
 ; a lexical item to be able to fill in this value itself, as when the item 
; is a preposition. 

end-of-path-rel := prep-fixpoint-line-rel &
  [ ARG0.SORT end-of-path-motion,
    ARG2.SORT endpnt-of-path ].
beginning-of-path-rel := prep-fixpoint-line-rel &
  [ ARG2.SORT startpnt-of-path ].
via-path-rel := prep-fixpoint-line-rel &
  [ ARG2.SORT via-pnt-of-path ].
along-path-rel := prep-nonfixpoint-line-rel &
  [ ARG0.SORT along-path-motion,
    ARG2.SORT path-followed ].

obl-relation := event-relation &
  [ ARGOBLQ semarg ].
arg0obl-rel := obl-relation.
arg1obl-rel := arg1-relation & obl-relation.
arg12obl-rel := arg12-relation & obl-relation.
arg123obl-rel := arg123-relation & obl-relation.

argxobl-rel := argx-relation & arg0obl-rel.




;;; 2. SPECIFICATIONS UNDER 'HOOK' ( SYNSEM.CONTENT.HOOK...)

; INDEX values for nouns (...HOOK.INDEX ref-ind & [PNG png /SORT semsort..].)

augm-ref-ind := ref-ind &
  [ BOUNDED bool ].

; PNG values
;; obsolete
;mascsg-sup := sg & masc.
;femsg-sup := sg & fem.
;mascsg := mascsg-sup.
;femsg := femsg-sup.
;commsg := mascsg-sup & femsg-sup.

; active
png := avm &
  [ NG ng,
    PERS pers ].
ng := avm &
 [ NUM num, GEN gen].

num := avm.
gen := avm.

pers := avm.

number := ng .
sg := number & [ NUM sing].
pl := number & [ NUM plur].
sing := num.
plur := num.

gender := ng.
; lh Dec01-06 - to avoid "absorpsjonsevnene[mascorfem] smiler" getting a parse by the neuter infl-rule, and "adelskapene[mascorneut] smiler" getting a parse by the fem infl-rule
;f := gen.
;m := gen.
;n := gen.
m-or-f := gen.
m-or-n := gen.
m := m-or-f & m-or-n.
f := m-or-f.
n := m-or-n.

neut-or-masc := gender & [ GEN m-or-n].
neut := neut-or-masc & [ GEN n].
;; [bmw] what exactly is the difference between non-neut and masc-or-fem?
;;       i've replaced references to non-neut by masc-or-fem
;;non-neut := masc & fem.
; FIXME should be neut-sg
neutsg := sg & neut.
; changed to masc-or-fem-pl [???]
;;commpl := pl & non-neut.
; FIXME should be neut-pl
neutpl := pl & neut.

masc-or-fem := gender & [ GEN m-or-f].
masc := neut-or-masc & masc-or-fem & [ GEN m].
fem := masc-or-fem & [ GEN f].

masc-or-fem-sg := sg & masc-or-fem.
masc-or-fem-pl := pl & masc-or-fem.
masc-sg := masc & masc-or-fem-sg.
fem-sg := fem & masc-or-fem-sg.
masc-pl := masc & masc-or-fem-pl.
fem-pl := fem & masc-or-fem-pl.

firstpers := pers.
secpers := pers.
thirdpers := pers.
1sg := png &
  [ NG sg,
    PERS firstpers ].
1pl := png &
  [ NG pl,
    PERS firstpers ].
2sg := png &
  [ NG sg,
    PERS secpers ].
2pl := png &
  [ NG pl,
    PERS secpers ].
3sg := png &
  [ NG sg,
    PERS thirdpers ].
3pl := png &
  [ NG pl,
    PERS thirdpers ].
3msg := 3sg &
  [ NG masc-sg ].
3fsg := 3sg &
  [ NG fem-sg ].
3nsg := 3sg &
  [ NG neutsg ].



; SORT values (for nouns)

; semsort-reg := semsort.(defined under SORT-verb)
item-specification := semsort-reg.
endpnt-of-path := referential-thing.
anim-endpnt-of-path := endpnt-of-path & anim-thing & full-thing.
inan-endpnt-of-path := endpnt-of-path & inan-thing & full-thing.
startpnt-of-path := referential-thing.
anim-startpnt-of-path := startpnt-of-path & anim-thing & full-thing.
inan-startpnt-of-path := startpnt-of-path & inan-thing & full-thing.
via-pnt-of-path := referential-thing.
anim-viapnt-of-path := via-pnt-of-path & anim-thing & full-thing.
inan-viapnt-of-path := via-pnt-of-path & inan-thing & full-thing.
path-followed := referential-thing.
anim-path-followed := path-followed & anim-thing & full-thing.
inan-path-followed := path-followed & inan-thing & full-thing.
anim-1dim-endpnt-of-path := endpnt-of-path & anim-thing & one-dim-thing.
inan-1dim-endpnt-of-path := endpnt-of-path & inan-thing & one-dim-thing.
anim-1dim-startpnt-of-path := startpnt-of-path & anim-thing & one-dim-thing.
inan-1dim-startpnt-of-path := startpnt-of-path & inan-thing & one-dim-thing.
anim-1dim-viapnt-of-path := via-pnt-of-path & anim-thing & one-dim-thing.
inan-1dim-viapnt-of-path := via-pnt-of-path & inan-thing & one-dim-thing.
anim-1dim-path-followed := path-followed & anim-thing & one-dim-thing.
inan-1dim-path-followed := path-followed & inan-thing & one-dim-thing.

orientation-corr := full-thing.
orientation-target := orientation-corr.
orientation-direction := orientation-corr.
target-of-orient := full-thing.
starttime-of-motion := item-specification.
measure-unit := item-specification.
path-unit := measure-item.
event-unit := measure-item.
; doubled in predsorts.tdl.
time-item := measure-unit.
measure-item := measure-unit.
length-unit := measure-item.
inner-obj-unit := length-unit & event-unit & path-unit.
weight-unit := measure-item.
volume-unit := measure-item.
amount-unit := measure-item.
;to enable "tusen og tretti" as N-coordination:
;card-unit := measure-item.
card-unit := number-unit.
;card-unit := measure-item & referential-thing.
path-as-card-unit := path-unit & card-unit.
time-as-card-unit := time-item & card-unit.
length-as-card-unit := length-unit & card-unit.
amount-as-card-unit := amount-unit & card-unit.
anim-card-unit := card-unit & anim-thing.
inanim-card-unit := card-unit & inan-thing.
;anim-card-unit := card-unit & animfull-thing.
;inanim-card-unit := card-unit & inanfull-thing.
number-unit := measure-item.
;number-unit := measure-item & referential-thing.
path-as-number-unit := path-unit & number-unit.
time-as-number-unit := time-item & number-unit.
length-as-number-unit := length-unit & number-unit.
anim-number-unit := number-unit & anim-thing.
inanim-number-unit := number-unit & inan-thing.
;anim-number-unit := number-unit & animfull-thing.
;inanim-number-unit := number-unit & inanfull-thing.

body-part := item-specification.
relatum := referential-thing.
init-und := item-specification.
init-or-actor := init-und.
init := init-or-actor.
und-or-theme := init-und.
und := und-or-theme.
actor := init-or-actor.
theme := und-or-theme.
endtime-of-motion := item-specification.
one-dim-thing := referential-thing.
one-dim-thing-path := one-dim-thing.
one-dim-thing-vehicle := one-dim-thing.
xdim-thing := full-thing.
referential-thing := item-specification.
inher-compl := referential-thing.
full-thing := referential-thing.
anim-thing := item-specification.
inan-thing := item-specification.
indiv-kind := full-thing.
correlate := full-thing.
animfull-thing := full-thing & anim-thing.
inanfull-thing := full-thing & inan-thing.
anim-relatum := relatum & anim-thing.
inan-relatum := relatum & inan-thing.

anim-relatum-endpnt-of-path := anim-relatum & endpnt-of-path.
inan-relatum-endpnt-of-path := inan-relatum & endpnt-of-path.
anim-relatum-viapnt-of-path := anim-relatum & via-pnt-of-path.
inan-relatum-viapnt-of-path := inan-relatum & via-pnt-of-path.
anim-relatum-startpnt-of-path := anim-relatum & startpnt-of-path.
inan-relatum-startpnt-of-path := inan-relatum & startpnt-of-path.
anim-relatum-path-followed := anim-relatum & path-followed.
inan-relatum-path-followed := inan-relatum & path-followed.


speaker := correlate.
hearer := correlate.
landmark := correlate.
cntxt-given := correlate.


indirquest-prep := semsort-reg.



; SORT values (for verbs)

semsort-reg := semsort.
verb-act-specification := semsort-reg.
non-fix-point := verb-act-specification.
direction := verb-act-specification.
fix-point-motion := verb-act-specification.
path-related-motion := direction.
orientation := non-fix-point & direction.
end-of-path-motion := path-related-motion & fix-point-motion.
beg-of-path-motion := path-related-motion & fix-point-motion.
via-path-motion := path-related-motion & fix-point-motion.
along-path-motion := path-related-motion & non-fix-point.
place := non-fix-point.
time := non-fix-point.

telmarking := semsort.
accomplishment-time := telmarking.
duration-time := telmarking.

correlated-event := non-fix-point.

correlated-event-time := correlated-event.
correlated-event-place := correlated-event.
correlated-event-condition := correlated-event.

orientsort := avm.
orient := orientsort.
in-or-out := orient.
to-in := in-or-out.
to-out := in-or-out.
up-or-down := orient.
to-up := up-or-down.
to-down := up-or-down.
close-or-far := orient.
to-close := close-or-far.
to-far := close-or-far.
to-forth := close-or-far.
to-home := close-or-far.
ahead-or-back := orient.
to-ahead := ahead-or-back.
to-back := ahead-or-back.
at-or-awayfrom-salientpoint := orient.
to-at-salientpoint := at-or-awayfrom-salientpoint.
to-awayfrom-salientpoint := at-or-awayfrom-salientpoint.
to-right-or-left := orient.
to-right := to-right-or-left.
to-left := to-right-or-left.
to-along := orient.
in-compass-direction := orient.
to-south := in-compass-direction.
to-north := in-compass-direction.
to-east := in-compass-direction.
to-west := in-compass-direction.


place-param := place.
at-in-or-out := place-param.
at-in := at-in-or-out.
at-out := at-in-or-out.
at-up-or-down := place-param.
at-up := at-up-or-down.
at-down := at-up-or-down.
at-close-or-far := place-param.
at-close := at-close-or-far.
at-far := at-close-or-far.
at-home := at-close-or-far.
at-ahead-or-back := place-param.
at-ahead := at-ahead-or-back.
at-back := at-ahead-or-back.
at-on-or-awayfrom-salientpoint := place-param.
at-salientpoint := at-on-or-awayfrom-salientpoint.
at-awayfrom-salientpoint := at-on-or-awayfrom-salientpoint.
at-right-or-left := place-param.
at-right := at-right-or-left.
at-left := at-right-or-left.
at-compass-direction := place-param.
at-south := at-compass-direction.
at-north := at-compass-direction.
at-east := at-compass-direction.
at-west := at-compass-direction.

startpnt-at-in := at-in & startpnt-of-path.
startpnt-at-out := at-out & startpnt-of-path.
startpnt-at-up := at-up & startpnt-of-path.
startpnt-at-down := at-down & startpnt-of-path.
startpnt-at-close := at-close & startpnt-of-path.
startpnt-at-far := at-far & startpnt-of-path.
startpnt-at-home := at-home & startpnt-of-path.
startpnt-at-ahead := at-ahead & startpnt-of-path.
startpnt-at-back := at-back & startpnt-of-path.
startpnt-at-salientpoint := at-salientpoint & startpnt-of-path.
startpnt-at-awayfrom-salientpoint := at-awayfrom-salientpoint.
startpnt-at-right := at-right & startpnt-of-path.
startpnt-at-left := at-left & startpnt-of-path.
startpnt-at-south := at-south & startpnt-of-path.
startpnt-at-north := at-north & startpnt-of-path.
startpnt-at-east := at-east & startpnt-of-path.
startpnt-at-west := at-west & startpnt-of-path.

; for use on EXTRINSIC-ORD:
noncomplete-imp := sort.
complete-imp := sort.


;;; for use in KEYS.KEY:


adhoc-norm := predsort.
adhoc-abnorm := propt.
som-cmpar := adhoc-abnorm.
enn-cmpar := adhoc-abnorm.
interr-word := non-measurnoun.
qkey := quantas.
posspcl := weaklic.
possprn := weaklic.
coordinator := adhoc-norm.
punctuator := adhoc-norm.
degreer := adhoc-norm.
weaklic := adhoc-norm.
adjquant-pre := adhoc-norm.
adjquant-fleste := adjquant-pre.
adjquant-f√¶rreste := adjquant-pre.
adjquant-post := adhoc-norm.

;;;;;;;
om-k := predsort.
p√•-k := predsort.
innp√•-k := predsort.
inni-k := predsort.
innenfor-k := predsort.
med-k := predsort.
mot-k := predsort.
overfor-k := predsort.
av-k := predsort.
til-k := predsort.
som-k := predsort.
for-k := predsort.
over-k := predsort.
i-k := predsort.
etter-k := predsort.
fra-k := predsort.
der-n√•r-k := predsort.
ang√•ende-k := predsort.
bak-k := predsort.
blant-k := predsort.
rundt-k := predsort.
foran-k := predsort.
gjennom-k := predsort.
igjennom-k := predsort.
langs-k := predsort.
under-k := predsort.
ved-k := predsort.
uten-k := predsort.
borti-k := predsort.

ut-k := predsort.
opp-k := predsort.
ned-k := predsort.
bort-k := predsort.
frem-k := predsort.
inn-k := predsort.
ferdig-k := predsort.

s√•-k := predsort.
videre-k := predsort.
deretter-k := predsort.
halvveis-k := predsort.
og-k := predsort.
ikke-k := predsort.
kanskje-k := predsort.
neppe-k := predsort.
heller-k := predsort.
sannsynligvis-k := predsort.
virkelig-k := predsort.
antakeligvis-k := predsort.
antageligvis-k := predsort.
antagelig-k := predsort.
antakelig-k := predsort.
trolig-k := predsort.
aldri-k := predsort.
alltid-k := predsort.
sjelden-k := predsort.
tidligere-k := predsort.
ofte-k := predsort.
heldigvis-k := predsort.
for-eksempel-k := predsort.
nettopp-k := predsort.
akkurat-k := predsort.
ogs√•-k := predsort.
forresten-k := predsort.
faktisk-k := predsort.
just-k := predsort.
igjen-k := predsort.
likevel-k := predsort.
vel-k := predsort.
derfor-k := predsort.
gjerne-k := predsort.
alternativt-k := predsort.
dessverre-k := predsort.
dessuten-k := predsort.
dernest-k := predsort.
derimot-k := predsort.
tydeligvis-k := predsort.
nok-k := predsort.
deriblant-k := predsort.
engang-k := predsort.
for-det-meste-k := predsort.
f√∏r-k := predsort.
hinsides-k := predsort.
hos-k := predsort.
mellom-k := predsort.
n√¶r-k := predsort.
omkring-k := predsort.
oppi-k := predsort.

; nom-k is the leaf of leaves!
;leir-k := nom-k.
;fl√∏yten-k := nom-k.
;has-k := nom-k.
leir-k := predsort.
fl√∏yten-k := predsort.
has-k := predsort.
m√•l-k := predsort.
d√∏d-k := predsort.
m√•te-k := relinan.
fare-k := relinan.
sang-k := relinan.
;;;;;;;

selct := adhoc-norm.
non-selct := adhoc-norm.
; for detach-poss
detch := actv-prep & prim-mod.
p√•-detch := detch & p√•-k.
i-detch := detch & i-k.

fct-spec := index-sitA.
actv-prep := adhoc-norm.
pass-prep := adhoc-norm.
fct-actv-spec := fct-spec & actv-prep.
fct-pass-spec := fct-spec & pass-prep.

om-fct-spec := fct-spec & om-k.
p√•-fct-spec := fct-spec & p√•-k.
innp√•-fct-spec := fct-spec & innp√•-k.
inni-fct-spec := fct-spec & inni-k.
innenfor-fct-spec := fct-spec & innenfor-k.
med-fct-spec := fct-spec & med-k.
mot-fct-spec := fct-spec & mot-k.
overfor-fct-spec := fct-spec & overfor-k.
av-fct-spec := fct-spec & av-k.
gjennom-fct-spec := fct-spec & gjennom-k.
igjennom-fct-spec := fct-spec & igjennom-k.
til-fct-spec := fct-spec & til-k.
som-fct-spec := fct-spec & som-k.
for-fct-spec := fct-spec & for-k.
over-fct-spec := fct-spec & over-k.
i-fct-spec := fct-spec & i-k.
borti-fct-spec := fct-spec & borti-k.
under-fct-spec := fct-spec & under-k.
bak-fct-spec := fct-spec & bak-k.
foran-fct-spec := fct-spec & foran-k.
rundt-fct-spec := fct-spec & rundt-k.
etter-fct-spec := fct-spec & etter-k.
fra-fct-spec := fct-spec & fra-k.
der-n√•r-fct-spec := fct-spec & der-n√•r-k.
ang√•ende-fct-spec := fct-spec & ang√•ende-k.
mellom-fct-spec := fct-spec & mellom-k.
ved-fct-spec := fct-spec & ved-k.

om-fctactv-spec := fct-actv-spec & om-fct-spec & non-clse.
p√•-fctactv-spec := fct-actv-spec & p√•-fct-spec & non-clse.
med-fctactv-spec := fct-actv-spec & med-fct-spec & non-clse.
mot-fctactv-spec := fct-actv-spec & mot-fct-spec & non-clse.
overfor-fctactv-spec := fct-actv-spec & overfor-fct-spec & non-clse.
for-fctactv-spec := fct-actv-spec & for-fct-spec & non-clse.
av-fctactv-spec := fct-actv-spec & av-fct-spec & non-clse.
til-fctactv-spec := fct-actv-spec & til-fct-spec & non-clse.
som-fctactv-spec := fct-actv-spec & som-fct-spec & non-clse.
over-fctactv-spec := fct-actv-spec & over-fct-spec & non-clse.
i-fctactv-spec := fct-actv-spec & i-fct-spec & non-clse.
borti-fctactv-spec := fct-actv-spec & borti-fct-spec & non-clse.
der-n√•r-fctactv-spec := fct-actv-spec & der-n√•r-fct-spec & non-clse.
etter-fctactv-spec := fct-actv-spec & etter-fct-spec & non-clse.
ved-fctactv-spec := fct-actv-spec & ved-fct-spec & non-clse.
mellom-fctactv-spec := fct-actv-spec & mellom-fct-spec & non-clse.
ang√•ende-fctactv-spec := fct-actv-spec & ang√•ende-fct-spec & non-clse.
gjennom-fctactv-spec := fct-actv-spec & gjennom-fct-spec & non-clse.

om-fctpass-spec := fct-pass-spec & om-fct-spec.
p√•-fctpass-spec := fct-pass-spec & p√•-fct-spec.
med-fctpass-spec := fct-pass-spec & med-fct-spec.
mot-fctpass-spec := fct-pass-spec & mot-fct-spec.
overfor-fctpass-spec := fct-pass-spec & overfor-fct-spec.
av-fctpass-spec := fct-pass-spec & av-fct-spec.
til-fctpass-spec := fct-pass-spec & til-fct-spec.
som-fctpass-spec := fct-pass-spec & som-fct-spec.
over-fctpass-spec := fct-pass-spec & over-fct-spec.
i-fctpass-spec := fct-pass-spec & i-fct-spec.
borti-fctpass-spec := fct-pass-spec & borti-fct-spec.
der-n√•r-fctpass-spec := fct-pass-spec & der-n√•r-fct-spec.
etter-fctpass-spec := fct-pass-spec & etter-fct-spec.
ved-fctpass-spec := fct-pass-spec & ved-fct-spec.
mellom-fctpass-spec := fct-pass-spec & mellom-fct-spec.
ang√•ende-fctpass-spec := fct-pass-spec & ang√•ende-fct-spec.
gjennom-fctpass-spec := fct-pass-spec & gjennom-fct-spec.

con-communic-act := fct-spec.
med-concumm := con-communic-act & med-fct-spec.
om-concumm := con-communic-act & om-fct-spec.
instr := fct-spec.
med-instr := instr & med-fct-spec.
topic-of := fct-spec. 
om-topic-of := topic-of & om-fct-spec.
p√•-topic-of := topic-of & p√•-fct-spec.
adverse := fct-spec.
mot-adverse := adverse & mot-fct-spec.
overfor-adverse := adverse & overfor-fct-spec.
basis-of := fct-spec.
p√•-basis-of := basis-of & p√•-fct-spec.

assoc-act := fct-spec.
med-assoc := assoc-act & med-fct-spec.
p√•-assoc := assoc-act & p√•-fct-spec.
til-assoc := assoc-act & til-fct-spec.
for-assoc := assoc-act & for-fct-spec.
av-assoc := assoc-act & av-fct-spec.
i-assoc := assoc-act & i-fct-spec.

med-act-assoc := med-assoc & med-fctactv-spec.
p√•-act-assoc := p√•-assoc & p√•-fctactv-spec.
til-act-assoc := til-assoc & til-fctactv-spec.
for-act-assoc := for-assoc & for-fctactv-spec.
av-act-assoc := av-assoc & av-fctactv-spec.
i-act-assoc := i-assoc & i-fctactv-spec.


med-act-concumm := med-concumm & med-fctactv-spec.
med-act-instr := med-instr & med-fctactv-spec.
om-act-topic-of := om-topic-of & om-fctactv-spec.
p√•-act-topic-of := p√•-topic-of & p√•-fctactv-spec.
mot-act-adverse := mot-adverse & mot-fctactv-spec.
overfor-act-adverse := overfor-adverse & overfor-fctactv-spec.
p√•-act-basis-of := p√•-basis-of & p√•-fctactv-spec.


med-pass-concumm := med-concumm & med-fctpass-spec & non-clse.
med-pass-instr := med-instr & med-fctpass-spec & non-clse.
om-pass-topic-of := om-topic-of & om-fctpass-spec & non-clse.
p√•-pass-topic-of := p√•-topic-of & p√•-fctpass-spec & non-clse.
mot-pass-adverse := mot-adverse & mot-fctpass-spec & non-clse.
overfor-pass-adverse := overfor-adverse & overfor-fctpass-spec & non-clse.
p√•-pass-basis-of := p√•-basis-of & p√•-fctpass-spec & non-clse.

med-pass-assoc := med-assoc & med-fctpass-spec.
p√•-pass-assoc := p√•-assoc & p√•-fctpass-spec.
til-pass-assoc := til-assoc & til-fctpass-spec.

preprel := actv-prep & prim-mod & non-clse.
om-rel := preprel & om-k.
p√•-rel := preprel & p√•-k.
over-rel := preprel & over-k.
av-rel := preprel & av-k.
med-rel := preprel & med-k.
til-rel := preprel & til-k.
for-rel := preprel & for-k.
i-rel := preprel & i-k.
#|

om-rel := preprel & om-fct-spec.
p√•-rel := preprel & p√•-fct-spec.
over-rel := preprel & over-fct-spec.
av-rel := preprel & av-fct-spec.
med-rel := preprel & med-fct-spec.
til-rel := preprel & til-fct-spec.
for-rel := preprel & for-fct-spec.
i-rel := preprel & i-fct-spec.
|#

; for prep-clause-word
clausal-yes := adhoc-norm.
clausal-no := adhoc-norm.
clse := fct-actv-spec & clausal-yes.
non-clse := clausal-no.
om-clse := clse & om-fct-spec.
p√•-clse := clse & p√•-fct-spec.
over-clse := clse & over-fct-spec.
av-clse := clse & av-fct-spec.
i-clse := clse & i-fct-spec.
med-clse := clse & med-fct-spec.
som-clse := clse & som-fct-spec.
til-clse := clse & til-fct-spec.
fra-clse := clse & fra-fct-spec.
for-clse := clse & for-fct-spec.
ang√•ende-clse := clse & ang√•ende-fct-spec.


atelic-operation := prim-mod.
p√•-atelop := atelic-operation & p√•-k.
av-atelop := atelic-operation & av-k.
med-atelop := atelic-operation & med-k.
ved-atelop := atelic-operation & ved-k.

; med-fctactv-spec
p√•-act-atelop := p√•-atelop & actv-prep.
av-act-atelop := av-atelop & actv-prep.
med-act-atelop := med-atelop & actv-prep.

p√•-pass-atelop := p√•-atelop & pass-prep.
av-pass-atelop := av-atelop & pass-prep.
med-pass-atelop := med-atelop & pass-prep.

; for prep-indirwhquest-word
indirqu := fct-spec.
p√•-indirqu := indirqu & p√•-fct-spec & fct-actv-spec.
om-indirqu := indirqu & om-fct-spec & fct-actv-spec.
ang√•ende-indirqu := indirqu & ang√•ende-fct-spec & fct-actv-spec.

; for prep-rais-word
rais := prim-mod.
p√•-rais := rais & p√•-k.
om-rais := rais & om-k.
som-rais := rais & som-k.
til-rais := rais & til-k.
med-rais := rais & med-k.
mot-rais := rais & mot-k.
fra-rais := rais & fra-k.
uten-rais := rais & uten-k.
av-rais := rais & av-k.
for-rais := rais & for-k.
over-rais := rais & over-k.
i-rais := rais & i-k.


; for prep-delimit-fix
delimfix := non-selct & actv-prep.
p√•-delimfix := delimfix & p√•-k.
i-delimfix := delimfix & i-k.
; for prep-tel-fix
telfix := non-selct & actv-prep.
p√•-telfix := telfix & p√•-k & canbefirstafterverb-index-sit1.
i-telfix := telfix & i-k & canbefirstafterverb-index-sit1.
; for prep-word-reg/dir
reg := selct.
prim-mod := reg.
sec-mod := reg.
non-dir := reg.
;relprep := non-dir.
index-sit := non-dir & nonfixpt.
index-sitA := index-sit & prim-mod.
index-sit1 := index-sitA & actv-prep.
index-sit2 := index-sit & sec-mod & actv-prep.



uten-indxsit := canbefirstafterverb-index-sit1 & uten-k.
etter-indxsit := canbefirstafterverb-index-sit1 & etter-k.
p√•-indxsit := canbefirstafterverb-index-sit1 & p√•-k.
i-indxsit := canbefirstafterverb-index-sit1 & i-k.
ved-indxsit := canbefirstafterverb-index-sit1 & ved-k.
med-indxsit := canbefirstafterverb-index-sit1 & med-k.
under-indxsit := canbefirstafterverb-index-sit1 & under-k.
bak-indxsit := canbefirstafterverb-index-sit1 & bak-k.
over-indxsit := canbefirstafterverb-index-sit1 & over-k.
foran-indxsit := canbefirstafterverb-index-sit1 & foran-k.
innenfor-indxsit := canbefirstafterverb-index-sit1 & innenfor-k.
n√¶r-indxsit := canbefirstafterverb-index-sit1 & n√¶r-k.
til-indxsit := canbefirstafterverb-index-sit1 & til-k.
hos-indxsit := canbefirstafterverb-index-sit1 & hos-k.
rundt-indxsit := canbefirstafterverb-index-sit1 & rundt-k.
blant-indxsit := canbefirstafterverb-index-sit1 & blant-k.
om-indxsit := canbefirstafterverb-index-sit1 & om-k.
fra-indxsit := canbefirstafterverb-index-sit1 & fra-k.
omkring-indxsit := canbefirstafterverb-index-sit1 & omkring-k.
mellom-indxsit := canbefirstafterverb-index-sit1 & mellom-k.
for-indxsit := canbefirstafterverb-index-sit1 & for-k.
oppi-indxsit := canbefirstafterverb-index-sit1 & oppi-k.
inni-indxsit := canbefirstafterverb-index-sit1 & inni-k.
f√∏r-indxsit := canbefirstafterverb-index-sit1 & f√∏r-k.
hinsides-indxsit := canbefirstafterverb-index-sit1 & hinsides-k.
;i-indxsit := canbefirstafterverb-index-sit1 & i-k.
;i-indxsit := canbefirstafterverb-index-sit1 & i-k.

der-n√•r := index-sit1 & der-n√•r-k.

nofirstafterverb := index-sit1.
canbefirstafterverb-index-sit1 := index-sit1.

p√•-adv-indxsit := nofirstafterverb & p√•-k.
i-adv-indxsit := nofirstafterverb & i-k.
ved-adv-indxsit := nofirstafterverb & ved-k.
under-adv-indxsit := nofirstafterverb & under-k.
bak-adv-indxsit := nofirstafterverb & bak-k.
over-adv-indxsit := nofirstafterverb & over-k.
foran-adv-indxsit := nofirstafterverb & foran-k.

; ? to mark off adv-word-2-reg from adv-word-reg. eg for "han er her"
sec-index-sit := non-dir.

dir-sup := actv-prep.
dir := dir-sup & prim-mod.
fixpt := dir-sup.
nonfixpt := reg.
nonfixpt-dir := dir & nonfixpt.
orient-dir := nonfixpt-dir.
mot-orient-dir := orient-dir & mot-k.
langs-orient-dir := orient-dir & langs-k.
fra-orient-dir := orient-dir & fra-k.
gjennom-orient-dir := orient-dir & gjennom-k.
dir2 := dir-sup & sec-mod.
nonfixpt-dir2 := dir2 & nonfixpt.

pathconsumpt-dir := dir.
fixpt-dir := dir & fixpt.
nonfixptconsumpt-dir := pathconsumpt-dir & nonfixpt-dir.
fixptconsumpt-dir := pathconsumpt-dir & fixpt-dir.
mot-pathconsumpt-dir := nonfixptconsumpt-dir & mot-k.
langs-pathconsumpt-dir := nonfixptconsumpt-dir & langs-k.
til-pathconsumpt-dir := fixptconsumpt-dir & til-k.
fra-pathconsumpt-dir := fixptconsumpt-dir & fra-k.
gjennom-pathconsumpt-dir := fixptconsumpt-dir & gjennom-k.
etter-pathconsumpt-dir := nonfixptconsumpt-dir & etter-k.
om-pathconsumpt-dir := fixptconsumpt-dir & om-k.
pathconsumpt-dir2 := dir2.
fixpt-dir2 := dir2 & fixpt.
nonfixptconsumpt-dir2 := pathconsumpt-dir2 & nonfixpt-dir2.
fixptconsumpt-dir2 := pathconsumpt-dir2 & fixpt-dir2.

partitive := non-measurnoun.
av-partitive := partitive & av-k.
blant-partitive := partitive & blant-k.
measout := non-selct.
av-measout := measout & av-k.
med-measout := measout & med-k.
possprep := index-sit1.
til-poss := possprep & til-k.
av-poss := possprep & av-k.
for-poss := possprep & for-k.
fra-poss := possprep & fra-k.     


adj-selct := selct.
;seems never used:
;adj-k := absadj0 & adj-decl-selct & adj-quest-selct & propt.
; the next three only on abs-adj
adj-decl-selct := adj-selct.
adj-quest-selct := adj-selct.
absadj0 := adj-selct.
absadj0-tough := absadj0.
absadj0-epon := absadj0.
; this one only on adj-lxm (ie, non-abs)
propt := adj-selct & predcomp.


adv-selct := selct.
pcl := adv-selct.
ut-pcl := pcl & ut-k.
opp-pcl := pcl & opp-k.
ned-pcl := pcl & ned-k.
til-pcl := pcl & til-k.
bort-pcl := pcl & bort-k.
p√•-pcl := pcl & p√•-k.
over-pcl := pcl & over-k.
frem-pcl := pcl & frem-k.
inn-pcl := pcl & inn-k.
med-pcl := pcl & med-k.
rundt-pcl := pcl & rundt-k.
av-pcl := pcl & av-k.
ved-pcl := pcl & ved-k.

comptizer := selct.
predcomp := comptizer.
predcomp-inf := predcomp.
predcomp-adj := predcomp.
predcomp-n := predcomp.
predcomp-som := predcomp & som-k.
predcomp-for := predcomp & for-k.
predcomp-til := predcomp & til-k.
for-pred-inf := predcomp-inf & predcomp-for.
som-pred-inf := predcomp-inf & predcomp-som.
til-pred-inf := predcomp-inf & predcomp-til.
som-pred-adj := predcomp-adj & predcomp-som & actv-prep.
som-om-pred-adj := predcomp-adj & predcomp-som & actv-prep.
som-pred-n := predcomp-n & predcomp-som & actv-prep.
til-pred-n := predcomp-n & predcomp-til.
fin-infin-comp := comptizer.
finit-comp := fin-infin-comp.
infinit-comp := fin-infin-comp.
infinit-comp-eq := infinit-comp.
infinit-comp-arb := infinit-comp.
pre-comp := fin-infin-comp.

connadv := non-selct.
s√•-conn := connadv & s√•-k.
videre-conn := connadv & videre-k.
deretter-conn := connadv & deretter-k.
og-conn := connadv & og-k.

adv-s := non-selct.
ikke-adv-s := adv-s & ikke-k.
kanskje-adv-s := adv-s & kanskje-k.
neppe-adv-s := adv-s & neppe-k.
heller-adv-s := adv-s & heller-k.
sannsynligvis-adv-s := adv-s & sannsynligvis-k.
virkelig-adv-s := adv-s & virkelig-k.
antakeligvis-adv-s := adv-s & antakeligvis-k.
antageligvis-adv-s := adv-s & antageligvis-k.
antagelig-adv-s := adv-s & antagelig-k.
antakelig-adv-s := adv-s & antakelig-k.
trolig-adv-s := adv-s & trolig-k.
aldri-adv-s := adv-s & aldri-k.
alltid-adv-s := adv-s & alltid-k.
sjelden-adv-s := adv-s & sjelden-k.
tidligere-adv-s := adv-s & tidligere-k.
ofte-adv-s := adv-s & ofte-k.
heldigvis-adv-s := adv-s & heldigvis-k.
for-eksempel-adv-s := adv-s & for-eksempel-k.
nettopp-adv-s := adv-s & nettopp-k.
akkurat-adv-s := adv-s & akkurat-k.
ogs√•-adv-s := adv-s & ogs√•-k.
forresten-adv-s := adv-s & forresten-k.
faktisk-adv-s := adv-s & faktisk-k.
just-adv-s := adv-s & just-k.
igjen-adv-s := adv-s & igjen-k.
likevel-adv-s := adv-s & likevel-k.
vel-adv-s := adv-s & vel-k.
derfor-adv-s := adv-s & derfor-k.
gjerne-adv-s := adv-s & gjerne-k.
alternativt-adv-s := adv-s & alternativt-k.
dessverre-adv-s := adv-s & dessverre-k.
dessuten-adv-s := adv-s & dessuten-k.
dernest-adv-s := adv-s & dernest-k.
derimot-adv-s := adv-s & derimot-k.
tydeligvis-adv-s := adv-s & tydeligvis-k.
nok-adv-s := adv-s & nok-k.
s√•-adv-s := adv-s & s√•-k.
deriblant-adv-s := adv-s & deriblant-k.
engang-adv-s := adv-s & engang-k.
for-det-meste-adv-s := adv-s & for-det-meste-k.
videre-adv-s := adv-s & videre-k.
deretter-adv-s := adv-s & deretter-k.
halvveis-adv-s := adv-s & halvveis-k.




adv-m := selct.

relprn := adhoc-abnorm & non-measurnoun.
som-subjgap := relprn & som-k.
som-subjrelprn := relprn & som-k.
hvilket-subjrelprn := relprn & som-k.
som-fillerrelprn := relprn & som-k.
hvilket-fillerrelprn := relprn & som-k.

quantas := non-selct.
name-of-card := quantas.
crdfix := quantas.
klokkfix := name-of-card & crdfix.
; 'measnoun' to enable "Jon g√•r to femti", as length,
; and 'meastimenoun' to enable "Jon g√•r p√• to femti", as time spent
crdnum := crdfix & weaklic & measnoun & meastimenoun.

adv-nonselct := non-selct.

measurnoun := non-selct.
non-measurnoun := non-selct.
measnoun := measurnoun.
meastimenoun := measurnoun.
meastime-takes-pl-sp := meastimenoun & msr-takes-pl-spc.
meastime-takes-sg-sp := meastimenoun & msr-takes-sg-spc.
regnoun := non-measurnoun.
propnoun := non-measurnoun.
plainnoun := non-selct.
animnoun := plainnoun.
inanimnoun := plainnoun.
relnoun := regnoun.
absnoun := regnoun.
reganim := animnoun & absnoun.
reginan := inanimnoun & absnoun.
relanim := animnoun & relnoun.
relinan-sup := inanimnoun & relnoun.
relinan := relinan-sup.
fact := relinan-sup.
rel-hensyn := relinan.
rel-sikkerhet := relinan.
rel-mot := relinan.
rel-bak := relinan.
rel-under := relinan.
reg-ved := reginan.
takes-pl-spc := measurnoun.
takes-sg-spc := measurnoun.
takes-adj := measurnoun.
msr-takes-pl-spc := measnoun & takes-pl-spc.
msr-takes-sg-spc := measnoun & takes-sg-spc.
msr-takes-adj := measnoun & takes-adj.
timemeas-noun:= meastimenoun & crdfix. 
tmsr-takes-pl-spc := timemeas-noun & takes-pl-spc.
tmsr-takes-sg-spc := timemeas-noun & takes-sg-spc.
tmsr-takes-adj := timemeas-noun & takes-adj.
;weekday-noun:= meastimenoun. 
weekday-noun:= timemeas-noun & takes-sg-spc. 
;daytime-noun:= meastimenoun. 
daytime-noun:= timemeas-noun & takes-sg-spc. 
;year-noun:= meastimenoun & crdfix. 
year-noun:= timemeas-noun & takes-sg-spc. 
week-noun:= timemeas-noun & takes-sg-spc. 
timeperiod-noun:= meastimenoun & crdfix. 
dirnoun := non-measurnoun.
propanim := animnoun & propnoun.
propinan := inanimnoun & propnoun.
persprn := non-measurnoun.
explprn := non-measurnoun.

mealnoun := adhoc-norm.
; Commented out REGINAN, to hinder pres-participle from being applied to measure rules.
; EAA030811.
day-and-meal := mealnoun & daytime-noun. ; & reginan.
;day-and-meal := reginan.
;LH 050811: commented in again, needed for restraining "til" for "til lunsj"
;LH200811 - and out again, it yields 'en' combining by measure-np-rule in caes where it shouldnt (like 'en st√∏rre' in 'en st√∏rre mann enn...' 'til lunsj' will requirw other means...
;day-and-meal := mealnoun & daytime-noun & reginan.

inhr-comp := non-measurnoun.
leir-inhcmp := inhr-comp & leir-k.
d√∏d-inhcmp := inhr-comp & d√∏d-k.
rundtur-inhcmp := inhr-comp.
fl√∏yten-inhcmp := inhr-comp & fl√∏yten-k.
has-inhcmp := inhr-comp & has-k.

nom-k := reganim & reginan & relinan & relanim & dirnoun.
anonym-k := reganim & reginan & relinan & relanim & dirnoun & propt. 
propnoun-k := propnoun.

vb := adhoc-norm.
mainvb := vb.
; if we have this one, we need 70...
advoblvb := mainvb.
mainvb-norm := mainvb.
mainvb-nofreepred := mainvb.

auxvb := vb.
interjct := vb.

start-parenth := adhoc-norm.
end-parenth := adhoc-norm.
start-quote := adhoc-norm.
end-quote := adhoc-norm.

; TENSE values
non-finite := tense.
finite := tense.
pres := finite.
pret := finite.
infin := non-finite.
perf := non-finite.
prespartcpl := non-finite.

imperative := mood.

indicative := mood.
hortative := mood.


; DEGREE values
degree := avm.
positive := degree.
comparative := degree.
superlative := degree.

;; HEAD values

poss-subj-head := head &
  [ RELATIVPRON bool,
    TRANSPAR bool ].
card-nom := head.

np-head := poss-subj-head &
  [ COORDINABLE bool,
    PRESENTED bool].

allquant := np-head &
  [ COORDINABLE + ].
headx := head.
interjection := head &
  [KEYS.KEY interjct,
   INTERJECT bool].
cl-adjct := headx.
headz := headx.
possparticle := poss.
poss := headx.
; SELECTED is brought higher up in the system than one might
; think necessary, but we need it for adv and prep and comp, and
; for now, this is the lowest possible
heady := headz &
  [ SELECTED bool,
    DEGREE degree].
; sic, to rstrict measure-np-cmpar-phrase
verb-all-or-noun := heady &
 [DEGREE positive].
verb-or-noun := verb-all-or-noun.
posspron := poss.
postposspron := poss.
possnoun := nom &
  [ COORDINABLE + ].
prep-or-verb := heady.
nominal := heady & nominal-or-connect-n.

nominal-or-connect-n := np-head.


nom := nominal &
  [ DEFINITE bool,
    DEF bool,
    SELECTED - ].
expl-pron := nom &
  [ COORDINABLE -,
    EXPLETIVE + ].
pers-pron := nom &
  [ COORDINABLE + ,
    EXPLETIVE - ].
rel-filler := np-head & [RELATIVPRON bool].
rel-pron := poss-subj-head & comp &
  [ RELATIVPRON +,
    EXPLETIVE - ].
resumpt-pron := nom &
  [ COORDINABLE -,
    EXPLETIVE - ].
; attachment points of cmpar-clauses
n-or-adj-or-adv := head.
n-or-adj := head & [COMPAR-DEP adhoc-abnorm].

; n-or-adj-or-adv
noun := nom & verb-or-noun & n-or-adj-or-adv & n-or-adj & card-nom &
  [ BARE bool,
    COORDINABLE +,
    EXPLETIVE - ].
comm-noun := noun.
prop-noun := noun.
;; nb! check all partitive expressions!
part-prep := nom &
  [ COORDINABLE - ].
voice := avm.
active := voice.
passive := voice.
s-pass := passive.
ptc-pass := passive.
;verb-or-comp := prep-or-verb & poss-subj-head &
verb-or-comp := prep-or-verb & 
  [ MAIN-CL bool,
    INV bool,
    IMPERATIVE bool,
    DECL bool,
    VOICE voice,
    WH-COMPLETE bool,
    WH-MOVED bool].
verb-all := verb-or-comp & verb-all-or-noun &
 [ COP bool].
copula := verb-all &
 [ COP + ].
non-copula := verb-all &
 [ COP - ].
verb-aux := non-copula.
verb := non-copula & verb-or-noun.
det := q &
  [ MOD <> ].

;LH050513 - hvor mange/mye/stor
q := nominal & adjectival &
  [COORDINABLE + ].
art := q.
;possart := art & possparticle.
quantor := q.
quant:= quantor & comparative-adv.
adj-quant := quant.
n-quant := quant.
prep-or-adj-or-adv := heady.
prep-or-adj := prep-or-adj-or-adv.
adjectival := heady.
; n-or-adj-or-adv
;adjectival & 
; this leads to head-cop-prepadv-comp-phrase combining random forms of adj with copula, in violation of agreement. Therfore going back to previous, and be prepared to solve what prompted this definition by other means. see massifcentral-testsuites and test-ch1-6, from around 10th of July.
;adj := n-or-adj-or-adv & n-or-adj & comparative-adv &
;  [ WEAK bool ] is introduced higher up, to facilitate rule subsumption.
adj := n-or-adj-or-adv & n-or-adj & adjectival &
[ WEAK bool ].
adj-reg := adj & prep-or-adj.
degspr := adjectival & [KEYS.KEY degreer].
card := adjectival & card-nom.
ord := adjectival.
cardnum := card & np-head.
cardquant := card & np-head.
; feb18-06: was earlier := adjectival, and probl with "tre cm mer enn to meter
; h√∏yere enn"
comparative-adv := prep-or-adv & adjectival.
cmpar-reg-adv := comparative-adv.
cmpar-close-adv := comparative-adv & quantor.
cmpar-dep := head.
cmpar-dep-close := cmpar-dep.
cmpar-dep-reg := cmpar-dep.
;prep := prep-or-verb.
prep-or-comp := heady &
  [ TEL-FIXING bool ].
comp := prep-or-comp & verb-or-comp.
glob-comp := comp & np-head.
;  poss-subj-head &
fin-comp := glob-comp &
  [ TRANSPAR - ].
; poss-subj-head & 
infin-comp := glob-comp.
adjct-comp := comp.

som-or-for := prep-ultra.; & verb-or-comp.
for-cmp := glob-comp.
prep-or-adv := prep-or-adj-or-adv &
  [ LEG-SWITCH bool ].
adv-super := prep-or-adv.
; n-or-adj-or-adv
adv := adv-super & prep-adv & n-or-adj-or-adv & adjectival.
a := adj & adv.
adv-reg := adv &
  [ DEGREE positive ].
refl-adv := head.
adv-particle := adv-super.
; should be := adv-super, but accidents with head-comp-expl-...-rule ...
s-adv := cl-adjct.
prep-adv := cl-adjct.
prep-ultra := prep-or-adv & prep-or-comp & prep-or-adj & prep-or-verb.
;prep-super := prep-ultra.
prep := prep-ultra & prep-adv.
;prep-contr := prep-super.
prep-comp := prep-ultra.

connect := headz.
punct := connect & [KEYS.KEY punctuator].
conn-pos := connect.
conn-adv := conn-pos.
conn-coord := conn-pos.
coord := conn-pos & [KEYS.KEY coordinator].
word-coord := coord.
comma-coord := coord.
correl-coord := conn-pos.
enclosing-mark := headz.
parenthesis := enclosing-mark.
quotation-mark := enclosing-mark.

connect-n := nominal-or-connect-n.
;connect-n-or-nominal := np-head.

;connect-n := comm-noun.


; BASIC LEX-ITEMS TYPES


lex-item-1rel := word-or-lexrule &
  [SYNSEM.LOCAL.CONT [RELS [ LIST.FIRST #2 & [ARG0 #1],
                             LIST.REST #rest,
                             LAST #rest ],
                      HOOK.INDEX #1],
   SYNSEM.LKEYS.KEYREL #2 & relation,
   SYNSEM.NON-LOCAL.SLASH diff-list  ].

lex-item-sinarg0-1rel := word-or-lexrule &
  [SYNSEM.LOCAL.CONT [RELS [ LIST.FIRST #2,
                             LIST.REST #rest,
                             LAST #rest ]],
   SYNSEM.LKEYS.KEYREL #2 & relation,
   SYNSEM.NON-LOCAL.SLASH diff-list  ].

; & [ ARG0 #1] 
;LIST.FIRST #key,
;SYNSEM.LKEYS.KEYREL #key & [ ARG0 #1], - in order to get index right for resultative secpred
lex-item-2rel := word-or-lexrule &
[ SYNSEM. LOCAL.CONT.HOOK.INDEX #1,
  SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key,
                           LIST.REST [FIRST #relation,             
                                      REST #rest],
                           LAST #rest],
  SYNSEM.LKEYS.KEYREL #key & [ ARG0 #1],
  SYNSEM.LKEYS.ALTKEYREL #relation].


  

lex-item-sinarg0-2rel := word-or-lexrule &
[ SYNSEM. LOCAL.CONT.HOOK.INDEX #1,
  SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key,
                           LIST.REST [FIRST #relation,             
                                      REST #rest],
                           LAST #rest],
  SYNSEM.LKEYS.KEYREL #key,
  SYNSEM.LKEYS.ALTKEYREL #relation & [ ARG0 #1] ].

lex-item-openarg0-2rel := word-or-lexrule &
[ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key,
                           LIST.REST [FIRST #relation,             
                                      REST #rest],
                           LAST #rest],
  SYNSEM.LKEYS.KEYREL #key,
  SYNSEM.LKEYS.ALTKEYREL #relation ].

lex-item-3rel := word-or-lexrule &
[ SYNSEM. LOCAL.CONT.HOOK.INDEX #1,
  SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key,
                           LIST.REST [FIRST relation,             
                                      REST [FIRST relation,
                                            REST #rest]],
                           LAST #rest],
  SYNSEM.LKEYS.KEYREL #key & [ ARG0 #1]].

lex-item-sinarg0-3rel := word-or-lexrule &
[ SYNSEM. LOCAL.CONT.HOOK.INDEX #1,
  SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key,
                           LIST.REST [FIRST #relation,             
                                      REST [FIRST relation,
                                            REST #rest]],
                           LAST #rest],
  SYNSEM.LKEYS.KEYREL #key,
  SYNSEM.LKEYS.ALTKEYREL #relation & [ ARG0 #1]].



lex-item-4rel := word-or-lexrule &
[ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key,
                           LIST.REST [FIRST #relation,
                                      REST [FIRST relation,
                                            REST [FIRST relation,
                                                  REST  #rest]]],
                           LAST #rest],
  SYNSEM.LKEYS.KEYREL #key,
  SYNSEM.LKEYS.ALTKEYREL #relation ].



lex-item-4rel-xtra := word-or-lexrule &
[ SYNSEM. LOCAL.CONT.HOOK.INDEX #1,
  SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key & [ ARG0 #1],
                           LIST.REST [FIRST relation,
                                      REST [FIRST #relation,
                                            REST [FIRST relation,
                                                  REST  #rest]]],
                           LAST #rest],
  SYNSEM.LKEYS.KEYREL #key,
  SYNSEM.LKEYS.ALTKEYREL #relation ].

; the XARG a bit suspicious here - making new version below...
; this one was used in the directional-adverb-decomposition
; grammar, and should be saved for its reappearance

#|
lex-item-5rel := word-or-lexrule &
[ SYNSEM. LOCAL.CONT.HOOK.INDEX #1,
  SYNSEM. LOCAL.CONT.HOOK.XARG #4,
  SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key,
                           LIST.REST [ FIRST #relation & [ ARG0 #1,
                                                          ARG1 #4],
                                       REST [ FIRST relation,
                                              REST [ FIRST relation,
                                                     REST [ FIRST relation,
                                                            REST #rest]]]],
                           LAST #rest],
  SYNSEM.LKEYS.KEYREL #key,
  SYNSEM.LKEYS.ALTKEYREL #relation ].
|#

lex-item-5rel := word-or-lexrule &
[ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key,
                           LIST.REST [FIRST #relation,
                                      REST [FIRST relation,
                                            REST [FIRST relation,
                                                  REST [FIRST relation,
                                                        REST #rest]]]],
                           LAST #rest],
  SYNSEM.LKEYS.KEYREL #key,
  SYNSEM.LKEYS.ALTKEYREL #relation ].

lex-item-6rel := word-or-lexrule &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
  SYNSEM.LOCAL.CONT.HOOK.XARG #4,
  SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST #key,
                           LIST.REST [ FIRST #relation & [ ARG0 #1,
                                                           ARG1 #4 ],
                                      REST [ FIRST relation,
                                             REST [ FIRST relation,
                                                    REST [ FIRST relation,
                                                           REST [ FIRST relation,
                                                                  REST #rest]]]]],
                           LAST #rest ],
  SYNSEM.LKEYS.KEYREL #key,
  SYNSEM.LKEYS.ALTKEYREL #relation ].



; this (expanded) type is equiv to 'norm-lex-item' (apart from IDIOMOD -
; used with prep-reg-2-word and pp-mod-phrase2
lbl-ltop-lex-item-super := lex-item-1rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1,
    SYNSEM.IDIOMOD bool ].

lbl-ltop-lex-item-sinarg0 := lex-item-sinarg0-1rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1,
    SYNSEM.IDIOMOD - ].

lbl-ltop-lex-item := lbl-ltop-lex-item-super &
  [ SYNSEM.IDIOMOD - ].

lbl-ltop-lex-item-idio := lbl-ltop-lex-item-super &
  [ SYNSEM.IDIOMOD + ].

lbl-ltop-lex-item-2rel := lex-item-2rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1 ]. 
#|
lbl-ltop-lex-item-2rel-lbltweak := word-or-lexrule &
  [ SYNSEM. LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #10,
    SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ PRED #key,
					  ARG0 #1 ],
			     LIST.REST [FIRST [LBL #10,
					       PRED #11,
					       ARG0 #12],             
					REST #rest],
			     LAST #rest],
    SYNSEM.LKEYS.KEYREL [ PRED #key,
			  ARG0 #1],
    SYNSEM.LKEYS.ALTKEYREL [LBL #10,
			    PRED #11,
			    ARG0 #12]]. 
|#

lbl-ltop-lex-item-2rel-lbltweak := word-or-lexrule &
  [ SYNSEM. LOCAL.CONT.HOOK.INDEX #1,
 ;   SYNSEM.LOCAL.CONT.HOOK.LTOP #10,
    SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ PRED #key,
					  ARG0 #1 ],
			     LIST.REST [FIRST [PRED #11,
					       ARG0 #12],             
					REST #rest],
			     LAST #rest],
    SYNSEM.LKEYS.KEYREL [ PRED #key,
			  ARG0 #1],
    SYNSEM.LKEYS.ALTKEYREL [PRED #11,
			    ARG0 #12]]. 

#|
lbl-ltop-lex-item-2rel-lbltweak-argOoblq := lbl-ltop-lex-item-2rel-lbltweak &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARGOBLQ #1 ],
			     LIST.REST [FIRST [ARGOBLQ #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARGOBLQ #1],
    SYNSEM.LKEYS.ALTKEYREL [ARGOBLQ #2]]. 

lbl-ltop-lex-item-2rel-lbltweak-argOx := lbl-ltop-lex-item-2rel-lbltweak &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARGX #1 ],
			     LIST.REST [FIRST [ARGX #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARGX #1],
    SYNSEM.LKEYS.ALTKEYREL [ARGX #2]]. 
|#

lbl-ltop-lex-item-2rel-lbltweak-arg1 := lbl-ltop-lex-item-2rel-lbltweak &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARG1 #1 ],
			     LIST.REST [FIRST [ARG1 #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARG1 #1],
    SYNSEM.LKEYS.ALTKEYREL [ARG1 #2]]. 

#|
lbl-ltop-lex-item-2rel-lbltweak-arg1oblq := lbl-ltop-lex-item-2rel-lbltweak-arg1 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARGOBLQ #1 ],
			     LIST.REST [FIRST [ARGOBLQ #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARGOBLQ #1],
    SYNSEM.LKEYS.ALTKEYREL [ARGOBLQ #2]]. 

lbl-ltop-lex-item-2rel-lbltweak-arg1x := lbl-ltop-lex-item-2rel-lbltweak-arg1 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARGX #1 ],
			     LIST.REST [FIRST [ARGX #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARGX #1],
    SYNSEM.LKEYS.ALTKEYREL [ARGX #2]]. 
|#

lbl-ltop-lex-item-2rel-lbltweak-arg12 := lbl-ltop-lex-item-2rel-lbltweak-arg1 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARG2 #1 ],
			     LIST.REST [FIRST [ARG2 #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARG2 #1],
    SYNSEM.LKEYS.ALTKEYREL [ARG2 #2]]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12a := lbl-ltop-lex-item-2rel-lbltweak &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST arg0-relation,
			     LIST.REST [FIRST [ ARG1 #0,
						ARG2 #1 ] ]],             
    SYNSEM.LKEYS.KEYREL arg0-relation,
    SYNSEM.LKEYS.ALTKEYREL [ ARG1 #0,
			     ARG2 #1] ]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12a1 := lbl-ltop-lex-item-2rel-lbltweak-arg12a &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST [FIRST.ARG1 #1 ]],             
    SYNSEM.LKEYS.KEYREL.ARG1 #1 ]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12aObl := lbl-ltop-lex-item-2rel-lbltweak-arg12a &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST [FIRST.ARGOBLQ #1 ]],             
    SYNSEM.LKEYS.KEYREL.ARGOBLQ #1 ]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12a1Obl := lbl-ltop-lex-item-2rel-lbltweak-arg12a1 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST [FIRST.ARGOBLQ #1 ]],             
    SYNSEM.LKEYS.KEYREL.ARGOBLQ #1 ]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12a12 := lbl-ltop-lex-item-2rel-lbltweak-arg12a1 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST [FIRST.ARG2 #1 ]],             
    SYNSEM.LKEYS.KEYREL.ARG2 #1 ]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12a12Obl := lbl-ltop-lex-item-2rel-lbltweak-arg12a12 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST [FIRST.ARGOBLQ #1 ]],             
    SYNSEM.LKEYS.KEYREL.ARGOBLQ #1 ]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12ax := lbl-ltop-lex-item-2rel-lbltweak-arg12a &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST [FIRST.ARGX #1 ]],             
    SYNSEM.LKEYS.KEYREL.ARGX #1 ]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12a1x := lbl-ltop-lex-item-2rel-lbltweak-arg12a1 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST [FIRST.ARGX #1 ]],             
    SYNSEM.LKEYS.KEYREL.ARGX #1 ]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12a12x := lbl-ltop-lex-item-2rel-lbltweak-arg12a12 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST [FIRST.ARGX #1 ]],             
    SYNSEM.LKEYS.KEYREL.ARGX #1 ]. 





#|
lbl-ltop-lex-item-2rel-lbltweak-arg12oblq := lbl-ltop-lex-item-2rel-lbltweak-arg12 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARGOBLQ #1 ],
			     LIST.REST [FIRST [ARGOBLQ #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARGOBLQ #1],
    SYNSEM.LKEYS.ALTKEYREL [ARGOBLQ #2]]. 

lbl-ltop-lex-item-2rel-lbltweak-arg12x := lbl-ltop-lex-item-2rel-lbltweak-arg12 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARGX #1 ],
			     LIST.REST [FIRST [ARGX #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARGX #1],
    SYNSEM.LKEYS.ALTKEYREL [ARGX #2]]. 

lbl-ltop-lex-item-2rel-lbltweak-arg123 := lbl-ltop-lex-item-2rel-lbltweak-arg12 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARG3 #1 ],
			     LIST.REST [FIRST [ARG3 #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARG3 #1],
    SYNSEM.LKEYS.ALTKEYREL [ARG3 #2]]. 

lbl-ltop-lex-item-2rel-lbltweak-arg123oblq := lbl-ltop-lex-item-2rel-lbltweak-arg123 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARGOBLQ #1 ],
			     LIST.REST [FIRST [ARGOBLQ #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARGOBLQ #1],
    SYNSEM.LKEYS.ALTKEYREL [ARGOBLQ #2]]. 

lbl-ltop-lex-item-2rel-lbltweak-arg123x := lbl-ltop-lex-item-2rel-lbltweak-arg123 &
  [ SYNSEM.LOCAL.CONT.RELS [ LIST.FIRST [ ARGX #1 ],
			     LIST.REST [FIRST [ARGX #2]]],             
    SYNSEM.LKEYS.KEYREL [ ARGX #1],
    SYNSEM.LKEYS.ALTKEYREL [ARGX #2]]. 
|#


#|
lbl-ltop-lex-item-2rel-lbltweak := word-or-lexrule &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.ALTKEYREL.LBL #1 ]. 
|#

lbl-ltop-lex-item-sinarg0-2rel := lex-item-sinarg0-2rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1 ]. 

lbl-ltop-lex-item-openarg0-2rel := lex-item-openarg0-2rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1 ]. 

lbl-ltop-lex-item-3rel := lex-item-3rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1 ].

lbl-ltop-lex-item-sinarg0-3rel := lex-item-sinarg0-3rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1 ]. 


lbl-ltop-lex-item-4rel := lex-item-4rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1 ].

lbl-ltop-lex-item-4rel-xtra := lex-item-4rel-xtra &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1 ].

lbl-ltop-lex-item-5rel := lex-item-5rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LKEYS.KEYREL.LBL #1 ].

lbl-ltop-lex-item-6rel := lex-item-6rel &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CONT.RELS <! [], [ LBL #1 ], [], [], [], [] !> ].




reg-mod-lex-item := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #1,
                                  LOCAL.CONT.HOOK.LTOP #2,
                                  LKEYS.KEYREL.LBL #2,
                                  LOCAL.CAT.VAL.COMPS list]>,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           SPEC <> ],
    SYNSEM.LKEYS.KEYREL [ ARG1 #1 ],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1 ].

dir-mod-lex-item := lbl-ltop-lex-item & norm-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.DIRARG #1,
                                  LOCAL.CONT.HOOK.LTOP #2,
                                  LKEYS.KEYREL.LBL #2,
                                  LOCAL.CAT.VAL.COMPS olist]>,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           SPEC <> ],
    SYNSEM.LKEYS.KEYREL [ ARG1 #1 ],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

dir-mod-lex-item-2 := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.DIRARG #1,
                                  LOCAL.CONT.HOOK.LTOP #2,
                                  LKEYS.KEYREL.LBL #2,
                                  LOCAL.CAT.VAL.COMPS <>]>,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           SPEC <> ],
    SYNSEM.LKEYS.KEYREL [ ARG1 #1,
                         LBL #2 ],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

xarg-mod-lex-item-2 := lbl-ltop-lex-item-idio &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.XARG #1,
                                  LOCAL.CONT.HOOK.LTOP #2,
                                  LKEYS.KEYREL.LBL #2,
                                  LOCAL.CAT.VAL.COMPS <>]>,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR <>,
                           SPEC <> ],
    SYNSEM.LKEYS.KEYREL [ ARG1 #1,
                                  LBL #2 ],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

; ,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #1
reg-mod-lex-item-2rel := lbl-ltop-lex-item-openarg0-2rel &
  [ SYNSEM.LOCAL.CAT.VAL [ SPEC <> ],
    SYNSEM.LOCAL.CONT.HCONS <! [] !> ].



;;; PRO FORMA TYPES, for the BIG LEXICON

unknown-lxm := lexeme & lbl-ltop-lex-item.
x-noun-lxm := noun-lexeme.

;; proforma types, now in lex3.prep-adv-nonass.tdl
prep-nonassigned-word := reg-mod-lex-item & prep-word &
  [ SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY index-sit1 ],
    SYNSEM.LOCAL.CONT.HOOK [INDEX.SORT non-fix-point ],
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb-all-or-noun ] > ].
adv-nonassigned-word := reg-mod-lex-item & adv-word &
  [ SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY index-sit1 ],
    SYNSEM.LOCAL.CONT.HOOK [INDEX.SORT non-fix-point ],
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb-all-or-noun ] > ].

complementizer-word := basic-compl & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD fin-comp & [ TRANSPAR - ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.COMPS olist,
                                   LOCAL.CAT.VAL.SUBJ antilist,
                                   LOCAL.CAT.VAL [SPR <>,
                                                  SPEC <>,
                                                  ICOMPS <>],
                                   LOCAL.CAT.HEAD.MAIN-CL -,
                                   LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
                                   LOCAL.CONT.HOOK.LTOP #4]>,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
    SYNSEM.LOCAL.CONT.RELS <! arg1-relation & [LBL #3,
                                               ARG1 #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].


cond-complementizer-word := basic-compl & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD fin-comp & [ TRANSPAR - ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ antilist,    
                                   LOCAL.CAT.VAL.COMPS olist,
                                   LOCAL.CAT.VAL [SPR <>,
                                                  SPEC <>,
                                                  ICOMPS <>],
                                   LOCAL.CAT.HEAD.MAIN-CL -,
                                   LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
                                   LOCAL.CONT.HOOK.LTOP #4]>,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
    SYNSEM.LOCAL.CONT.RELS <! arg1-relation & [LBL #3,
                                               ARG1 #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

co-conj-word := word & lbl-ltop-lex-item.

; WORD TYPES

;;; COORDINATORS

resumptive-gap := word &
  [ SYNSEM gap & [ LOCAL.CAT.HEAD rel-pron & [ACCUSATIVE - ]] ].

; verb-all -> head
end-punct := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD punct & [MOD <[ LOCAL.CAT.HEAD head,
                                             LOCAL.CAT.VAL.COMPS <> ]>],
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>,
     SYNSEM.LOCAL.HAS-PUNCT +  ].

decl-end-punct := end-punct &
  [  SYNSEM.LOCAL.CAT.HEAD [ MOD <[ LOCAL [ CAT.HEAD [ DECL + ],
					    CONT.HOOK.INDEX.SF prop-or-comm ]] >],
     SYNSEM.LKEYS.KEYREL [ PRED "_period-punctuated_rel" ]].

interjct-end-punct := end-punct &
  [  SYNSEM.LOCAL.CAT.HEAD [ MOD <[ LOCAL.CAT.HEAD interjection ]> ]].

noun-end-punct := end-punct &
  [  SYNSEM.LOCAL.CAT.HEAD [ MOD <[ LOCAL.CAT.HEAD n-or-adj-or-adv ]> ]].

quest-end-punct := end-punct &
  [  SYNSEM.LOCAL.CAT.HEAD [ MOD <[ LOCAL [ CAT.HEAD [ IMPERATIVE - ],
					   CONT.HOOK.INDEX.SF ques ]] > ],
     SYNSEM.LKEYS.KEYREL [ PRED "_quest-punctuated_rel" ]].

; exclamation mark goes well with declarative force, for expressing enthusiasm, surprise etc.
;commd-end-punct := end-punct &
;  [  SYNSEM.LOCAL.CAT.HEAD [MOD <[ LOCAL.CAT.HEAD [ DECL -,
;                                                    IMPERATIVE + ] ]>],
;     SYNSEM.LKEYS.KEYREL [PRED "_exclam-punctuated_rel"]].

commd-end-punct := end-punct &
  [  SYNSEM.LOCAL.CAT.HEAD [ MOD <[ LOCAL [ CONT.HOOK.INDEX.SF prop-or-comm ]] > ],
     SYNSEM.LKEYS.KEYREL [PRED "_exclam-punctuated_rel"]].

colon-end-punct := end-punct &
  [  SYNSEM.LOCAL.CAT.HEAD [MOD <[ LOCAL.CAT.HEAD [ DECL + ] ]>],
     SYNSEM.LKEYS.KEYREL [PRED "_colon-punctuated_rel"]].

semicolon-end-punct := end-punct &
  [  SYNSEM.LOCAL.CAT.HEAD [MOD <[ LOCAL.CAT.HEAD [ DECL + ] ]>],
     SYNSEM.LKEYS.KEYREL [PRED "_semicolon-punctuated_rel"]].

gedankenstrech-end-punct := end-punct &
  [  SYNSEM.LOCAL.CAT.HEAD [MOD <[ LOCAL.CAT.HEAD [ DECL + ] ]>],
     SYNSEM.LKEYS.KEYREL [PRED "_gedankestrech-punctuated_rel"]].

p-adv-connector := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY reg],
                                             LOCAL.CAT.VAL.COMPS <> ]>],
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

p-adv-dir-connector := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY dir],
                                             LOCAL.CAT.VAL.COMPS <> ]>],
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

#|
n-connector := reg-mod-lex-item-2rel &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD np-head,
                                             LOCAL.CAT.VAL.COMPS <> ]>],
;     SYNSEM.LOCAL.XLBL #lbl,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #ind,
     SYNSEM.LKEYS.KEYREL [ ARG0 #ind ],
     SYNSEM.LOCAL.CONT.RELS <! indef-q-rel & [PRED "_udef_q_rel",
					      ARG0 #ind,
					      RSTR #rstr], 
			     [ PRED "_set_rel",
			       LBL #lbl,
			       ARG0 #ind ]  !>,
     SYNSEM.LOCAL.CONT.HCONS <! [HARG #rstr,
				 LARG #lbl] !>  ].
|#

n-connector-2 := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD np-head,
                                             LOCAL.CAT.VAL.COMPS <> ]>],
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

n-connector := lbl-ltop-lex-item-2rel &
  [  SYNSEM.LOCAL.CAT.HEAD connect-n,
     SYNSEM.LOCAL.CAT.VAL.SPR <[LOCAL.CAT.HEAD np-head]>, 
     SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD np-head]>, 
     SYNSEM.LOCAL.CONT.HOOK.INDEX #ind,
     SYNSEM.LKEYS.KEYREL [ ARG0 #ind ],
     SYNSEM.LOCAL.CONT.RELS <! indef-q-rel & [PRED "_udef_q_rel",
					      ARG0 #ind,
					      RSTR #rstr], 
			     [ PRED "_set_rel",
			       LBL #lbl,
			       ARG0 #ind ]  !>,
     SYNSEM.LOCAL.CONT.HCONS <! [HARG #rstr,
				 LARG #lbl] !>  ].

p-clse-connector := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD prep & [KEYS.KEY der-n√•r],
                                             LOCAL.CAT.VAL.COMPS <> ]>],
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

rel-cl-connector := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD verb-all & [KEYS.KEY vb,
                                                                        INV -],
                                             LOCAL.CAT.VAL.COMPS <> ]>],
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

rel-cl-nonrestr-connector := lbl-ltop-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD verb-all & [KEYS.KEY vb,
                                                                        INV -],
                                             LOCAL.CAT.VAL.COMPS <>,
                                             LOCAL.CONT.HOOK.LTOP #1 ]>],
     SYNSEM.LOCAL.CONT.RELS <! adj_rel & [PRED "_nonrestr-comment_rel",
                                                ARG1 #1 ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

n-nonrestr-connector := lbl-ltop-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD np-head,
                                             LOCAL.CAT.VAL.COMPS <>,
                                             LOCAL.CONT.HOOK.LTOP #1 ]>],
     SYNSEM.LOCAL.CONT.RELS <! adj_rel & [PRED "_nonrestr-comment_rel",
                                                ARG1 #1 ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

vcond-connector := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD verb-all & [KEYS.KEY vb],
                                             LOCAL.CAT.VAL.COMPS <>,
                                             LOCAL.CONT.HOOK.INDEX.E.MOOD indicative ]>],
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

vcond-connector-2 := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD adjct-comp,
                                             LOCAL.CAT.VAL.COMPS <>,
                                             LOCAL.CONT.HOOK.INDEX.E.MOOD indicative ]>],
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

v-connector := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD verb-all & [KEYS.KEY vb],
                                             LOCAL.CAT.VAL.COMPS <>,
                                             LOCAL.CONT.HOOK.INDEX.E.MOOD mood ]>],
     SYNSEM.LKEYS.KEYREL arg1-relation,
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

a-connector := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD <[ LOCAL.CAT.HEAD adj-reg ]>],
     SYNSEM.LKEYS.KEYREL arg1-relation,
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>  ].

p-adv-connect-punctuation := p-adv-connector &
  [  SYNSEM.LOCAL.CAT.HEAD punct,
     SYNSEM.LKEYS.KEYREL [PRED "_punctuation_c_rel"]].

p-clse-connect-punctuation := p-clse-connector &
  [  SYNSEM.LOCAL.CAT.HEAD punct,
     SYNSEM.LKEYS.KEYREL [PRED "_punctuation_c_rel"]].

vcond-connect-punctuation := vcond-connector &
  [  SYNSEM.LOCAL.CAT.HEAD punct & [MOD < [LOCAL.RIGHT-ADJ-SITE-OPEN +] >],
     SYNSEM.LKEYS.KEYREL [PRED "_punctuation_c_rel"]].

vcond-hvis-punctuation := vcond-connector-2 &
  [  SYNSEM.LOCAL.CAT.HEAD punct & [MOD < [LOCAL.CAT.HEAD.INV -] >],
     SYNSEM.LKEYS.KEYREL [PRED "_punctuation_c_rel"]].

interject-connector := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD < [LOCAL.CAT.HEAD interjection & [KEYS.KEY interjct],
                                           LOCAL.CAT.VAL.COMPS <>,
					   LOCAL.CONT.HOOK.LTOP #ltop]  >],
     SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
     SYNSEM.LOCAL.CONT.RELS <! [ LBL #ltop ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !> ].

interject-connect-punctuation := interject-connector &
  [  SYNSEM.LOCAL.CAT.HEAD punct & [MOD < [LOCAL.CAT.HEAD interjection & [KEYS.KEY interjct],
                                           LOCAL.CAT.VAL.COMPS <>,
					   LOCAL.CONT.HOOK.LTOP #ltop]  >],
     SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
     SYNSEM.LOCAL.CONT.RELS <! [ LBL #ltop ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>,
     SYNSEM.LKEYS.KEYREL [PRED "_punctuation_c_rel"] ].

interject-connect-word := interject-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos ].

adj-interject-connector := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD connect & [MOD < [LOCAL.CAT.HEAD adj & [KEYS.KEY adj-decl-selct],
                                           LOCAL.CAT.VAL.COMPS <>,
					   LOCAL.CONT.HOOK.LTOP #ltop]  >],
     SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
     SYNSEM.LOCAL.CONT.RELS <! [ LBL #ltop ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !> ].

adj-interject-connect-punctuation := adj-interject-connector &
  [  SYNSEM.LOCAL.CAT.HEAD punct & [MOD < [LOCAL.CAT.HEAD adj & [KEYS.KEY adj-decl-selct],
                                           LOCAL.CAT.VAL.COMPS <>,
					   LOCAL.CONT.HOOK.LTOP #ltop]  >],
     SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
     SYNSEM.LOCAL.CONT.RELS <! [ LBL #ltop ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>,
     SYNSEM.LKEYS.KEYREL [PRED "_punctuation_c_rel"] ].

quotation-connect-punctuation := reg-mod-lex-item &
  [  SYNSEM.LOCAL.CAT.HEAD punct & [MOD < [LOCAL.CAT.HEAD verb-all,
                                           LOCAL.CAT.VAL.COMPS <>]  >],
     SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
     SYNSEM.LOCAL.CONT.HCONS <! !>,
     SYNSEM.LKEYS.KEYREL [PRED "_punctuation_c_rel"] ].

rel-cl-connect-punctuation := rel-cl-connector &
  [  SYNSEM.LOCAL.CAT.HEAD punct,
     SYNSEM.LKEYS.KEYREL [PRED "_punctuation_c_rel"]].

rel-cl-nonrestr-punctuation := rel-cl-nonrestr-connector &
  [  SYNSEM.LOCAL.CAT.HEAD punct,
;     SYNSEM.LOCAL.HAS-PUNCT +,
     SYNSEM.LOCAL.HAS-PUNCT bool ].

app-punctuation := n-connector-2 &
  [  SYNSEM.LOCAL.CAT.HEAD punct,
;     SYNSEM.LOCAL.HAS-PUNCT +,
     SYNSEM.LOCAL.HAS-PUNCT bool ].

app-nonrestr-punctuation := n-nonrestr-connector &
  [  SYNSEM.LOCAL.CAT.HEAD punct,
;     SYNSEM.LOCAL.HAS-PUNCT +,
     SYNSEM.LOCAL.HAS-PUNCT bool ].

v-connect-word := v-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos ].

v-connect-comma := v-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
;     SYNSEM.LOCAL.HAS-PUNCT +,
     SYNSEM.LOCAL.HAS-PUNCT bool ].

a-connect-word := a-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos ].

a-connect-comma := a-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos,
;     SYNSEM.LOCAL.HAS-PUNCT +,
     SYNSEM.LOCAL.HAS-PUNCT bool ].

n-connect-word := n-connector &
  [  SYNSEM.LOCAL.CAT.HEAD connect-n ].

n-connect-comma := n-connector &
  [  SYNSEM.LOCAL.CAT.HEAD connect-n,
;     SYNSEM.LOCAL.HAS-PUNCT +,
     SYNSEM.LOCAL.HAS-PUNCT bool ].

p-adv-connect-word := p-adv-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos ].

p-adv-dir-connect-word := p-adv-dir-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos ].

p-adv-connect-adv-word := p-adv-connector &
  [  SYNSEM.LOCAL.CAT.HEAD conn-pos ].

coordinating-pos-v-dir-word := coordinating-v-dir-word.
; & coordinating-pospol-word.

;coordinating-v-comma := coordinating-v-word-sup &
;  [ SYNSEM.LOCAL.CAT.HEAD comma-coord ].

coordinating-relcl-word := word &
  [ SYNSEM.LOCAL.CAT.HEAD word-coord,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & [SORT #7 ],
    SYNSEM.LOCAL.CONT.RELS <! conjunction-relation &
                            [ C-ARG #2,
                              LBL #5,
                              R-INDEX #1,
                              R-HNDL #3,
                              L-INDEX #6 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [ LARG #5 ] !>,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD #8 & verb-all & [WH-COMPLETE +],
                                 LOCAL.CONT.HOOK.INDEX #6 & [E.TENSE #11],
                                 LOCAL.CAT.VAL [ COMPS #9,
                                                 ICOMPS #10 ]] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS < canonical-synsem &
                                 [LOCAL.XCAT.HEAD #8 & verb-all & [WH-COMPLETE +],
                                  LOCAL.CAT.VAL [ COMPS #9,
                                                  ICOMPS #10 ],
                                  LOCAL.CONT.HOOK.INDEX #1 & [SORT #7,
                                                              E.TENSE #11],
                                  LOCAL.CONT.HOOK.LTOP #3 ] > ].

coordinating-adj-word-sup := word &
  [ SYNSEM.LOCAL.CAT.HEAD coord,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & [SORT #7 ],
    SYNSEM.LOCAL.CONT.RELS <! conjunction-relation &
                            [ C-ARG #2,
                              LBL #5,
                              R-INDEX #1,
                              R-HNDL #3,
                              L-INDEX #6,
							  L-HNDL #12 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [ LARG #5 ] !>,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD #8 & adj-reg,
                                 LOCAL.CONT.HOOK.INDEX #6,
								 LOCAL.CONT.HOOK.LTOP #12,
                                 LOCAL.CAT.VAL [ COMPS #9,
                                                 ICOMPS #10 ]] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS < canonical-synsem &
                                 [LOCAL.CAT.HEAD #8 & adj,
                                  LOCAL.CAT.VAL [ COMPS #9,
                                                 ICOMPS #10 ],
                                  LOCAL.CONT.HOOK.INDEX #1 & [SORT #7],
                                  LOCAL.CONT.HOOK.LTOP #3 ] > ].

coordinating-adj-word := coordinating-adj-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD word-coord ].
coordinating-pos-adj-word := coordinating-adj-word.
; & coordinating-pospol-word.
coordinating-neg-adj-word := coordinating-adj-word.
; & coordinating-negpol-word.

coordinating-adj-comma := coordinating-adj-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD comma-coord,
     SYNSEM.LOCAL.HAS-PUNCT + ].

coordinating-v-dir-word := word &
  [ SYNSEM.LOCAL.CAT.HEAD coord,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    SYNSEM.LOCAL.CONT.RELS <! conjunction-relation &
                            [ C-ARG #2,
                              LBL #5,
                              R-INDEX #1,
                              R-HNDL #3,
                              L-INDEX #6 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [ LARG #5 ] !>,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD adv-reg & [KEYS.KEY dir],
                                 LOCAL.CONT.HOOK.INDEX #6] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS < canonical-synsem &
                                 [LOCAL.XCAT.HEAD verb-all,
                                  LOCAL.CONT.HOOK.INDEX #1 & [E.TENSE infin],
                                  LOCAL.CONT.HOOK.LTOP #3 ] > ].

coordinating-coord-word-sup := word &
  [ SYNSEM.LOCAL.CAT.HEAD coord,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & [SORT #7],
    SYNSEM.LOCAL.CONT.RELS <! conjunction-relation &
                            [ C-ARG #2,
                              LBL #5,
                              R-INDEX #1,
                              R-HNDL #3,
                              L-INDEX #6 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [ LARG #5 ] !>,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CONT.HOOK.INDEX #6] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS < canonical-synsem &
                                 [LOCAL.CAT.HEAD coord,
                                  LOCAL.CONT.HOOK.INDEX #1 & [SORT #7],
                                  LOCAL.CONT.HOOK.LTOP #3 ] > ].

coordinating-coord-word := coordinating-coord-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD word-coord ].
coordinating-coord-comma := coordinating-coord-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD comma-coord,
     SYNSEM.LOCAL.HAS-PUNCT + ].

correlative-coord-word := reg-mod-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD correl-coord & [ MOD <[LOCAL.COORD-RELEASED #1]>],
    SYNSEM.LOCAL.COORD-RELEASED #1 ].

correl-pos-coord-word := correlative-coord-word &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD <[LOCAL.COORD-POL +]>]].
correl-neg-coord-word := correlative-coord-word &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD <[LOCAL.COORD-POL -]>]].

;;;;;;; PREPOSITIONS

dir-lex-item := word-or-lexrule &
  [ SYNSEM.LOCAL.CAT.HEAD.LEG-SWITCH bool ].

; SYNSEM.NON-LOCAL.SLASH <!!> in order to forestall crazy filler-construal
prep-word := word & 1arg-1comps &
  [ SYNSEM arg2-comps-synsem & [LOCAL [CAT [HEAD #3 & prep-ultra ],
                                       XCAT [HEAD #3 ]]],
    SYNSEM.LOCAL.CAT.VAL.COMPS < #1 >,
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT #1,
    SYNSEM.LOCAL [ CONT.HOOK.XARG #2 ],
    SYNSEM.LKEYS.KEYREL arg12-relation & [ARG1 #2 ],
    EXTRACTED-FROM -,
    SYNSEM.BIND unbnd  ].

prep-n-word := prep-word &
  [ SYNSEM [LOCAL.CAT [ VAL.COMPS 1-list & [FIRST.LOCAL.CAT.HEAD poss-subj-head,
                                            FIRST.LOCAL.CONT.HOOK.INDEX #1,
                                            FIRST.LOCAL.DERIVED-HEAD bool],
                        QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1]] ].


prep-s-word := word & 1arg-1comps &
  [ SYNSEM arg2-comps-synsem & [LOCAL [CAT [HEAD #3 & adjct-comp ],
                                       XCAT [HEAD #3 ]]],
    SYNSEM.LOCAL.CAT.VAL.COMPS < #1 >,
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT #1 & [LOCAL.CAT.HEAD verb-all & [MOD <>],
					LOCAL.CAT.VAL [SUBJ olist,
						       COMPS <>,
						       ICOMPS <>,
						       SPR <>,
						       SPEC <>]],
    SYNSEM.LOCAL [ CONT.HOOK.XARG #2 ],
    SYNSEM.LKEYS.KEYREL arg12-relation & [ARG1 #2 ],
    EXTRACTED-FROM -,
    SYNSEM.BIND unbnd  ].

; for the moment leaving open whether '-reg' or 'dir-'
;prep-s-word := prep-word &
;  [ SYNSEM [LOCAL [CAT [ VAL.COMPS <[LOCAL.CAT.HEAD verb-all & [MOD <>]]> ]] ]].

; ARG2 should be a handle, not ref-ind, but error-messages come out indicating that clashes with constraints of arg2-comps-synsem, which however seems not to conflict. But somewhere the ARG2 is constrained to be 'individual' - not clear where. TODO.
;prep-s-word := prep-word &
;  [ SYNSEM [LOCAL [CAT [ VAL.COMPS <[LOCAL.CAT.HEAD verb-all & [MOD <>],
;				     LOCAL.CONT.HOOK.LTOP #1]>,
;			 QVAL.DOBJECT.LOCAL.CONT.HOOK.LTOP #1 ]],
;	    LKEYS.KEYREL.ARG2 #1 ]].


prep-rais-word := word & 1arg-1comps & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD prep-comp & [KEYS.KEY rais],
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ < synsem >,    
                                   LOCAL.CAT.HEAD infin-comp & [TRANSPAR +],
                                   LOCAL.CONT.HOOK.LTOP #3,
                                   LOCAL.CONT.HOOK.XARG #1,
				   LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl ]>,   
    SYNSEM.LOCAL.CAT.VAL.COMPS < #4 >,
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT #4,   
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    SYNSEM.LKEYS.KEYREL arg12-relation & [ARG2 #3],
    SYNSEM.LOCAL.CONT.RELS <! [] !>,
    SYNSEM.LOCAL.CONT.HCONS <!  !>].

;KEYS.KEY index-sit1,                                
prep-rais-vp-mod-word := word & 1arg-1comps & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD prep & [SELECTED -,
;				  KEYS.KEY rais,
                                  MOD < [LOCAL.CAT.HEAD verb-all,
                                         LOCAL.CONT.HOOK.INDEX #2,
                                         LOCAL.CONT.HOOK.XARG #1] >],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ < synsem >,    
                                   LOCAL.CAT.HEAD infin-comp & [TRANSPAR +],
                                   LOCAL.CONT.HOOK.LTOP #4,
                                   LOCAL.CONT.HOOK.XARG #1 ]>,   
   SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;   SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
   SYNSEM.LKEYS.KEYREL #5,
   SYNSEM.LOCAL.CONT.RELS <! #5 & arg12-relation & [ARG1 #2,
                                                    ARG2 #4] !>,
   SYNSEM.LOCAL.CONT.HCONS <! !> ].

; all items of this type are now suspended, and therewith the rules head-verb-prepindirwhquest-comp-phrase and head-prep-indirwhquestclause-comp-phrase lh Dec07-06
#|
prep-indirwhquest-word := word & lex-synsem & reg-mod-lex-item & 1arg-1comps &
  [ SYNSEM.LOCAL.CAT.HEAD prep-comp & [SELECTED +,
                                       KEYS.KEY indirqu ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD verb-or-comp,
                                  LOCAL.CAT.HEAD.DECL -,
                                  LOCAL.CONT.HOOK.LTOP #2 & semarg,
                                  LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,   
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT indirquest-prep,
    SYNSEM.LKEYS.KEYREL arg12-relation & [ARG2 #2 ] ].
|#

; to get      jeg snakker om hvorvidt du kommer
;            *jeg stoler p√• hvorvidt du kommer
; we need two types of these, or three, according to whether
; they allow a question to follow. And intrans-obl-verbs must
; be subclassified accordingly 
; right now, only a hack, letting "p√•_clause" select declarative clause,
; reflecting the behavior for "stole p√•"

;;; DPF 020411


prep-clause-word := word & lex-synsem & reg-mod-lex-item & 1arg-1comps &
  [ SYNSEM.LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY clse,
                                        SELECTED +],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT [ HEAD verb-or-comp,
					      VAL.SUBJ antilist ],
                                  LOCAL.CONT.HOOK.LTOP #2 & semarg,
                                  LOCAL.CONT.HOOK.INDEX.E.TENSE tense] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS < #1 >,
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT #1,   
    SYNSEM.LKEYS.KEYREL arg12-relation & [ARG2 #2 ] ].


#|
prep-clause-word := word & lex-synsem & reg-mod-lex-item & 1arg-1comps &
  [ SYNSEM.LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY clse,
                                        SELECTED +],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD verb-or-comp,
                                  LOCAL.CONT.HOOK.LTOP #2 & semarg,
                                  LOCAL.CONT.HOOK.INDEX.E.TENSE tense] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS < #1 >,
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT #1,   
    SYNSEM.LKEYS.KEYREL arg12-relation & [ARG2 #2 ] ].
|#



prep-bareclause-word := word & lex-synsem & reg-mod-lex-item & 1arg-1comps &
  [ SYNSEM.LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY clse ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD verb-all,
                                  LOCAL.CONT.HOOK.LTOP #2 & semarg,
                                  LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,   
    SYNSEM.LKEYS.KEYREL arg12-relation & [ARG2 #2 ] ].

; til, med, som; ... til √•
; LOCAL.CAT.HEAD glob-comp -> fin-comp. Too much doubling with prep-rais-word
prep-expl-dep-word := word & 1arg-1comps & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD prep-comp & [KEYS.KEY rais],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ < synsem >,    
                                   LOCAL.CAT.HEAD fin-comp,
                                   LOCAL.CONT.HOOK.LTOP #3 ]>,   
;   SYNSEM.LOCAL.CONT.HOOK.XARG expl-ind,
   SYNSEM.LOCAL.CONT.HOOK.XARG ref-ind,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
   SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
   SYNSEM.LOCAL.CONT.RELS <! [ PRED "expl-dep_rel" ] !>,
   SYNSEM.LOCAL.CONT.HCONS <! !> ].

; som  KEY som-rais
prep-s-expl-dep-word := word & 1arg-1comps & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD prep-comp & [KEYS.KEY rais],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ list,    
                                   LOCAL.CAT.HEAD verb-all,
                                   LOCAL.CONT.HOOK.LTOP #3 ]>,   
;   SYNSEM.LOCAL.CONT.HOOK.XARG expl-ind,
   SYNSEM.LOCAL.CONT.HOOK.XARG ref-ind,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
   SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
   SYNSEM.LOCAL.CONT.RELS <! [PRED "_som_eq_rel"] !>,
   SYNSEM.LOCAL.CONT.HCONS <! !>].



prep-s-word-reg := reg-mod-lex-item & prep-s-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY der-n√•r,
    SYNSEM.LOCAL.CAT.HEAD.SELECTED - ].

prep-s-word-modadvreg := xarg-mod-lex-item-2 & prep-s-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit2,
    SYNSEM.LOCAL.CAT.HEAD.SELECTED - ].



prep-s-word-vmod-reg-time := prep-s-word-reg &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-time,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]> ].

prep-s-word-nmod-reg-time := prep-s-word-reg &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-time,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD comm-noun,
                                LOCAL.CONT.HOOK.INDEX.SORT time-item]> ].

;LH trying, to get the expn like other subords in v-trExpnSu-expnCOND 
;prep-s-word-reg-plce := subord-comp &
;  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-place ].
;previously, and again - unclear what the above did
prep-s-word-reg-plce := prep-s-word-reg &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-place ].

prep-s-word-reg-cond := prep-s-word-reg &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-condition ].


;;; a modadv-batch:

prep-s-word-vmod-modadvreg-time := prep-s-word-modadvreg &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-time,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]> ].

prep-s-word-nmod-modadvreg-time := prep-s-word-modadvreg &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-time,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD comm-noun,
                                LOCAL.CONT.HOOK.INDEX.SORT time-item]> ].

prep-s-word-modadvreg-plce := prep-s-word-modadvreg &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-place ].

prep-s-word-modadvreg-cond := prep-s-word-modadvreg &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-condition ].

;;;;;;;;;;


prep-vp-word-reg-time := reg-mod-lex-item & prep-vp-word & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT correlated-event-time ].

prep-nom-vp-word := word & 1arg-1comps &
  [ SYNSEM arg2-comps-synsem & [LOCAL [CAT [HEAD prep,
                                            HEAD.MOD < [LOCAL.CONT.HOOK.INDEX #1,
                                                        LOCAL.CAT.HEAD nominal] >,
                                            VAL.COMPS <[LOCAL.CAT.HEAD verb,
                                                        LOCAL.CONT.HOOK.XARG #1]>]],
                                LKEYS.KEYREL arg12-relation]].

prep-nom-vp-word-reg-refind := reg-mod-lex-item & prep-nom-vp-word & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT semsort ].


; for the moment leaving open whether '-reg' or 'dir-'
prep-vp-word := prep-word &
  [ SYNSEM [LOCAL [CAT [HEAD prep,
                        HEAD.MOD < [LOCAL.CONT.HOOK.XARG #1,
                                    LOCAL.CAT.HEAD verb] >,
                        VAL.COMPS <[LOCAL.CAT.HEAD verb,
                                    LOCAL.CONT.HOOK.XARG #1]>]]]].

; using
; COMPS 1-list & [FIRST.LOCAL.CAT.HEAD cl-adjct inst of
; COMPS 1-list & [FIRST.LOCAL.CAT.HEAD prep-or-adv   -
; covers the same...
prep-p-adv-word := prep-word &
  [ SYNSEM [LOCAL.CAT [ VAL.COMPS 1-list & [FIRST.LOCAL.CAT.HEAD cl-adjct,
                                            FIRST.LOCAL.CONT.HOOK.INDEX #1,
                                            FIRST.LOCAL.DERIVED-HEAD -],
                        QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1]] ].

dir-prep-p-adv-word := prep-p-adv-word & dir-mod-lex-item.
prep-p-adv-word-reg := prep-p-adv-word & reg-mod-lex-item &
 [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb-all-or-noun,
				 LOCAL.CONT.HOOK.INDEX #1] >,
   SYNSEM.LKEYS.KEYREL.ARG1 #1 ].

; removed ',
; removed prep DECL+
;    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX [SORT referential-thin;  g]]>' - clashing with preps taking temporal objects and other special sorts
; prep taking clauses and inf have to find another category - prep-clause-word
prep-word-reg := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED -,
					KEYS.KEY index-sit1],
;    SYNSEM.LOCAL.CONT.HOOK [INDEX.SORT non-fix-point ],
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.DERIVED-HEAD -,
                                 LOCAL.CAT.HEAD np-head]>,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb-all-or-noun ] >,
    SYNSEM.LOCAL.KEY-SPEC #1,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD [KEYS.KEY #1]]>].


; like above
prep-modadvreg-word := xarg-mod-lex-item-2 & prep-word &
  [ SYNSEM.LOCAL.CAT.HEAD prep & [SELECTED -,
				  KEYS.KEY index-sit2 ],
    SYNSEM.LKEYS.KEYREL prep-mod-relation,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.DERIVED-HEAD -,
                                 LOCAL.CAT.HEAD np-head]>,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD prep-or-adv & [SELECTED -,
								KEYS.KEY index-sit1],
				  LOCAL.DERIVED-HEAD -] > ].

#|
prep-word-agent := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD  [KEYS.KEY index-sit1 ],
    SYNSEM.LOCAL.CONT.HOOK [INDEX.SORT non-fix-point ],
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb & [ VOICE passive ],
				  LOCAL.CONT.HOOK.VARG #1 ] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD np-head,
				 LOCAL.CONT.HOOK.INDEX #1]> ].
|#

prep-word-agent := lbl-ltop-lex-item-2rel & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD  [KEYS.KEY index-sit1 ],
    SYNSEM.LOCAL.CONT.HOOK [INDEX.SORT non-fix-point ],
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb & [ VOICE passive ],
				  LOCAL.CONT.HOOK.VARG #3 ] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD np-head,
				 LOCAL.CONT.HOOK.INDEX #4]>,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #1,
                                  LOCAL.CONT.HOOK.LTOP #2,
                                  LKEYS.KEYREL.LBL #2,
                                  LOCAL.CAT.VAL.COMPS list]>,
    SYNSEM.LOCAL.CONT.RELS <! [], [ PRED "_identical-to_rel",
				    ARG1 #3,
				    ARG2 #4 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           SPEC <> ],
    SYNSEM.LKEYS.KEYREL [ ARG1 #1 ],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1].

; undergoes unary rule first
; selected Ps that are not in detach-poss and not in "om at..."-constr
prep-word-sel := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED +,
                                        KEYS.KEY fct-spec,
                                        MOD <[LOCAL.CAT.HEAD verb-all]>],
    SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX ref-ind & #1 & [SORT referential-thing],
                                  LOCAL.CAT.HEAD np-head] >,
    SYNSEM.LOCAL.DERIVED-HEAD - ].

; for detached-poss
prep-detachposs-word := lbl-ltop-lex-item & prep-n-word &
  [ SYNSEM arg2-comps-synsem & [LOCAL [CAT [HEAD prep-ultra & [KEYS.KEY detch,
                                                               SELECTED +] ]]],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #2 & [SORT referential-thing]]>,
    SYNSEM.LOCAL.CONT.HOOK [VARG #2,
                            XARG #1 ],
    SYNSEM.LKEYS.KEYREL arg12-relation & [ARG1 #1 & event-verb,
                                          ARG2 #2 ],
    EXTRACTED-FROM -,
    SYNSEM.BIND unbnd  ].

; for "spise av/p√• br√∏det"
;prep-atelic-word := word & lbl-ltop-lex-item &
prep-atelic-word := reg-mod-lex-item & prep-n-word & 
  [ SYNSEM arg2-comps-synsem & [LOCAL [CAT [HEAD prep-ultra & [KEYS.KEY atelic-operation,
                                                               SELECTED +] ]]],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #2 & [SORT referential-thing]]>,
    SYNSEM.LKEYS.KEYREL arg12-relation & [PRED "_affect_rel",
                                          ARG1 #xarg,
                                          ARG2 #2 ],
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    EXTRACTED-FROM -,
    SYNSEM.BIND unbnd  ].

time-prep-word := reg-mod-lex-item & prep-n-word &
  [ SYNSEM arg2-comps-synsem & [LKEYS.KEYREL line-to-xdim-temporal-rel],
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY index-sit1 ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD noun & [KEYS.KEY predsort ],
                                   LOCAL.CONT.HOOK.INDEX [SORT time-item]]>,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb ]> ].

; leaves the 'LEG' aspect out, since it uses 'prep-mod-relation'
;dir-prep-word := dir-mod-lex-item & prep-n-word.

#|
; march22-06: comm-out, along with using prep-line-rel
; assumed in 'Without-Predsort' march08.05lh - till ;;;
dir-prep-word := dir-mod-lex-item & prep-n-word &
  [ SYNSEM arg2-comps-synsem & [LKEYS.KEYREL prep-path-rel & [ LEG #1 ]],
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX [SORT referential-thing]]>,
    SYNSEM.LOCAL.CONT.HOOK.XLEG #1,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb ]> ].
|#

; SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD head ]> to allow PP modifying derived adjective, as in "spredd over plassen"
dir-prep-word := dir-mod-lex-item & prep-n-word &
  [ SYNSEM arg2-comps-synsem & [LKEYS.KEYREL prep-line-rel],
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX [SORT referential-thing],
                                   LOCAL.CAT.HEAD  nominal ]>,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD head ]> ].

dir-fixpoint-prep-word := dir-prep-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY pathconsumpt-dir ] ].

dir-nonfixpoint-prep-word := dir-prep-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point ].
    
; for PPs modifying adv

; this type also represents PP adjoining to PP. In this case, the
; specification 'MOD<[LKEYS.KEYREL orient-adv-rel]>' plays no role, since
; LKEYS specification does not reach phrasal level. (Otherwise it
; would have blocked operation, so a good thing...)
; SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD prep-or-adv & [SELECTED bool] - bool here to allow "han vil inn i huset", where "vil" combines by head-verb-adverb-comp-rule, which otherwise requires selected+.
dir-prep-2-word := dir-mod-lex-item & prep-n-word &
  [ SYNSEM arg2-comps-synsem & [LKEYS.KEYREL prep-line-rel],
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir2 ],
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD prep-or-adv & [SELECTED bool],
                                  LOCAL.DERIVED-HEAD -,
				  LKEYS.KEYREL orient-adv-rel ]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX [SORT referential-thing],
                                   LOCAL.CAT.HEAD  np-head ]>].

dir-fixpoint-prep-2-word := dir-prep-2-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY fixptconsumpt-dir2 ] ].

dir-nonfixpoint-prep-2-word := dir-prep-2-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY nonfixpt-dir2 ] ].    
;;;

; assumed in Predsort march08.05lh - till ;;;
dirarg-prep-word := dir-mod-lex-item & prep-n-word &
  [ SYNSEM arg2-comps-synsem & [LKEYS.KEYREL prep-mod-relation],
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir ],
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb-or-noun ]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX [SORT referential-thing],
                                   LOCAL.CAT.HEAD  np-head ]> ].

dirarg-telic-prep-word := dirarg-prep-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion ].

dirarg-atelic-prep-word := dirarg-prep-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point ].

dirarg-prep-2-word := dir-mod-lex-item & prep-word &
  [ SYNSEM arg2-comps-synsem & [LKEYS.KEYREL prep-mod-relation],
    SYNSEM.LOCAL.CAT.HEAD.TEL-FIXING -,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD adv & [SELECTED -],
                                  LKEYS.KEYREL orient-adv-rel ]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.DERIVED-HEAD -,
                                   LOCAL.CONT.HOOK.INDEX [SORT referential-thing]]> ].

dirarg-telic-prep-2-word := dirarg-prep-2-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion ].

dirarg-atelic-prep-2-word := dirarg-prep-2-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point ].   
;;;

; det er under tvil at han kommer
prep-arg1prop-epon-lxm := lbl-ltop-lex-item &
  [ SYNSEM.LKEYS.KEYREL arg12-relation,
     SYNSEM.LOCAL.CAT.HEAD prep,
    SYNSEM.LKEYS.KEYREL.ARG1 #1 & handle,
    SYNSEM.LKEYS.KEYREL.ARG2 #3,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD comm-noun,
				   LOCAL.CONT.HOOK.INDEX #3], 
				 [ LOCAL.CAT.HEAD fin-comp,
				   LOCAL.CONT.HOOK.LTOP #1] >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    SYNSEM.LOCAL.CAN-MODIFY -,
    SYNSEM.NON-LOCAL.SLASH 0-dlist  ].   







nom-dir-prep-word := reg-mod-lex-item & prep-word &
  [ SYNSEM.LKEYS.KEYREL prep-line-rel,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir,
                           SELECTED -],
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD np-head,
                                  LOCAL.CONT.HOOK.INDEX.SORT one-dim-thing ] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX [SORT referential-thing]]>].

nom-dir-fixpt-prep-word := nom-dir-prep-word &
  [ SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY fixpt-dir ]].
nom-dir-nonfixpt-prep-word := nom-dir-prep-word &
  [ SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY nonfixpt-dir ]].

tel-fix-word := word & 1arg-1comps &
  [ SYNSEM.LOCAL.CAT.HEAD [TEL-FIXING +,
                           SELECTED -],
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CONT.HOOK.INDEX.SORT time-item,
                                 LOCAL.CAT.HEAD.KEYS.KEY meastimenoun]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT telmarking,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all  ]>].

tel-fix-pathtelic-word := tel-fix-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT accomplishment-time,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK dir-hook,
				LOCAL.CONT.HOOK.INDEX.PATH-TELIC +,
                                LOCAL.PATHTELFIXED -,
                                LOCAL.PATHTELACTV +]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY telfix ].

tel-fix-path-atelic-word := tel-fix-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT duration-time,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK dir-hook,
				LOCAL.CONT.HOOK.INDEX.PATH-TELIC -,
                                LOCAL.PATHTELFIXED -,
                                LOCAL.PATHTELACTV +]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY telfix ].

tel-fix-delim-word := tel-fix-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT accomplishment-time,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX.E.DELIMITED +,
                                LOCAL.DELIMTELFIXED -,
                                LOCAL.DELIMTELACTV +]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY delimfix ].

tel-fix-nondelim-word := tel-fix-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT duration-time,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX.E.DELIMITED -,
                                LOCAL.DELIMTELFIXED -,
                                LOCAL.DELIMTELACTV +]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY delimfix ].

; also tel-fix-incremtelic, same ways...

tel-fix-prep-word := prep-n-word & tel-fix-word & reg-mod-lex-item.

tel-fix-pathtelic-prep-word := tel-fix-prep-word & tel-fix-pathtelic-word.
  
tel-fix-path-atelic-prep-word := tel-fix-prep-word & tel-fix-path-atelic-word.

tel-fix-delim-prep-word := tel-fix-prep-word & tel-fix-delim-word.

tel-fix-nondelim-prep-word := tel-fix-prep-word & tel-fix-nondelim-word.

; the specification ...LOCAL.CAT.HEAD.KEYS.KEY regnoun] excludes poss-prep from cooccurring with relational nouns, which is of course wrong, but since they always will have a relational prep allowed, we reduce parse proliferation
prep-word-poss := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LKEYS.KEYREL possessed-by-rel,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.DEFINITE +,
                                  LOCAL.CAT.HEAD.KEYS.KEY regnoun] >,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY possprep ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX [SORT animfull-thing],
                                   LOCAL.CAT.HEAD np-head & [KEYS.KEY animnoun] ]> ].

;,
;    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.TRANSPAR - ]>
rel-prep-word := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.SORT relatum,
                                  LOCAL.CAT.HEAD comm-noun & [KEYS.KEY relnoun]] >,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.DERIVED-HEAD -,
                                 LOCAL.CAT.HEAD nominal]>,
    SYNSEM.LOCAL.CAT.HEAD [TEL-FIXING -,
                           SELECTED +,
                           KEYS.KEY preprel],
    SYNSEM.LOCAL.CAN-CMB-V - ].

und-rel-prep-word := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LKEYS.KEYREL.PRED "takes_as_undergoer_rel",
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.SORT init-und,
                                  UNDERGOER-OPEN - ] >,
    SYNSEM.LOCAL.CAT.HEAD [TEL-FIXING -,
                           SELECTED - ] ].

init-rel-prep-word := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LKEYS.KEYREL.PRED "_takes_as_initiator_rel",
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.SORT init-or-actor,
                                  UNDERGOER-OPEN - ] >,
    SYNSEM.LOCAL.CAT.HEAD [TEL-FIXING -,
                           SELECTED - ] ].

perform-rel-prep-word := reg-mod-lex-item & prep-n-word &
  [ SYNSEM.LKEYS.KEYREL.PRED "_takes_as_performer_rel",
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.SORT init-or-actor ] >,
    SYNSEM.LOCAL.CAT.HEAD [TEL-FIXING -,
                           SELECTED - ] ].




;;;; ADVERBS
adv-word :=  word &
  [ SYNSEM [LOCAL [CAT [HEAD #3 & adv,
                        VAL.COMPS <>],
                   XCAT [HEAD #3 ],
                   CONT.HOOK.INDEX ad-event,
		   DERIVED-HEAD bool],
            LKEYS.KEYREL arg1-relation ],
    EXTRACTED-FROM -].

; the intuition is that these 'particles' are always selected
; removed ,
;                                              KEYS.KEY adv-selct
adv-particle-word :=   reg-mod-lex-item & word & 
  [ SYNSEM [LOCAL [CAT [HEAD #3 & adv-reg & [ MOD <[LOCAL.CONT.HOOK hook] >,
                                              SELECTED +,
                                              KEYS.KEY pcl ]],
                   XCAT.HEAD #3,
                   CONT.HOOK.INDEX ad-event ]]].

; to make compatible with rule for fronted adverbs
; ,
;                                   KEYS.KEY adv-s
;LOCAL.CONT.RELS <!  ad-rel &
;s-adv-word := word &  lbl-ltop-lex-item &
;  [ SYNSEM.LOCAL.CAT.HEAD s-adv & [MOD < [ LOCAL.CONT.HOOK.LTOP #4 & handle,
;                                           LOCAL.ADJ-SITE-OPEN + ]>],  
;    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
;    SYNSEM.LKEYS.KEYREL [ARG0 ad-event,
;                         ARG1 #4,
;                         LBL #1 ],
;    SYNSEM.LOCAL.CONT.HCONS <! !> ].

; need LOCAL.CAT.HEAD verb-all, -> head
; for fragments - with relaxation also in the syntax rule   TODO                                  
;VAL.SPEC < [ LOCAL.CAT.HEAD verb-all,
s-operadv-word := word &  lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT [HEAD s-adv & [KEYS.KEY adv-s],
                      VAL.SPEC < [ LOCAL.CAT.HEAD head,
                                   LOCAL.CONT.HOOK.LTOP #4 & handle,
                                   LOCAL.ADJ-SITE-OPEN + ] >],  
    SYNSEM.LKEYS.KEYREL [ARG0 ad-event,
                         ARG1 #4 ],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    CAN-OCCUR-INITIAL bool,
    CAN-OCCUR-FINAL bool ].

s-operadv-init-word := s-operadv-word &
  [ CAN-OCCUR-INITIAL +,
    CAN-OCCUR-FINAL -].
s-operadv-final-word := s-operadv-word &
  [ CAN-OCCUR-INITIAL -,
    CAN-OCCUR-FINAL +].
s-operadv-init-final-word := s-operadv-word &
  [ CAN-OCCUR-INITIAL +,
    CAN-OCCUR-FINAL +].
s-operadv-stnd-word := s-operadv-word &
  [ CAN-OCCUR-INITIAL -,
    CAN-OCCUR-FINAL -].


qualadv-word := word &  lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT [HEAD s-adv & [KEYS.KEY adv-s],
                      VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #4 & handle,
                                   LOCAL.ADJ-SITE-OPEN + ] >],  
    SYNSEM.LKEYS.KEYREL [ARG0 ad-event,
                         ARG1 #4 ],
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

qualifadv-word := qualadv-word.
focqualifadv-word := qualadv-word.

qualifadv-quant-word := qualifadv-word &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CAT.HEAD quantor]> ].
qualifadv-allquant-word := qualifadv-word &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CAT.HEAD allquant]> ].
qualifadv-card-word := qualifadv-word &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CAT.HEAD card]> ].
focqualifadv-n-word := focqualifadv-word &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CAT.HEAD noun]> ].
focqualifadv-padv-word := focqualifadv-word &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CAT.HEAD prep-or-adv]> ].


m-adv-word := adv-word & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD adv & [KEYS.KEY adv-m],
    SYNSEM.LKEYS.KEYREL adj_rel & [ARG1 #1],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

; should somehow be distinguished from place-adverbs  TODO
time-adv-word := reg-mod-lex-item & adv-word  &
  [ SYNSEM.LOCAL.CAT.HEAD adv & [KEYS.KEY index-sit1],
;				 MOD <[LOCAL.CAT.HEAD verb-all]>],; tempting, but loses 'kampen imorgen' etc
;    SYNSEM.LKEYS.KEYREL adj_rel & [ARG1 #1],
;    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event & [SORT non-fix-point],
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

; not adv-reg
adv-word-reg-sup := reg-mod-lex-item & adv-word &
  [ SYNSEM.LOCAL.CAT.HEAD adv,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY index-sit1 ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event & [SORT non-fix-point] ].

adv-word-reg := adv-word-reg-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ].
; "hvor lenge varer det?" - 'hvor' must be able to combine with a normal adverb.
;adv-word-reg := adv-word-reg-sup &
;  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ].

adv-word-at-in-reg := adv-word-reg &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-in].
adv-word-at-out-reg := adv-word-reg &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-out].
adv-word-at-up-reg := adv-word-reg &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-up].
adv-word-at-down-reg := adv-word-reg &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-down].
adv-word-at-far-reg := adv-word-reg &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-far].
adv-word-at-home-reg := adv-word-reg &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-home].
adv-word-at-ahead-reg := adv-word-reg &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-ahead].
adv-word-at-back-reg := adv-word-reg &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-back].
adv-word-at-salientpoint-reg := adv-word-reg &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-salientpoint].
adv-word-at-awayfrom-salientpoint-reg := adv-word-reg &
  [ SYNSEM.LKEYS.KEYREL.ARG0.SORT at-awayfrom-salientpoint].


adv-word-vp-mod := adv-word-reg-sup &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [LOCAL.CAT.HEAD non-copula ] >],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ].
   


;dirarg-adv-word := dir-mod-lex-item & adv-word &
;  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb-or-noun ]> ].

dirarg-adv-word := dir-mod-lex-item & adv-word &
  [ SYNSEM.LOCAL.CAT.HEAD adv-reg & [MOD < [ LOCAL.CAT.HEAD verb-or-noun ]>],
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir ] ].

dirarg-telic-adv-word-sup := dirarg-adv-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY fixpt-dir ]  ].

dirarg-telic-adv-word := dirarg-telic-adv-word-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ].

wh-dirarg-telic-adv-word := dirarg-telic-adv-word-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH + ].

; a possible type (for "inn", f.ex.), but spurious, since in an
; adv-adv-modification, the ORIENT values would clash. We thereby
; miss a same-leg reading otherwise desirable. (Phrasal rule
; available: adv-mod-adv2-rule) If we want to get at the latter, 
; all words of this type would have to have 'ORIENT orient', and
; thus no represented semantics in the feature specification.
; This is exactly the course taken with regard to adv-word-2-reg
; (then concerning 'SORT place-param').
; (See also discussion for orient-adv-2-word.)

dirarg-telic-adv-2-word := dir-mod-lex-item & adv-word &
  [  SYNSEM.LOCAL.CAT.HEAD adv-reg & [MOD < [ LOCAL.CAT.HEAD adv ]>],
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
     SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY fixpt-dir2,
                            SELECTED - ]  ].

; this is the same as orient-adv-word - could be used instead
;dirarg-atelic-adv-word := dirarg-adv-word &
;  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point ].

dirarg-telic-to-in-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-in ].
dirarg-telic-to-out-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-out ].
dirarg-telic-to-up-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-up ].
dirarg-telic-to-down-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-down ].
dirarg-telic-to-far-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-far ].
dirarg-telic-to-along-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-along ].
dirarg-telic-to-home-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-home ].
dirarg-telic-to-ahead-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-ahead ].
dirarg-telic-to-back-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-back ].
dirarg-telic-to-at-salientpoint-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-at-salientpoint ].
dirarg-telic-to-awayfrom-salientpoint-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-awayfrom-salientpoint ].
dirarg-telic-to-right-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-right ].
dirarg-telic-to-left-adv-word := dirarg-telic-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-left ].


orient-adv-word-sup := dir-mod-lex-item-2 & adv-word &
  [ SYNSEM.LKEYS.KEYREL orient-adv-rel,
    SYNSEM.LOCAL.CAT.HEAD adv-reg & [MOD <[LOCAL.CAT.HEAD verb-or-noun ]>],
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY orient-dir ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point ].

orient-adv-word := orient-adv-word-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ].

wh-orient-adv-word := orient-adv-word-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH + ].

; a possible type, but spurious: if we want adv-adv-modif, the
; ORIENT values will clash. Hence ARG0s are distinct, and then
; we may as well use iterative V-adjunction. Hence no lex-items
; with this type
orient-adv-2-word := dir-mod-lex-item-2 & adv-word &
  [ SYNSEM.LKEYS.KEYREL orient-adv-rel,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD adv & [SELECTED -]  ]>,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY orient-dir ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point ].

orient-to-north-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-north ].
orient-to-south-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-south ].
orient-to-east-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-east ].
orient-to-west-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-west ].
orient-to-in-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-in].
orient-to-out-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-out].
orient-to-up-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-up].
orient-to-down-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-down].
orient-to-far-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-far].
orient-to-forth-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-forth].
orient-to-home-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-home].
orient-to-ahead-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-ahead].
orient-to-at-salientpoint-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-at-salientpoint].
orient-to-awayfrom-salientpoint-adv-word := orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-awayfrom-salientpoint].

wh-adv-word-reg := adv-word-reg-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH + ].

adv-word-2-reg := xarg-mod-lex-item-2 & adv-word &
 [ SYNSEM.LOCAL.CAT.HEAD adv-reg & [ KEYS.KEY index-sit2 ],
   SYNSEM [LKEYS.KEYREL arg1-relation,
           LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD adv-reg & [SELECTED -] ] >]].

adv-word-2placepar-reg := adv-word-2-reg &
 [ SYNSEM.LKEYS.KEYREL.ARG0.SORT place-param ].






#|
nom-orient-adv-word := reg-mod-lex-item & adv-word &
  [ SYNSEM.LKEYS.KEYREL orient-adv-rel,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY orient-dir ],
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD noun  ]> ].

nom-orient-to-south-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-south].
nom-orient-to-north-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-north].
nom-orient-to-east-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-east].
nom-orient-to-west-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-west].
nom-orient-to-down-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-down].
nom-orient-to-in-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-in].
nom-orient-to-out-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-out].
nom-orient-to-up-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-up].
nom-orient-to-far-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-far].
nom-orient-to-home-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-home].
nom-orient-to-ahead-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-ahead].
nom-orient-to-at-salientpoint-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-at-salientpoint].
nom-orient-to-awayfrom-salientpoint-adv-word := nom-orient-adv-word &
  [ SYNSEM.LKEYS.KEYREL.ARG0.ORIENT to-awayfrom-salientpoint].
|#



refl-adv-word := reg-mod-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD refl-adv,
    SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    SYNSEM.LKEYS.KEYREL asserted-id-rel,
    SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD pers-pron ]> ].


;;;;;;;; NP-internal items

adjectival-word := word &
  [ SYNSEM.LOCAL.CAT.HEAD #3 & adjectival,
    SYNSEM.LOCAL.XCAT [HEAD #3 ],
    SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    SYNSEM.LOCAL.CAT.VAL.SPEC list].

adjective-word := adjectival-word & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [WEAK #bool,
                                 DEGREE #degree],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.AGR.PNG.NG [NUM #num,
                             GEN #gen],
    INFL-MORPH [WEAKFORM #bool,
                DEG #degree,
                GEND #gen,
                NUMB #num] ].

adjective-word-2 := adjectival-word & lbl-ltop-lex-item-3rel &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [WEAK #bool,
                                 DEGREE #degree],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.AGR.PNG.NG [NUM #num,
                             GEN #gen],
    INFL-MORPH [WEAKFORM #bool,
                DEG #degree,
                GEND #gen,
                NUMB #num] ].


#|
adjective-word := adjectival-word & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [WEAK #bool,
                                 DEGREE #degree],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG [NUM #num,
                                        GEN #gen],
    INFL-MORPH [WEAKFORM #bool,
                DEG #degree,
                GEND #gen,
                NUMB #num] ].
|#

; changing from a-mod-phrase to head-spec-phrase, and thus MOD to SPEC
; see card-mod-phrase-sup

;SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [SORT card-unit],

cardinal-word := word & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX semarg, 
    SYNSEM.LOCAL.CAT.HEAD #3 & cardnum & [KEYS.KEY crdnum,
                                          DEGREE positive],
    SYNSEM.LOCAL.XCAT [HEAD #3 ],
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD nom ]>,     
;    SYNSEM.LKEYS.KEYREL card-relation,
    SYNSEM.LKEYS.KEYREL card-arg1-relation & [ARG1 #1],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    EXTRACTED-FROM -,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.NON-LOCAL.SLASH 0-dlist & [ LIST < > ] ].

; old version, when being a modifier (till July -06)
#|
cardinal-word := adjectival-word & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind & [SORT measure-unit], 
    SYNSEM.LOCAL.CAT.HEAD cardnum & [ MOD < [ LOCAL.CONT.HOOK.INDEX #1 ]>,
                                      KEYS.KEY crdnum ], 
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LKEYS.KEYREL card-relation,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].
|#

#|
; remove requirement of definiteness
ordinal-word := adjectival-word & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind, 
    SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CONT.HOOK.INDEX #1 ]>,
                                  WEAK +,
                                  DEGREE degree ], 
    SYNSEM.LKEYS.KEYREL card-relation,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].
|#

ordinal-word := adjectival-word & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD adj-reg & [ WEAK +,
				      DEGREE degree,
				      MOD < [LOCAL.CAT.HEAD noun,
					     LOCAL.CAT.VAL.SUBJ <>,
					     LOCAL.CAT.VAL.COMPS <>,
					     LOCAL.CAT.VAL.ICOMPS <>,
					     LOCAL.CAT.VAL.SPR <>]> ],
    SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LKEYS.KEYREL card-arg1-relation & [ARG1 #1],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

freestnding-weak-adj-word := adjectival-word & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind, 
    SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CONT.HOOK.INDEX #1,
                                         LOCAL.CAT.HEAD noun & [DEF + ],
                                         LOCAL.CAT.VAL.SPR < [] > ] >,
                                  WEAK +,
                                  DEGREE positive ], 
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LKEYS.KEYREL same-rel,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

#|
; TODO - fails to work in 'mine mange gutter' - doesnt catch index of N
quantity-word := adjectival-word & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1, 
    SYNSEM.LOCAL.CAT.HEAD cardquant & [ MOD < [ LOCAL.CONT.HOOK.INDEX #1 ]>],
    SYNSEM.LKEYS.KEYREL pron_rel,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].
|#

;INDEX -> XARG
plur-cardinal-word := cardinal-word &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG pl ].

;INDEX -> XARG
sg-cardinal-word := cardinal-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg ].

#|
; 'qualitative' count quantifiers
plur-quantity-word := quantity-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl,
    SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CAT.HEAD.DEF +]> ].

; not used so far (jul 05)
sg-quantity-word := quantity-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg ].
|#

;deleted WH -  in SYNSEM.LOCAL.CONT.HOOK.INDEX #4 & [ WH - ],
; in order to allow "hvor mange flere gutter"

cmpar-quantity-word := adjectival-word & lbl-ltop-lex-item-2rel & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #4, 
    SYNSEM.LOCAL.CAT.HEAD adj-quant & [KEYS.KEY adjquant-pre], 
    SYNSEM.LOCAL.CAT.HEAD.DEGREE comparative,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.INDEX #4,
                                  LOCAL.CAT.HEAD.DEFINITE -,
                                  LOCAL.CAT.HEAD.DEF -,
                                  LOCAL.CAT.HEAD.COMPAR-DEP enn-cmpar ]>,
    SYNSEM.LKEYS.KEYREL pron_rel,
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #4 ], 
                            compare-rel & [ PRED "_exceed_c_rel",
                                            ARG0 #8,
                                            ARG1 #4,
                                            ARG2 #5 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING + ].

cmpar-count-quantity-word := cmpar-quantity-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl ].

cmpar-mass-quantity-word := cmpar-quantity-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.DERIVED-HEAD - ] >].


; unclear how to deal with CMPAR-PENDING
#|
superlat-quantity-word := adjectival-word & lbl-ltop-lex-item-4rel & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #4, 
    SYNSEM.LOCAL.CAT.HEAD adj-quant, 
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH - ],
    SYNSEM.LOCAL.CAT.HEAD.DEGREE superlative,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.INDEX #4]>,
    SYNSEM.LKEYS.KEYREL pron_rel,
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #4 ], 
                            compare-rel & [ PRED "_exceed_c_rel",
                                            ARG0 #8,
                                            ARG1 #2,
                                            ARG2 #3 ],
                            measure-out-rel & [ ARG1 #2,
                                                ARG2 #4 ],
                            measure-out-rel & [ ARG1 #3,
                                                ARG2 #5 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING + ].
|#

superlat-quantity-word := adjectival-word & lbl-ltop-lex-item-2rel & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #4, 
    SYNSEM.LOCAL.CAT.HEAD adj-quant, 
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH - ],
    SYNSEM.LOCAL.CAT.HEAD.DEGREE superlative,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.INDEX #4]>,
    SYNSEM.LKEYS.KEYREL pron_rel,
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #4 ], 
                            compare-rel & [ PRED "_exceed_c_rel",
                                            ARG0 #8,
                                            ARG1 #4,
                                            ARG2 #5 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING + ].

superlat-count-quantity-word := superlat-quantity-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl ].

superlat-mass-quantity-word := superlat-quantity-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.DERIVED-HEAD - ] >].

superlat-strong-quantity-word := superlat-quantity-word &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.DEFINITE -,
                                  LOCAL.CAT.HEAD.DEF -]>].

superlat-weak-quantity-word := superlat-quantity-word &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.DEF +,
                                  LOCAL.CAT.VAL.SPR <[]>]>].

superlat-count-strong-quantity-word := superlat-count-quantity-word & superlat-strong-quantity-word &
  [ SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY adjquant-pre]].
superlat-count-weak-quantity-word := superlat-count-quantity-word & superlat-weak-quantity-word &
  [ SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY adjquant-pre]].
superlat-mass-strong-quantity-word := superlat-mass-quantity-word & superlat-strong-quantity-word &
  [ SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY adjquant-pre]].
superlat-mass-weak-quantity-word := superlat-mass-quantity-word & superlat-weak-quantity-word &
  [ SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY adjquant-pre]].

superlat-count-post-quantity-word := superlat-strong-quantity-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY adjquant-post]].


; still tidy up semantics here
#|
superlat-cum-part-quantity-word := adjectival-word & lbl-ltop-lex-item-4rel & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #4, 
    SYNSEM.LOCAL.CAT.HEAD adj-quant & [KEYS.KEY adjquant-pre], 
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH - ],
   SYNSEM.LOCAL.CAT.HEAD.DEGREE superlative,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD part-prep,
                                 LOCAL.CONT.HOOK.XARG #10,
                                 LOCAL.CONT.HOOK.CMPAR-ARG #7,
                                 LOCAL.CAT.VAL.SPR <[], [LOCAL.CAT.HEAD det]>] >,
    SYNSEM.LKEYS.KEYREL pron_rel,
    SYNSEM.LOCAL.CONT.HOOK.VARG #10,
    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #4 ], 
                            compare-rel & [ PRED "_exceed_c_rel",
                                            ARG0 #8,
                                            ARG1 #2,
                                            ARG2 #3 ],
                            measure-out-rel & [ ARG1 #2,
                                                ARG2 #4 ],
                            measure-out-rel & [ ARG1 #3,
                                                ARG2 #10 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING + ].
|#

superlat-cum-part-quantity-word := adjectival-word & lbl-ltop-lex-item-2rel & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #4, 
    SYNSEM.LOCAL.CAT.HEAD adj-quant & [KEYS.KEY adjquant-pre], 
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH - ],
   SYNSEM.LOCAL.CAT.HEAD.DEGREE superlative,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD part-prep,
                                 LOCAL.CONT.HOOK.XARG #10,
                                 LOCAL.CONT.HOOK.CMPAR-ARG #7,
                                 LOCAL.CAT.VAL.SPR <[], [LOCAL.CAT.HEAD det]>] >,
    SYNSEM.LKEYS.KEYREL pron_rel,
    SYNSEM.LOCAL.CONT.HOOK.VARG #10,
    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #4 ], 
                            compare-rel & [ PRED "_exceed_c_rel",
                                            ARG0 #8,
                                            ARG1 #4,
                                            ARG2 #10 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING + ].

superlat-cum-part-count-quantity-word := superlat-cum-part-quantity-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl ].
superlat-cum-part-mass-quantity-word := superlat-cum-part-quantity-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg ].





;;;;; Adjective Words

participial-pres-adj-word := adjective-word & const-ltow-rule &
  [ DTR presparticpl-adj-lxm ].

;plur-or-weak-adj := lexeme-to-word-rule.

;; strong:
neutsg-adj-word := adjective-word & lexeme-to-word-rule &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg,
    DTR strong-adj-lxm ].

neutsg-infl-adj-word := neutsg-adj-word & infl-ltow-rule. 

; [bmw]
neutsg-infl-adj-word-const := neutsg-adj-word & const-ltow-rule. 

; masc-or-fem-sg
masc-or-fem-sg-adj-word := adjective-word & const-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG masc-or-fem-sg,
    DTR strong-adj-lxm ].

; part of abandoned attempt to deal with "lita"
;fem-sg-adj-word := adjective-word & const-ltow-rule &
;  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG fem-sg,
;    DTR strong-adj-lxm ].

;; EAA. Alt path for mal irules.
orth-alter-masc-or-fem-sg-adj-word := adjective-word & infl-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG masc-or-fem-sg,
    DTR strong-adj-lxm ].

strongpl-adj-word := adjective-word & infl-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG pl,
    DTR strong-adj-lxm  ].

strongpl-adj-word-const := adjective-word & const-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG pl,
    DTR strong-adj-lxm  ].

; [bmw]
;strongpl-adj-word := adjective-word & infl-ltow-rule &
;  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG pl,
;    DTR strong-adj-lxm  ].

;; weak:
#|
weaksg-adj-word := adjective-word & infl-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG sg,
    SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CAT.HEAD noun,
                                         LOCAL.CAT.VAL.SPR < [] > ] >],
    DTR weak-adj-lxm  ].

weakpl-adj-word := adjective-word & infl-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG pl,
    SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CAT.HEAD noun,
                                         LOCAL.CAT.VAL.SPR cons ] >],
    DTR weak-adj-lxm  ].
|#

;; LOCAL.CAT.VAL.SPR cons &  <[LOCAL.CAT.HEAD.KEYS.KEY weaklic],...> moved from weak-adj-lxm to weak-adj-word.

weak-adj-word := adjective-word & infl-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CAT.HEAD noun,
                                         LOCAL.CAT.VAL.SPR cons &  <[LOCAL.CAT.HEAD.KEYS.KEY weaklic],...> ] >],
    DTR weak-adj-lxm  ].

#|
mal-weak-adj-word := adjective-word & infl-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CAT.HEAD noun & [DEFINITE +],
					 LOCAL.CAT.VAL.SPR null ] >],
    GENRE robust,
    DTR weak-adj-lxm  ].
|#

weak-adj-word-const := adjective-word & const-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CAT.HEAD noun,
                                         LOCAL.CAT.VAL.SPR cons ] >],
    DTR weak-adj-lxm  ].

; [bmw]
;weak-adj-word := adjective-word & infl-ltow-rule &
;  [ SYNSEM.LOCAL.CAT.HEAD adj & [ MOD < [LOCAL.CAT.HEAD noun,
;                                         LOCAL.CAT.VAL.SPR cons ] >],
;    DTR weak-adj-lxm  ].

weaksg-adj-word := weak-adj-word &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG sg ].
weakpl-adj-word := weak-adj-word &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.NG pl ].


;CMPAR-COMMENTOUT

comparative-adj-word := word & lbl-ltop-lex-item-2rel & infl-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj,
    DTR comparative-adj-lxm  ].

sup-adj-word := word & lbl-ltop-lex-item-3rel & infl-ltow-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj,
    DTR sup-adj-lxm ].

sup-adj-weak-word := sup-adj-word &
  [ DTR sup-adj-weak-lxm  ]. 

sup-adj-strong-word := sup-adj-word &
  [ DTR sup-adj-strong-lxm  ]. 


adv-from-adj-t-pos-word := adv-word & infl-ltow-rule &
  [ DTR adv-from-adj-pos-lxm ].
adv-from-adj-√∏-pos-word := adv-word & infl-ltow-rule &
  [ DTR adv-from-adj-pos-lxm ].
adv-from-adj-tt-pos-word := adv-word & infl-ltow-rule &
  [ DTR adv-from-adj-pos-lxm ].
degadv-from-adj_nde-pos-word := lbl-ltop-lex-item & const-ltow-rule &
  [ DTR degadv-from-adj_nde-pos-lxm ].
degadv-from-adj_t-pos-word := lbl-ltop-lex-item & infl-ltow-rule &
  [ DTR degadv-from-adj_t-pos-lxm ].

adv-from-adj-cmpar-word := adv-word & infl-ltow-rule &
  [ DTR adv-from-adj-cmpar-lxm ].
adv-from-adj-superlat-word := adv-word & infl-ltow-rule &
  [ DTR adv-from-adj-superlat-lxm ].

; [bmw]
adv-from-adj-√∏-pos-word-const := adv-word & const-ltow-rule &
  [ DTR adv-from-adj-pos-lxm ].

sg-weak-cardinal-word := sg-cardinal-word & 
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.VAL.SPR < [] > ] >].
sg-strong-cardinal-word := sg-cardinal-word & 
  [  SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.VAL.SPR < > ] >,
     SYNSEM.LOCAL.CAT.VAL.SPEC <[ LOCAL.CAT.HEAD.DEF -]> ].

; for "den snille gutten" - cf def-q-word, for "den bengalske tiger"

det-word := lbl-ltop-lex-item & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD det,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR <>,
                           COMPS <>,
                           SPEC < [LOCAL.CONT.HOOK.INDEX #1 & [WH -],
                                   LOCAL.CONT.RELS <! [] !>,
                                   LOCAL.CAT.HEAD [DEF +,
                                                   DEFINITE +]] >],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1, 
    SYNSEM.LOCAL.CONT.RELS <! [] !>,
    SYNSEM.LOCAL.CONT.HCONS <!!>,
    SYNSEM.LKEYS.KEYREL familiar-rel].

#|
;experiment version, to get 'den' in 'den snille gutten' to get ARG0 distinct from gutt_rel
det-word := lbl-ltop-lex-item & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD det,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR <>,
                           COMPS <>,
                           SPEC < [LOCAL.CONT.HOOK.INDEX #1 & [WH -],
                                   LOCAL.CONT.RELS <! [] !>,
                                   LOCAL.CAT.HEAD [DEF +,
                                                   DEFINITE +]] >],
;    SYNSEM.LOCAL.CONT.HOOK.XARG #1, 
    SYNSEM.LOCAL.CONT.RELS <! [] !>,
    SYNSEM.LOCAL.CONT.HCONS <!!>,
    SYNSEM.LKEYS.KEYREL familiarity-rel,
    SYNSEM.LKEYS.KEYREL.ARG1 #1 ].
|#

;LOCAL.CONT.HOOK.LTOP #2,
;    				   ,
;SYNSEM.LKEYS.KEYREL deictic-rel,
    

dem-word-super := lbl-ltop-lex-item & lex-or-phrase-synsem & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD det,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR <>,
                           COMPS <>,
                           SPEC < [SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
				   LOCAL.CONT.HOOK.INDEX #1 & [WH -],
                                   LOCAL.CONT.RELS <! [LBL #2] !>] >],
    SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
 ;   SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LKEYS.KEYREL.ARG1 #1  ].


dem-word-sup := dem-word-super &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD.DEF +] >,
    SYNSEM.LOCAL.CONT.HCONS <!!> ].

; with DEF+ but DEFINITE bool, we allow "den bengalske tiger er utd√∏dd" -
dem-word := dem-word-sup &
[ SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CAT.HEAD.DEFINITE bool]>].

; cf det-word, for "den snille gutten"
; with DEF+ but DEFINITE-, we allow "den bengalske tiger er utd√∏dd" -
def-q-word := lbl-ltop-lex-item-2rel & no-slash &
  [ SYNSEM.LKEYS.KEYREL familiar-rel,
    SYNSEM.LOCAL.CONT.RELS <!  [ARG0 #2,
                                LBL #3],
                               def-q-rel & [ARG0 #2,
                                            RSTR #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    SYNSEM.LOCAL.CAT.HEAD det & [KEYS.KEY weaklic],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR <>,
                           COMPS <>,
                           SPEC < [LOCAL.CAT.HEAD.DEF +,
                                   LOCAL.CAT.HEAD.DEFINITE -,
                                   LOCAL.DERIVED-HEAD -,
                                   LOCAL.CONT.HOOK.INDEX #1 & [WH -],
                                   LOCAL.CONT.RELS <! [] !>] >],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LKEYS.KEYREL.ARG0 #11,
    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11 ].

;; In the following section, agreement information is moved from INDEX to AGR, 
;; so as to be linguistically sound, and open for a mal rule. EAA 020411.

;; How they used to look like:
;;det-fam-masc-or-fem-sg-word := det-word &
;;  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg ].
; LH080613 now redoing that - agreement between subj and adj in copulaconstr got lost

det-fam-masc-or-fem-sg-word := det-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG masc-or-fem-sg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg].

det-fam-neutsg-word := det-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg].

det-fam-pl-word := det-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG pl,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl].

dem-masc-or-fem-sg-word := dem-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG masc-or-fem-sg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg].

dem-neutsg-word := dem-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg].

dem-pl-word := dem-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG pl,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl].

def-q-masc-or-fem-sg-word := def-q-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG masc-or-fem-sg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg].

def-q-neutsg-word := def-q-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg].

def-q-pl-word := def-q-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG pl,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl].

;; Here the change ends. EAA 020411.

; for "klokka fem /fem tretti" , "nummer fem"
; the opened list for SPR in order to get "han kom tirsdag kl to" with weekday-spec-phrase and 'head-initial' spec rule for 'kl to'


; LH030513  dug to deep somewhwre, nothing wrong with this one
klokka-word := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD nom & [KEYS.KEY name-of-card],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPEC <>,
                           COMPS <>,
			   SPR.FIRST [LOCAL.CONT.HOOK.INDEX [SORT card-unit],
				      LOCAL.CAT.HEAD card ]],
;                           SPR 1-list & <[LOCAL.CONT.HOOK.INDEX [SORT card-unit],
;					  LOCAL.CAT.HEAD card ]> ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg,
    SYNSEM.LOCAL.CONT.RELS <! [] !>,
    SYNSEM.LOCAL.CONT.HCONS <!!>,
    SYNSEM.LKEYS.KEYREL arg0-relation].


klokka-bare-word := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD noun & [KEYS.KEY crdfix],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPEC <>,
                           COMPS <>,
                           SPR list ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg,
    SYNSEM.LOCAL.CONT.RELS <! [] !>,
    SYNSEM.LOCAL.CONT.HCONS <!!>,
    SYNSEM.LKEYS.KEYREL arg0-relation].

;SYNSEM.LKEYS.KEYREL partitive-rel & [ ARG1 #1,
;                                          ARG2 #2 ],
    
; "av" in "av guttene" expecting to combine with a quantifier such as
; "hver", "ingen", "noen", "hvilke"
part-q-prep-word := lbl-ltop-lex-item-sinarg0-2rel &
  [ SYNSEM.LOCAL.CAT.HEAD part-prep,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.INDEX #1 & [PNG.NG.GEN #gen],
                                 LOCAL.CAT.HEAD q ]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD np-head & [ DEF + ],
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.INDEX #2 & [PNG.NG pl,
							      PNG.NG.GEN #gen] ]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH bool,
    SYNSEM.LOCAL.BINDING.BOUND -,
    SYNSEM.LOCAL.CONT.RELS <! [ PRED "_pron_rel",
				ARG0 #1 ], partitive-rel & [ ARG1 #1,
							     ARG2 #2 ] !>  ].



; "av" in "av guttene" expecting to combine with a cardinal or "mange/f√•".
; a problem is how to induce scoping, since these items don't introduce
; their own quantifier. 
;   drop 'pl' to get mass also LOCAL.CONT.HOOK.INDEX #9 & [PNG.NG pl ] ]>].

#|
part-card-prep-word := lbl-ltop-lex-item-sinarg0-2rel &
  [ SYNSEM.LOCAL.CONT.RELS <! [ PRED "_pron_rel",
				ARG0 #3 ], partitive-rel & [ ARG1 #3,
							     ARG2 #9 ] !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    SYNSEM.LOCAL.CAT.HEAD part-prep,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.INDEX #3,
                                 LOCAL.CAT.HEAD adjectival & [KEYS.KEY quantas]], ...>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD np-head & [ DEF + ],
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.INDEX #9 ]>].
|#

part-card-prep-word := lbl-ltop-lex-item-openarg0-2rel &
  [ SYNSEM.LOCAL.CONT.RELS <! [ LBL #lbl,
				PRED "_pron_rel",
				ARG0 #3 ], partitive-rel & [ LBL #lbl,
							     ARG1 #3,
							     ARG2 #9 ]  !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl,
    SYNSEM.LOCAL.CAT.HEAD part-prep,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.INDEX #3 & [SORT card-unit],
				 LOCAL.CARD-TO-BARE-N +,
                                 LOCAL.CAT.HEAD comm-noun & [KEYS.KEY absnoun]], ...>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD np-head & [ DEF + ],
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.LTOP #lbl,
				  LOCAL.CONT.HOOK.INDEX #9 ]>].


part-measurenp-prep-word := lbl-ltop-lex-item-sinarg0-2rel &
  [ SYNSEM.LOCAL.CONT.RELS <! [ PRED "_pron_rel",
				ARG0 #3 ], partitive-rel & [ ARG1 #3,
							     ARG2 #9 ] !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #3,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CAT.HEAD part-prep,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.INDEX #3 & [ SORT measure-unit ],
                                 LOCAL.CAT.HEAD noun ]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD noun & [ DEF + ],
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.INDEX #9 & [PNG.NG pl ] ]>].


part-adj-prep-word := lbl-ltop-lex-item-sinarg0 &
  [ SYNSEM.LOCAL.CONT.RELS <! partitive-rel & [ ARG1 #3,
                                                ARG2 #9 ] !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #3,
    SYNSEM.LOCAL.CONT.HOOK.XARG #9,
    SYNSEM.LOCAL.CAT.HEAD part-prep,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.XARG #3,
                                 LOCAL.CAT.HEAD adj ], []>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD noun & [ DEF + ],
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.INDEX #9 & [PNG.NG pl ] ]>].

part-adj-prep2-word := lbl-ltop-lex-item-sinarg0 &
  [ SYNSEM.LOCAL.CONT.RELS <! partitive-rel & [ ARG1 #3,
                                                ARG2 #9 ] !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #3,
    SYNSEM.LOCAL.CONT.HOOK.XARG #9,
    SYNSEM.LOCAL.CAT.HEAD part-prep,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.XARG #3,
                                 LOCAL.CAT.HEAD adj ], []>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD allquant,
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.INDEX #9 & [PNG.NG pl ] ]>].

; "av" in "av vinen" expecting to combine with a quantifier such as
; "mye", "lite", "intet", "noe"
part-q-mass-prep-word := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD part-prep,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.INDEX #1,
                                 LOCAL.CAT.HEAD q ]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD noun & [ DEF + ],
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.INDEX #2 & [PNG.NG sg ] ]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LKEYS.KEYREL partitive-rel & [ ARG1 #1,
                                          ARG2 #2 ]].
#|
; not clear if this is needed
part-card-mass-prep-word := lbl-ltop-lex-item-2rel &
  [ SYNSEM.LOCAL.CONT.RELS <! partitive-rel & [ ARG1 #3,
                                                ARG2 #9 ], 
                            plurindef-q-rel & [ARG0 #3,
                                             RSTR #5 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #5,
                                LARG #6 ] !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #3,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #6,
    SYNSEM.LOCAL.CAT.HEAD part-prep,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.INDEX #3,
                                 LOCAL.CAT.HEAD card ]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD noun & [ DEF + ],
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.INDEX #9 & [PNG.NG sg ] ]>].
|#

; "av" in "hav av tilskuere", or "med" in "krukke med genever", expecting to 
; combine with an NP as COMPS which is BOUNDED -
measure-out-prep-word := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.HEAD part-prep,
    SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CONT.HOOK.INDEX #1 & [SORT measure-unit ],
                                 LOCAL.CAT.HEAD noun & [ KEYS.KEY measnoun ]]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD noun & [ DEF - ],
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.INDEX #2 & [BOUNDED - ] ]>,
    SYNSEM.LKEYS.KEYREL measure-out-rel & [ ARG1 #1,
                                            ARG2 #2 ]].




; in cooperation with head-quant-comp-phrase, this word category
; applies uniquely to "alle" and "begge" preceding a definite N-bar
univquant1-part-word := lbl-ltop-lex-item-sinarg0-3rel & 1arg-1comps & 
  [ SYNSEM.LOCAL.CONT.RELS <! partitive-rel & [ ARG1 #3,
                                                ARG2 #9 ], 
                            indef-q-rel & [ARG0 #3,
                                         RSTR #5 ], 
			    arg0-relation & [PRED "_entity_rel",
					     ARG0 #3] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #5,
                                 LARG #6 ] !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #3 & [ WH - ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #6,
    SYNSEM.LOCAL.CAT.HEAD allquant,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD noun & [ DEFINITE + ],
                                  LOCAL.CONT.HOOK.INDEX #9,
                                  LOCAL.CAT.VAL.SPR <> ]>,
    SYNSEM.LOCAL.BINDING.BOUND -].

univquant1-part-sg-word := univquant1-part-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.PNG.NG sg ]>].

; masc-or-fem-sg
univquant1-part-masc-or-fem-sg-word := univquant1-part-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg ]>].

univquant1-part-neutsg-word := univquant1-part-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg ]>].

univquant1-part-pl-word := univquant1-part-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [PNG.NG pl ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.PNG.NG pl ]>].


; in cooperation with head-quant-gen-comp-phrase, and before that
; poss-general-genitive-phrase, this word category
; applies uniquely to "alle" and "begge" preceding a genitive
univquant2-part-word := lbl-ltop-lex-item-sinarg0-2rel &
  [ SYNSEM.LOCAL.CONT.RELS <! partitive-rel & [ ARG1 #3,
                                                ARG2 #9 ], 
                            indef-q-rel & [ARG0 #3,
                                           RSTR #5 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #5,
                                 LARG #6 ] !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #3,
    SYNSEM.LOCAL.CONT.HOOK.INDEX [BOUNDED +,
                                  WH - ],
    SYNSEM.LOCAL.CONT.HOOK.LTOP #6,
    SYNSEM.LOCAL.CAT.HEAD allquant,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD noun & [ DEFINITE - ],
                                  LOCAL.CAT.VAL.SPR <>,
                                  LOCAL.CONT.HOOK.INDEX #9 ]>,
    SYNSEM.LOCAL.BINDING.BOUND - ].

univquant2-part-sg-word := univquant2-part-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.PNG.NG sg ]>].

; masc-or-fem-sg
univquant2-part-masc-or-fem-sg-word := univquant2-part-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg ]>].

univquant2-part-neutsg-word := univquant2-part-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg ]>].

univquant2-part-pl-word := univquant2-part-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.PNG.NG pl ]>].

; INDEFINITE QUANTIFIERS
; Changed DEF bool to DEF -. EAA 040411.
;LH   & [KEYS.KEY qkey]
indef-card-quantifier-word-sup := lbl-ltop-lex-item & word & no-slash & 
  [ SYNSEM.LOCAL.CAT.HEAD q,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS <>,
                           SPEC < [LOCAL.CAT.HEAD nom,
                                   LOCAL.CONT.HOOK.INDEX #1,
                                   LOCAL.CONT.HOOK.LTOP #3]>],
    SYNSEM.LOCAL.CONT.HOOK comp-hook & [ INDEX #1 & [WH -] ],
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #2,
                                LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.RELS <! indef-q-rel & [ARG0 #1,
                                             RSTR #2 ] !>,
    SYNSEM.LOCAL.BINDING.BOUND - ].

indef-card-quantifier-word := indef-card-quantifier-word-sup & 
[ SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD [ DEFINITE -, DEF - ]] >].

degreespec-word := lbl-ltop-lex-item-2rel &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS <>,
                           SPEC < [LOCAL.CAT.HEAD [DEGREE degree]] >],
    SYNSEM.LOCAL.CONT.HCONS <![ HARG #2,
                                LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.RELS <! [LBL #3,
			       ARG0 #ind ], indef-q-rel & [PRED "_udef_q_rel",
							   ARG0 #ind,
							   RSTR #2] !>].

#|
; 'absolute' use, without 'than-phrase'
degreespec-word-2 := lbl-ltop-lex-item-2rel &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS <>,
                           SPEC < [LOCAL.CAT.HEAD [DEGREE degree]] >],
    SYNSEM.LOCAL.CONT.HCONS <![ HARG #2,
                                LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.RELS <! [LBL #3,
			       ARG0 #ind ], indef-q-rel & [PRED "_diff-amount_q_rel",
							   ARG0 #ind,
							   RSTR #2] !>].
|#

; non-wh-degreewords
degreepos-spec-word-sup := degreespec-word &
  [ SYNSEM.LOCAL.CAT.HEAD degspr,
    SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CAT.HEAD [DEGREE positive ]] >],
    SYNSEM.LOCAL.CONT.HOOK comp-hook & [INDEX #1 & [ WH - ]],
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #1 ], [] !>].

;[why on earth have  HEAD comparative-adv? losing 'meget gammel' - -  SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CAT.HEAD comparative-adv & [DEGREE positive ]] >]].
degreepos-spec-word := degreepos-spec-word-sup &
 [ SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CAT.HEAD adjectival & [DEGREE positive ]] >]].

degreepos-post-spec-word := degreepos-spec-word-sup.

degreecmpar-spec-word := degreespec-word &
  [ SYNSEM.LOCAL.CAT.HEAD degspr,
    SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CAT.HEAD.DEGREE comparative,
;				   LOCAL.CONT.HOOK.INDEX #1,
				   LOCAL.CMPAR-PENDING +] >],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #1 ], [] !>].

; LH060513  For 'absolute' use, without than-clause. The mrs that would be induced by degreecmpar-spec-word will have an ARG2 of 'exceed' which is not instantiated. LKB seems to accept that as long as it is of type 'u', but in principle it should not happen, and THIS TYPE is one where this could be repaired. At the moment it behaves just like degreecmpar-spec-word, as long as the system doesn't complain.
degreecmpar-spec-word-2 := degreespec-word &
  [ SYNSEM.LOCAL.CAT.HEAD degspr,
    SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CAT.HEAD.DEGREE comparative,
				   LOCAL.CMPAR-PENDING -] >],
    SYNSEM.LOCAL.CONT.HOOK comp-hook & [INDEX #1 & [ WH - ]],
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #1 ], [] !>].

degreesup-spec-word := degreespec-word &
  [ SYNSEM.LOCAL.CAT.HEAD degspr,
    SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CAT.HEAD.DEGREE superlative ] >],
    SYNSEM.LOCAL.CONT.HOOK comp-hook & [INDEX #1 & [ WH - ]],
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #1 ], [] !>].

; wh-degreewords: "hvor stor", "hvor mange"
degreewh-spec-word := degreespec-word &
  [ SYNSEM.LOCAL.CAT.HEAD degspr,
    SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CAT.HEAD [DEGREE positive ]] >],
    SYNSEM.LOCAL.CONT.HOOK comp-hook & [INDEX #1 & [ WH + ]],
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #1 ], [] !>].
#|
; wh-degreewords: "hvor stor", "hvor mange"
; comparative-adv & 
wh-degrpos-spec-word := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD degspr,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS <>,
                           SPEC < [LOCAL.CAT.HEAD [DEGREE positive]] >],
    SYNSEM.LOCAL.CONT.HOOK comp-hook & [INDEX #1 & [ WH + ]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CONT.RELS <! interrog-q-rel & [PRED "_extent-factor_q_rel",
						ARG0 #1 ] !>].
|#

wh-degreecmpar-spec-word := degreespec-word &
  [ SYNSEM.LOCAL.CAT.HEAD degspr,
    SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CAT.HEAD.DEGREE comparative ] >],
    SYNSEM.LOCAL.CONT.HOOK comp-hook & [INDEX #1 & [ WH + ]],
;    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CONT.RELS <! interrog-q-rel & [PRED "_extent-factor_q_rel",
						ARG0 #1 ], [] !>].

; for "hvor mye" in "hvor mye mer/mindre", treated as a single unit, since
; "mye" cannot alternate with "lite"
wh-sg-degreecmpar-spec-word := wh-degreecmpar-spec-word &
  [ SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CONT.HOOK.INDEX.PNG.NG sg ] >]].
; for "hvor mange" in "hvor mange flere/f√¶rre", treated as a single unit, since
; "mange" cannot alternate with "f√•"
wh-pl-degreecmpar-spec-word := wh-degreecmpar-spec-word &
  [ SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CONT.HOOK.INDEX.PNG.NG pl ] >]].

quantspec-word := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD degspr,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS <>],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CAT.VAL [ SPEC < [LOCAL.CAT.HEAD.DEGREE positive ] >],
    SYNSEM.LOCAL.CONT.HOOK comp-hook & [INDEX #1 & [ WH - ]],
    SYNSEM.LOCAL.CONT.RELS <! [ARG0 #1 ] !>].

cardspec-word := quantspec-word &
  [ SYNSEM.LOCAL.CAT.VAL [  SPEC < [LOCAL.CAT.HEAD card] >]].

indefspec-word := quantspec-word &
  [ SYNSEM.LOCAL.CAT.VAL [  SPEC < [LOCAL.CAT.HEAD q] >]].

interrog-quantifier-word := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD quant & [KEYS.KEY interr-word],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ cons,
                           SPR list,
                           COMPS <>,
                           SPEC < [LOCAL.CAT.HEAD nom,
                                   LOCAL.CONT.HOOK.INDEX #1,
                                   LOCAL.CONT.HOOK.LTOP #3,
                                   LOCAL.CAT.HEAD.DEFINITE -,
                                   LOCAL.CAT.HEAD.DEF - ]>],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [ WH + ],
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #2,
                                LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.RELS <! interrog-q-rel & [ARG0 #1,
                                                RSTR #2 ] !>].



art-cardone-word-sup := indef-card-quantifier-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD art,
    SYNSEM.LOCAL.CONT.RELS <! [PRED "_exactly_1_q_rel"] !>].


art-cardone-word := art-cardone-word-sup & indef-card-quantifier-word.


quant-indef-card-word := indef-card-quantifier-word &
  [ SYNSEM.LOCAL.CAT.HEAD quant ].

; "intet", "hvert"
quant-indef-card-neutsg-word := quant-indef-card-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg,
    SYNSEM.LOCAL.CAT.HEAD n-quant ].

; "ingenting" - should really be an 'np'-item, but provisionally:
quant-indef-card-mascsg-word := quant-indef-card-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG masc-sg,
    SYNSEM.LOCAL.CAT.HEAD n-quant ].

; "ingen", mange, flere (abs)
quant-indef-card-pl-word := quant-indef-card-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG pl,
    SYNSEM.LOCAL.CAT.HEAD n-quant,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CMPAR-PENDING - ].

quant-indef-cmpar-card-pl-word := quant-indef-card-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG pl,
    SYNSEM.LOCAL.CAT.HEAD quant,
    SYNSEM.LOCAL.CMPAR-PENDING bool ].

; "ingen", "noen", "hver"
; masc-or-fem-sg
quant-indef-card-masc-or-fem-sg-word-sup := quant-indef-card-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG masc-or-fem-sg,
    SYNSEM.LOCAL.CAT.HEAD n-quant ].

; masc-or-fem-sg
quant-indef-nonpart-masc-or-fem-sg-word := quant-indef-card-masc-or-fem-sg-word-sup &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD noun] >].

; masc-or-fem-sg
quant-indef-part-masc-or-fem-sg-word := quant-indef-card-masc-or-fem-sg-word-sup.

; "noe"
quant-indef-ncard-sg-word := quant-indef-card-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg,
    SYNSEM.LOCAL.CAT.HEAD n-quant ].

; "litt", "mye" (comparable 'mass' quantifiers) with no "sv√¶rt" or "hvor"
; "Ola drikker litt vin". Real quantification
quant-indef-adjcard2-sg-word := quant-indef-card-word &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CAT.HEAD adj-quant ].

; "litt", "mye" (comparable 'mass' quantifiers), combined with "sv√¶rt"
; or "hvor" - 'how much wine'
quant-indef-adjcard-sg-word := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD adj-quant & [KEYS.KEY adjquant-pre],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR < [] >,
                           COMPS <>,
                           SPEC < [LOCAL.CAT.HEAD np-head,
                                   LOCAL.CONT.HOOK.INDEX #1,
                                   LOCAL.CONT.HOOK.LTOP #3,
                                   LOCAL.CAT.HEAD.DEFINITE -,
                                   LOCAL.CAT.HEAD.DEF - ]>],
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #2,
                                LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.RELS <! indef-q-rel & [ARG0 #1,
                                             RSTR #2 ] !>].

;  & [KEYS.KEY adjquant-pre]
; suspect with such a wide HEAD type. Trying with the one from above
quant-indef-adjcard-sg-abs-word := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD adj-quant & [KEYS.KEY adjquant-pre],
;    SYNSEM.LOCAL.CAT.HEAD np-head,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS <>,
                           SPEC < >],
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #2 ] !>,
    SYNSEM.LOCAL.CONT.RELS <! indef-q-rel & [RSTR #2 ] !>].



; "hvilke"
interrog-quant-pl-word := interrog-quantifier-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG pl ].
; "hvilken"
; masc-or-fem-sg
interrog-quant-masc-or-fem-sg-word := interrog-quantifier-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG masc-or-fem-sg ].
; hvilket"
interrog-quant-neutsg-word := interrog-quantifier-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg ].


;; Some changes here to accomodate new type of SPEC-rules. EAA. 020411.

art-neutsg-word := art-cardone-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg].

art-mascsg-word := art-cardone-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG masc-sg ].

;; Old entry
;art-mascsg-poss-word := art-cardone-poss-word &
;  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG masc-sg,
;    SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX.PNG masc-sg]>].

art-femsg-word := art-cardone-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG fem-sg ].

; 'nummer fem' in 'mann nummer fem'
numerical-parameter-word := lbl-ltop-lex-item & word & no-slash & 
  [ SYNSEM.LOCAL.CAT.HEAD q & [KEYS.KEY qkey],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS <>,
                           SPEC < [LOCAL.CAT.HEAD card,
                                   LOCAL.CONT.HOOK.INDEX #1,
                                   LOCAL.CONT.HOOK.LTOP #3]>],
    SYNSEM.LOCAL.CONT.HOOK comp-hook & [ INDEX #1 & [WH -] ],
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #2,
                                LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.RELS <! indef-q-rel & [ARG0 #1,
                                             RSTR #2 ] !>,
    SYNSEM.LOCAL.BINDING.BOUND - ].







; "mer (enn)", "like (som)"

comparative-adv-word-sup := lbl-ltop-lex-item-3rel & word & rule &
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-reg-adv,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.INDEX #4,
                                  LOCAL.CONT.HOOK.LTOP #1,
                                  LOCAL.CONT.HOOK.XPRED #9,
                                  LOCAL.DERIVED-HEAD - ] >,
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #9,
    SYNSEM.LOCAL.CONT.RELS <! compare-rel & [ LBL #1,
                                              ARG1 #2,
                                              ARG2 #3 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #2,
                                                ARG2 #4 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #3,
                                                ARG2 #5 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING + ].

comparative-adv-word := comparative-adv-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD.DEGREE comparative ].

; open how CMPAR-PENDING should behave here
superlative-adv-word := comparative-adv-word-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH - ],
   SYNSEM.LOCAL.CAT.HEAD.DEGREE superlative ].

comparative-closecomp-adv-word := lbl-ltop-lex-item-2rel &
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-close-adv & [ DEGREE comparative ],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS < [ LOCAL.CAT.HEAD cmpar-dep-close,
                                     LOCAL.CONT.HOOK.INDEX #3 ]>,
                           SPEC < [LOCAL.CAT.HEAD.DEGREE positive,
                                   LOCAL.CONT.HOOK.INDEX #4] >],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #8 & [ WH - ],
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CONT.HOOK.XARG #4,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.CONT.RELS <! compare-rel & [ LBL #1,
                                              ARG0 #8,
                                              ARG1 #2,
                                              ARG2 #3 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #2,
                                                ARG2 #4 ] !>,
    SYNSEM.LKEYS.KEYREL.ARG0 #11,
    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11 ].

#|
comparative-closecomp-with-cmpar-word := lbl-ltop-lex-item-2rel &
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-close-adv,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS < [ LOCAL.CAT.HEAD cmpar-dep,
                                     LOCAL.CONT.HOOK.INDEX #3 ]>,
                           SPEC < [LOCAL.CAT.HEAD.DEGREE comparative,
                                   LOCAL.CONT.HOOK.CMPAR-ARG #4] >],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #8 & [ WH - ],
    SYNSEM.LOCAL.CONT.HOOK.LTOP #10,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CONT.RELS <! compare-rel & [ LBL #1,
                                              ARG0 #8,
                                              ARG1 #2,
                                              ARG2 #3 ],
                            measure-out-rel & [ LBL #10,
						ARG1 #2,
                                                ARG2 #4 ] !>].
|#

; a slightly leaner version of the above
; for "mer enn fem meter st√∏rre"
comparative-closecomp-with-cmpar-word := lbl-ltop-lex-item-2rel &
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-close-adv & [ DEGREE comparative ],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS < [ LOCAL.CAT.HEAD cmpar-dep-close,
                                     LOCAL.CONT.HOOK.INDEX #3 ]>,
                           SPEC < [LOCAL.CAT.HEAD.DEGREE comparative,
                                   LOCAL.CONT.HOOK.CMPAR-ARG #4] >],
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH - ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #8 & [ WH - ],
    SYNSEM.LOCAL.CONT.HOOK.LTOP #10,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CONT.RELS <! compare-rel & [ LBL #1,
                                              ARG1 #2,
                                              ARG2 #3 ],
                            measure-out-rel & [ LBL #10,
						ARG1 #2,
                                                ARG2 #4 ] !>,
    SYNSEM.LKEYS.KEYREL.ARG0 #11,
    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11 ].

    
cmpar-dep-close-word := word &
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-dep-close,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS < [ LOCAL.CONT.HOOK.INDEX #1 & [SORT measure-unit ],
                                     LOCAL.CAT.VAL.COMPS <> ]>,
                           SPEC <> ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.RELS <! arg0bare-relation & [ PRED "_cmparpartcl_rel"]!>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].


cmpar-dep-reg-word := word-or-lexrule &
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-dep-reg & [ MOD < [ LOCAL.CAT.HEAD adjectival,
						    LOCAL.CONT.HOOK.VARG #3,
                                                    LOCAL.CONT.HOOK.CMPAR-PRED #2,
                                                    LOCAL.CMPAR-PENDING + ] >,
                                            KEYS.KEY adhoc-abnorm ] ,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS < [ LOCAL.CONT.HOOK.INDEX #1 & [ BOUNDED bool ]]>,
                           SPEC <> ],
    SYNSEM.LOCAL.CONT.RELS <! [ PRED #2,
                                ARG0 #3,
                                ARG1 #1 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

cmpar-dep-diff-for-noun-word := word-or-lexrule &
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-dep-reg & [ MOD < [ LOCAL.CAT.HEAD nom,
						    LOCAL.CONT.HOOK.INDEX #3,
                                                    LOCAL.CMPAR-PENDING + ] >,
                                            KEYS.KEY adhoc-abnorm ] ,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS < [ LOCAL.CONT.HOOK.INDEX #1 & [ BOUNDED bool ]]>,
                           SPEC <> ],
    SYNSEM.LOCAL.CONT.RELS <! [ PRED "_exceeds-in-q-dim-in-activity_rel",
                                ARG1 #3,
                                ARG2 #1 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].
    
cmpar-dep-equal-for-noun-word := word-or-lexrule &
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-dep-reg & [ MOD < [ LOCAL.CAT.HEAD nom,
						    LOCAL.CONT.HOOK.INDEX #3,
                                                    LOCAL.CMPAR-PENDING + ] >,
                                            KEYS.KEY adhoc-abnorm ] ,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           COMPS < [ LOCAL.CONT.HOOK.INDEX #1 & [ BOUNDED bool ]]>,
                           SPEC <> ],
    SYNSEM.LOCAL.CONT.RELS <! [ PRED "_equals-in-q-dim-in-activity_rel",
                                ARG1 #3,
                                ARG2 #1 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].
    

comparative-adv-vp-mod-word-sup := lbl-ltop-lex-item-3rel & word & rule &
  [ SYNSEM.LOCAL.CAT.HEAD adv,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD verb,
                                  LOCAL.CONT.HOOK.INDEX #4,
                                  LOCAL.CONT.HOOK.LTOP #1,
                                  LOCAL.CONT.HOOK.XPRED #9,
                                  LOCAL.DERIVED-HEAD - ] >,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1,
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #9,
    SYNSEM.LOCAL.CONT.RELS <! compare-rel & [ LBL #1,
                                              ARG1 #2,
                                              ARG2 #3 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #2,
                                                ARG2 #4 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #3,
                                                ARG2 #5 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING + ].

comparative-adv-vp-mod-word := comparative-adv-vp-mod-word-sup &
  [ SYNSEM.LOCAL.CAT.HEAD.DEGREE comparative ].

; open how CMPAR-PENDING should behave here
superlative-adv-vp-mod-word := comparative-adv-vp-mod-word-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH - ],
   SYNSEM.LOCAL.CAT.HEAD.DEGREE superlative ].



; to allow "hele Ola" and "den snille Ola", use 'DEFINITE bool'
proper-name-word := lbl-ltop-lex-item-2rel & word & rule & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD #5 & prop-noun & [ DEF +,
                                             DEFINITE bool,
                                             BARE -,
					     EXPLETIVE -,
                                             KEYS.KEY propnoun ],
    SYNSEM.LOCAL.XCAT.HEAD #5,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [ WH -,
                                             PNG.PERS thirdpers,
                                             SORT full-thing ],
    SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    SYNSEM.LOCAL.CAT.VAL.SPEC list,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.AGR.PNG.PERS thirdpers,
    SYNSEM.LOCAL.BINDING.BOUND -,
;    SYNSEM.LOCAL.INHER-WH -,
    SYNSEM.BIND unbnd-min,
    SYNSEM.LOCAL.CONT.RELS <!  named-relation & [ARG0 #2,
                                            LBL #3],
                               def-q-rel & [ARG0 #2,
                                          RSTR #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    SYNSEM.LKEYS.KEYREL.ARG0 #11,
    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11 ].

proprium-noun-lxm := lbl-ltop-lex-item-2rel & word & rule & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD #5 & prop-noun & [ DEF +,
                                             DEFINITE bool,
                                             BARE - ],
    SYNSEM.LOCAL.XCAT.HEAD #5,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [ WH -,
                                             PNG.PERS thirdpers,
                                             SORT full-thing ],
    SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    SYNSEM.LOCAL.CAT.VAL.SPEC list,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.AGR.PNG.PERS thirdpers,
    SYNSEM.LOCAL.BINDING.BOUND -,
    SYNSEM.BIND unbnd-min,
    SYNSEM.LOCAL.CONT.RELS <!  named-relation & [ARG0 #2,
                                            LBL #3],
                               def-q-rel & [ARG0 #2,
                                          RSTR #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    SYNSEM.LKEYS.KEYREL.ARG0 #11,
    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11 ].

mascsg-proper-name-word := proper-name-word &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-sg ].
femsg-proper-name-word := proper-name-word &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem-sg ].
neutsg-proper-name-word := proper-name-word &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg ].
; masc-or-fem-sg
masc-or-fem-sg-proper-name-word := proper-name-word &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg ].
commpl-proper-name-word := proper-name-word &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-pl ].
neutpl-proper-name-word := proper-name-word &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutpl ].

mascsg-anim-proper-name-word := mascsg-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propanim ].
mascsg-inan-proper-name-word := mascsg-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propinan ].
femsg-anim-proper-name-word := femsg-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propanim ].
femsg-inan-proper-name-word := femsg-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propinan ].
neutsg-anim-proper-name-word := neutsg-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propanim ].
neutsg-inan-proper-name-word := neutsg-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propinan ].
; masc-or-fem-sg
masc-or-fem-sg-anim-proper-name-word := masc-or-fem-sg-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propanim ].
; masc-or-fem-sg
masc-or-fem-sg-inan-proper-name-word := masc-or-fem-sg-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propinan ].
commpl-anim-proper-name-word := commpl-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propanim ].
commpl-inan-proper-name-word := commpl-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propinan ].
neutpl-anim-proper-name-word := neutpl-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propanim ].
neutpl-inan-proper-name-word := neutpl-proper-name-word &
[ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY  propinan ].


;;;;;; THE PRONOMINAL SYSTEM



bindable-word := word &
  [ SYNSEM.LOCAL.BINDING binding ].

; "som" as in "gutten som smiler": "som" is here subject, combining by head-relative-subject-phrase. which in turn adjoins to N by relative-subj-mod-phrase. This "som" can not invert - must be marked for that
subj-relpron := lbl-ltop-lex-item & rule & bindable-word & no-slash & 
  [ SYNSEM.LOCAL.CAT.HEAD comp & [ ACCUSATIVE -,
                                       SELECTED -],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC <>,
                           COMPS <> ],
    SYNSEM.LOCAL.SUBJ-ONLY +,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    RULE card-ok ].

som_subj-relpron := subj-relpron & 
  [ SYNSEM.LOCAL.CAT.HEAD rel-pron,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [ WH - ],
    SYNSEM.LOCAL.CONT.RELS <!  rel_pron_rel !> ].    
hvilket_subj-relpron := subj-relpron & 
  [ SYNSEM.LOCAL.CAT.HEAD comp,
    SYNSEM.LOCAL.CONT.HOOK.INDEX event-verb & [ WH - ],
    SYNSEM.LOCAL.CONT.RELS <!  vp-rel_pron_rel !> ].



som-resumpt-word := lbl-ltop-lex-item & rule & bindable-word & 
  [ SYNSEM.LOCAL.CAT.HEAD rel-pron & [ ACCUSATIVE -,
                                       SELECTED - ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [ WH + ],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ < >,
                           SPR < >,
                           SPEC < >,
                           COMPS < >],
    SYNSEM.LOCAL.SUBJ-ONLY +,
    SYNSEM.LOCAL.CONT.RELS <! res-pron-rel  !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
   ; SYNSEM.NON-LOCAL.SLASH 1-dlist & [ LIST < [ SYNSEM.LOCAL.CONT.HOOK.INDEX #index ] > ], 
    RESUMPTIVE +,
    RULE card-ok ].


interrog-pron-word := lbl-ltop-lex-item-2rel & rule & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD pers-pron & [KEYS.KEY interr-word],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [ WH +,
                                             SORT referential-thing],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC <>,
                           COMPS <> ],
    SYNSEM.LOCAL.CONT.RELS <!  pers-pron-rel & [ARG0 #2,
                                                LBL #3],
                               interrog-q-rel & [ARG0 #2,
                                                   RSTR #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    SYNSEM.LKEYS.KEYREL 3rd-wh-pers-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.PERS thirdpers,
    RULE card-ok,
    SYNSEM.LKEYS.KEYREL.ARG0 #11,
    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11 ].

pers-pron-word := lbl-ltop-lex-item-2rel & rule & bindable-word & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD pers-pron & [DEF +,
                                       KEYS.KEY persprn],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [ WH -,
                                             SORT referential-thing ],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
;                           SPEC <>,
                           COMPS <> ],
    SYNSEM.LOCAL.BINDING [ BOUND -,
                           REFL-I -,
                           REFL-II - ],
 ;   SYNSEM.LOCAL.BND-MOUNTABLE < >,
    SYNSEM.LOCAL.CONT.RELS <!  pers-pron-rel & [ARG0 #2,
                                                LBL #3],
                               contextual-q-rel & [ARG0 #2,
                                                   RSTR #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    RULE card-ok,
    SYNSEM.LKEYS.KEYREL.ARG0 #11,
    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11,
    SYNSEM.NON-LOCAL.SLASH 0-dlist ].

; imposed rather in lexicon - - too many subtypes
;pers-pron-str-word := pers-pron-word-sup &
;  [ SYNSEM.LOCAL.CTXT.DISC-BOUND + ].
;pers-pron-weak-word := pers-pron-word-sup &
;  [ SYNSEM.LOCAL.CTXT.DISC-BOUND - ].


#|
seg-word := lbl-ltop-lex-item-3rel & rule & bindable-word & no-slash & 
  [ SYNSEM.LOCAL.CAT.HEAD pers-pron & [DEF +,
                                       KEYS.KEY persprn],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [ WH -,
                                             SORT referential-thing ],
    SYNSEM.LOCAL.CONT.HOOK.VARG #index,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC <>,
                           COMPS <> ],
    SYNSEM.LOCAL.CONT.RELS <!  refl-pron-rel & [ARG0 #2,
                                                LBL #3],
                               reflexive-q-rel & [ARG0 #2,
                                                   RSTR #4],
                               arg12-relation & [LBL #3,
						 PRED "coreferential_rel",
                                                 ARG1 #2 & [PNG.PERS #p],
                                                 ARG2 #index & [PNG.PERS #p]] !>,
    SYNSEM.LOCAL.BND-MOUNTABLE < bindee & [ ANAPH-INDX #index ] >,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    SYNSEM.LOCAL.CTXT pron-discbnd,
    RULE card-ok ].
|#
;,
;                                             SORT referential-thing
;   not clear why so loose constraint - allows 'han anser seg snilt'                                               ARG1 #2 & [PNG.PERS #p],
;                                                 ARG2 #index & [PNG.PERS #p]] !>
seg-word := lbl-ltop-lex-item-3rel & rule & bindable-word & no-slash & 
  [ SYNSEM.LOCAL.CAT.HEAD pers-pron & [DEF +,
                                       KEYS.KEY persprn],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [ WH - ],
    SYNSEM.LOCAL.CONT.HOOK.VARG #index,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC <>,
                           COMPS <> ],
    SYNSEM.LOCAL.CONT.RELS <!  refl-pron-rel & [ARG0 #2,
                                                LBL #3],
                               reflexive-q-rel & [ARG0 #2,
                                                   RSTR #4],
                               arg12-relation & [LBL #3,
						 PRED "coreferential_rel",
                                                 ARG1 #2 & [PNG #p],
                                                 ARG2 #index & [PNG #p]] !>,
    SYNSEM.LOCAL.BND-RESP < bindee & [ ANAPH-INDX #index ] >,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    SYNSEM.LOCAL.CTXT pron-discbnd,
    RULE card-ok ].



nonrefl-pron-word := bindable-word &
  [ SYNSEM.LOCAL.BINDING [ BOUND bool,
                           REFL-I -,
                           REFL-II - ] ].

#|
seg-pron-word := bindable-word & no-slash & 
  [ SYNSEM.LOCAL.BINDING #1 & [ BOUND +,
                                REFL-I +,
                                REFL-II - ],
    SYNSEM.LOCAL.CONT.HOOK [VARG #index],
    SYNSEM.LOCAL.BND-MOUNTABLE < bindee & [ ANAPH-TYPE #1,
                                            ANAPH-INDX #index ] > ].
|#

seg-pron-word := bindable-word & no-slash & 
  [ SYNSEM.LOCAL.BINDING #1 & [ BOUND +,
                                REFL-I + ],
    SYNSEM.LOCAL.CONT.HOOK [VARG #index],
    SYNSEM.LOCAL.BND-RESP < bindee & [ ANAPH-TYPE #1,
                                       ANAPH-INDX #index ] > ].


nom-pers-pron := pers-pron-word &
  [ SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE - ].
acc-pers-pron := pers-pron-word &
  [ SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE + ].

sg-pers-pron := pers-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg,
    SYNSEM.LOCAL.AGR.PNG.NG sg ].
plur-pers-pron := pers-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl,
    SYNSEM.LOCAL.AGR.PNG.NG pl ].

acc-seg-pron := seg-word &
  [ SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE + ].

sg-seg-pron := seg-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg,
    SYNSEM.LOCAL.AGR.PNG.NG sg ].
plur-seg-pron := seg-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl,
    SYNSEM.LOCAL.AGR.PNG.NG pl ].

1st-pers-pron-word := pers-pron-word &
  [SYNSEM.LKEYS.KEYREL 1st-pers-pron-rel,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS firstpers,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem, ; too strong, really
   SYNSEM.LOCAL.AGR.PNG.PERS firstpers].
2nd-pers-pron-word := pers-pron-word &
  [SYNSEM.LKEYS.KEYREL 2nd-pers-pron-rel,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS secpers,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem, ; too strong, really
   SYNSEM.LOCAL.AGR.PNG.PERS secpers ].
3rd-pers-pron-word := pers-pron-word &
  [SYNSEM.LKEYS.KEYREL 3rd-pers-pron-rel,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS thirdpers,
   SYNSEM.LOCAL.AGR.PNG.PERS thirdpers ].

1st-seg-pron-word := seg-word &
  [SYNSEM.LKEYS.KEYREL 1st-refl-pron-rel,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS firstpers,
   SYNSEM.LOCAL.AGR.PNG.PERS firstpers].
2nd-seg-pron-word := seg-word &
  [SYNSEM.LKEYS.KEYREL 2nd-refl-pron-rel,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS secpers,
   SYNSEM.LOCAL.AGR.PNG.PERS secpers ].
3rd-seg-pron-word := seg-word &
  [SYNSEM.LKEYS.KEYREL 3rd-refl-pron-rel,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS thirdpers,
   SYNSEM.LOCAL.AGR.PNG.PERS thirdpers ].

; Commented out the line ;SYNSEM.LKEYS.KEYREL.PRED "_pron_rel", in the following 
; types, to avoid "en","man","den","denne" and "han" be represented as the same. EAA 01.04.11.
3rd-masc-pron := 3rd-pers-pron-word &
  [ ;SYNSEM.LKEYS.KEYREL.PRED "_pron_rel",
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc,
   SYNSEM.LOCAL.AGR.PNG.NG masc ].
3rd-fem-pron := 3rd-pers-pron-word &
  [;SYNSEM.LKEYS.KEYREL.PRED "_pron_rel",
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem,
   SYNSEM.LOCAL.AGR.PNG.NG fem ].
3rd-masc-or-fem-pron := 3rd-pers-pron-word &
  [ ;SYNSEM.LKEYS.KEYREL.PRED "_pron_rel",
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem,
   SYNSEM.LOCAL.AGR.PNG.NG masc-or-fem ].

3rd-neut-pron := 3rd-pers-pron-word &
  [;SYNSEM.LKEYS.KEYREL.PRED "_pron_rel",
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut,
   SYNSEM.LOCAL.AGR.PNG.NG neut ].

;  &
;  [SYNSEM.LKEYS.KEYREL 3rd-pl-pers-pron-rel ]
3rd-plural-pron := 3rd-pers-pron-word.

; masc-or-fem-sg
3rd-masc-or-fem-sg-pron := 3rd-pers-pron-word.
3rd-neutsg-pron := 3rd-pers-pron-word.

; deleting 'nonrefl-pron-word &' from all non-3rd sg pronouns, so as to avoid reduplication of "meg", "deg" etc
1st-sg-nom-pers-pron := 1st-pers-pron-word & nom-pers-pron & sg-pers-pron & nonrefl-pron-word &
  [SYNSEM.LKEYS.KEYREL 1st-sg-pers-pron-rel ].
#|
1st-sg-acc-pers-pron := 1st-pers-pron-word & acc-pers-pron & sg-pers-pron & nonrefl-pron-word &
  [SYNSEM.LKEYS.KEYREL 1st-sg-pers-pron-rel ].
|#
1st-sg-acc-pers-pron := 1st-pers-pron-word & acc-pers-pron & sg-pers-pron &
  [SYNSEM.LKEYS.KEYREL 1st-sg-pers-pron-rel ].
1st-pl-nom-pers-pron := 1st-pers-pron-word & nom-pers-pron & plur-pers-pron & nonrefl-pron-word &
  [SYNSEM.LKEYS.KEYREL 1st-pl-pers-pron-rel ].
1st-pl-acc-pers-pron := 1st-pers-pron-word & acc-pers-pron & plur-pers-pron &
  [SYNSEM.LKEYS.KEYREL 1st-pl-pers-pron-rel ].
2nd-sg-nom-pers-pron := 2nd-pers-pron-word & nom-pers-pron & sg-pers-pron & nonrefl-pron-word &
  [SYNSEM.LKEYS.KEYREL 2nd-sg-pers-pron-rel ].
2nd-sg-acc-pers-pron := 2nd-pers-pron-word & acc-pers-pron & sg-pers-pron &
  [SYNSEM.LKEYS.KEYREL 2nd-sg-pers-pron-rel ].
2nd-pl-pers-pron := 2nd-pers-pron-word & plur-pers-pron &
  [SYNSEM.LKEYS.KEYREL 2nd-pl-pers-pron-rel ].

3rd-sg-masc-nom-pers-pron := nom-pers-pron & sg-pers-pron & 3rd-masc-pron & nonrefl-pron-word.
3rd-sg-fem-nom-pers-pron := nom-pers-pron & sg-pers-pron & 3rd-fem-pron & nonrefl-pron-word.
; masc-or-fem-sg
; strange item, so replace by the one elow
;3rd-sg-neut-masc-or-fem-sg-pers-pron := sg-pers-pron & 3rd-neut-pron & 3rd-masc-or-fem-sg-pron & nonrefl-pron-word.
3rd-sg-neut-masc-or-fem-sg-pers-pron := sg-pers-pron & 3rd-masc-or-fem-pron & 3rd-masc-or-fem-sg-pron & nonrefl-pron-word.
3rd-sg-neut-neutsg-pers-pron := sg-pers-pron & 3rd-neut-pron & 3rd-neutsg-pron & nonrefl-pron-word.

3rd-sg-masc-acc-pers-pron := acc-pers-pron & sg-pers-pron & 3rd-masc-pron & nonrefl-pron-word.
3rd-sg-fem-acc-pers-pron := acc-pers-pron & sg-pers-pron & 3rd-fem-pron & nonrefl-pron-word.

3rd-pl-pers-pron := plur-pers-pron & 3rd-plural-pron & nonrefl-pron-word.
3rd-pl-nom-pers-pron := nom-pers-pron & 3rd-pl-pers-pron.
3rd-pl-acc-pers-pron := acc-pers-pron & 3rd-pl-pers-pron.

1st-sg-seg-pron := 1st-seg-pron-word & acc-seg-pron & sg-seg-pron  & seg-pron-word &
  [SYNSEM.LKEYS.KEYREL 1st-sg-refl-pron-rel ].
1st-pl-seg-pron := 1st-seg-pron-word & acc-seg-pron & plur-seg-pron & seg-pron-word  &
  [SYNSEM.LKEYS.KEYREL 1st-pl-refl-pron-rel ].
2nd-sg-seg-pron := 2nd-seg-pron-word & acc-seg-pron & sg-seg-pron & seg-pron-word &
  [SYNSEM.LKEYS.KEYREL 2nd-sg-refl-pron-rel ].
2nd-pl-seg-pron := 2nd-seg-pron-word & plur-seg-pron & seg-pron-word &
  [SYNSEM.LKEYS.KEYREL 2nd-pl-refl-pron-rel ].
3rd-seg-pron := acc-seg-pron & seg-pron-word &
  [ SYNSEM.LKEYS.KEYREL 3rd-refl-pron-rel,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS thirdpers,
    SYNSEM.LOCAL.AGR.PNG.PERS thirdpers ].

reciproc-pron := acc-seg-pron & plur-seg-pron & seg-pron-word  & 
  [SYNSEM.LKEYS.KEYREL refl-pron-rel ].

poss-reflpron-word := lbl-ltop-lex-item-3rel & bindable-word & rule & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD posspron & [KEYS.KEY possprn],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC < [LOCAL.CAT.HEAD.DEFINITE -,
                                   LOCAL.CAT.HEAD.DEF + ] >,
                           COMPS <> ],
    SYNSEM.LOCAL.CONT.RELS <!  refl-pron-rel & [ARG0 #1,
                                                LBL #3],
                               contextual-q-rel & [ARG0 #1,
                                                   RSTR #4],
                               arg12-relation & [PRED "coreferential_rel",
                                                 ARG1 #1 & [PNG.PERS #p],
                                                 ARG2 #index & [PNG.PERS #p]] !>,
    SYNSEM.LOCAL.BND-MOUNTABLE < bindee & [ ANAPH-INDX #index ] >,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    RULE card-ok].

poss-pron-word-sup := lbl-ltop-lex-item-2rel & bindable-word & rule & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD posspron & [KEYS.KEY possprn],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC < [LOCAL.CAT.HEAD.DEFINITE -,
                                   LOCAL.CAT.HEAD.DEF + ] >,
                           COMPS <> ],
    SYNSEM.LOCAL.CONT.RELS <!  [ARG0 #1,
                                LBL #3],
                               contextual-q-rel & [ARG0 #1,
                                                   RSTR #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    RULE card-ok,
    SYNSEM.LKEYS.KEYREL.ARG0 #11,
    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11 ].

poss-pron-word := poss-pron-word-sup &
 [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ].

poss-wh-pron-word := poss-pron-word-sup &
 [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH + ].


poss-particle-word := word-or-lexrule & rule & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD possparticle & [KEYS.KEY posspcl],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC < [LOCAL.CAT.HEAD.DEFINITE -,
                                   LOCAL.CAT.HEAD.DEF + ] >,
                           COMPS <[ LOCAL.CONT.HOOK.INDEX #1,
				    LOCAL.CONT.HOOK.LTOP #lbl]> ],
    SYNSEM.LOCAL.CONT.RELS <! arg0bare-relation & [ PRED "_posspartcl_rel",
						    LBL #lbl ] !>,
    SYNSEM.LOCAL.CONT.HCONS <!  !>,
    RULE card-ok].

; masc-or-fem-sg - ?
poss-mascsg-particle-word := poss-particle-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG masc-sg ].

poss-femsg-particle-word := poss-particle-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG fem-sg ].

poss-neutsg-particle-word := poss-particle-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg ].

poss-plur-particle-word := poss-particle-word &
  [ SYNSEM.LOCAL.AGR.PNG.NG pl ].



poss-reflpron-post-word := lbl-ltop-lex-item-4rel & bindable-word & rule & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD postposspron & [MOD < [LOCAL.CAT.HEAD.DEFINITE +,
                                                 LOCAL.CONT.HOOK.INDEX #5 ] >,
                                          KEYS.KEY possprn],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC < >,
                           COMPS <> ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [WH -],
    SYNSEM.LOCAL.CONT.RELS <!  refl-pron-rel & [ARG0 #1,
                                                LBL #3],
                               contextual-q-rel & [ARG0 #1,
                                                   RSTR #4],
                            poss-rel & [ LBL #3,
					 ARG1 #1,
                                         ARG2 #5 ],
                               arg12-relation & [LBL #3,
						 PRED "coreferential_rel",
                                                 ARG1 #1 & [PNG.PERS #p],
                                                 ARG2 #index & [PNG.PERS #p]] !>,
    SYNSEM.LOCAL.BND-MOUNTABLE < bindee & [ ANAPH-INDX #index ] >,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3]  !>,
    RULE card-ok].


poss-pron-post-word := lbl-ltop-lex-item-3rel & bindable-word & rule & 
  [ SYNSEM.LOCAL.CAT.HEAD postposspron & [MOD < [LOCAL.CAT.HEAD.DEFINITE +,
						 LOCAL.CONT.HOOK.INDEX #5 ] >],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC < >,
                           COMPS <> ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [WH -],
    SYNSEM.LOCAL.CONT.RELS <!  [ARG0 #1,
                                LBL #3],
                               contextual-q-rel & [ARG0 #1,
                                                   RSTR #4],
                            poss-rel & [ LBL #3,
					 ARG1 #1,
                                         ARG2 #5 ] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3]  !>,
    RULE card-ok].

poss-word := word.
sg-poss := poss-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg ].
plur-poss := poss-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl ].

1st-poss-word := poss-word &
  [SYNSEM.LKEYS.KEYREL 1st-pers-pron-rel,
   SYNSEM.LOCAL.AGR.PNG.PERS firstpers ].
1st-sg-poss-word := 1st-poss-word &
  [SYNSEM.LKEYS.KEYREL 1st-sg-pers-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.NG sg ].
1st-pl-poss-word := 1st-poss-word &
  [SYNSEM.LKEYS.KEYREL 1st-pl-pers-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.NG pl ].
2nd-poss-word := poss-word &
  [SYNSEM.LKEYS.KEYREL 2nd-pers-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.PERS secpers ].
2nd-sg-poss-word := 2nd-poss-word &
  [SYNSEM.LKEYS.KEYREL 2nd-sg-pers-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.NG sg ].
2nd-pl-poss-word := 2nd-poss-word &
  [SYNSEM.LKEYS.KEYREL 2nd-pl-pers-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.NG pl ].

3rd-poss-word := poss-word &
  [SYNSEM.LKEYS.KEYREL 3rd-pers-pron-rel ].

3rd-quest-poss-word := poss-word & poss-wh-pron-word &
  [SYNSEM.LKEYS.KEYREL 3rd-wh-pers-pron-rel ].

; pied piping 'hvis' in relatives. To work, it must induce a feature on the hosting NP which releases WH-COMPLETE + when used as subject (head-relative-subject-phrase), and is recognized as a relative filler when not a subject (rel-head-filler-phrase)
3rd-rel-poss-word := poss-word & poss-pron-word &
  [SYNSEM.LKEYS.KEYREL 3rd-wh-pers-pron-rel ].

3rd-sg-masc-poss := 3rd-poss-word &
  [SYNSEM.LKEYS.KEYREL.PRED "_3sg_pron_masc_anim_rel",
    SYNSEM.LOCAL.AGR.PNG 3msg ].
3rd-sg-fem-poss := 3rd-poss-word &
  [SYNSEM.LKEYS.KEYREL.PRED "_3sg_pron_fem_anim_rel",
    SYNSEM.LOCAL.AGR.PNG 3fsg ].
3rd-sg-neut-msc-poss := 3rd-poss-word &
  [SYNSEM.LKEYS.KEYREL.PRED "_3sg_pron_neutanim_msc_rel",
    SYNSEM.LOCAL.AGR.PNG 3nsg ].
3rd-sg-neut-nt-poss := 3rd-poss-word &
  [SYNSEM.LKEYS.KEYREL.PRED "_3sg_pron_neutanim_nt_rel",
    SYNSEM.LOCAL.AGR.PNG 3nsg ].
3rd-plural-poss := 3rd-poss-word &
  [SYNSEM.LKEYS.KEYREL 3rd-pl-pers-pron-rel,
    SYNSEM.LOCAL.AGR.PNG 3pl ].

; masc-or-fem-sg "dens"?
3rd-masc-or-fem-sg-poss := 3rd-poss-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg ].
3rd-neutsg-poss := 3rd-poss-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutsg ].

;; for reflexive possessives
1st-reflposs-word := poss-word &
  [SYNSEM.LKEYS.KEYREL 1st-refl-pron-rel,
   SYNSEM.LOCAL.AGR.PNG.PERS firstpers ].
1st-sg-reflposs-word := 1st-reflposs-word &
  [SYNSEM.LKEYS.KEYREL 1st-sg-refl-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.NG sg ].
1st-pl-reflposs-word := 1st-reflposs-word &
  [SYNSEM.LKEYS.KEYREL 1st-pl-refl-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.NG pl ].
2nd-reflposs-word := poss-word &
  [SYNSEM.LKEYS.KEYREL 2nd-refl-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.PERS secpers ].
2nd-sg-reflposs-word := 2nd-reflposs-word &
  [SYNSEM.LKEYS.KEYREL 2nd-sg-refl-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.NG sg ].
2nd-pl-reflposs-word := 2nd-reflposs-word &
  [SYNSEM.LKEYS.KEYREL 2nd-pl-refl-pron-rel,
    SYNSEM.LOCAL.AGR.PNG.NG pl ].

3rd-reflposs-word := poss-word &
  [SYNSEM.LKEYS.KEYREL 3rd-refl-pron-rel ].

; PRONOMINAL possessives, neutral as to pre- or post-nominal
; min
; masc-or-fem-sg? or masc-sg
1st-mascsg-poss-pron := 1st-sg-poss-word & sg-poss & nonrefl-pron-word & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc ].
; mi
1st-sg-fem-poss-pron := 1st-sg-poss-word & sg-poss & nonrefl-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem ].
; mitt
1st-sg-neut-poss-pron := 1st-sg-poss-word & sg-poss & nonrefl-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
; mine
1st-sg-plur-poss-pron := 1st-sg-poss-word & plur-poss & nonrefl-pron-word.

; v√•r
; masc-or-fem-sg
1st-pl-masc-or-fem-sg-poss-pron := 1st-pl-poss-word & sg-poss & nonrefl-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg ].
; v√•rt
1st-pl-neut-poss-pron := 1st-pl-poss-word & sg-poss & nonrefl-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
; v√•re
1st-pl-plur-poss-pron := 1st-pl-poss-word & plur-poss & nonrefl-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl ].

; din
; masc-or-fem-sg ? rather masc-sg
2nd-mascsg-poss-pron := 2nd-sg-poss-word & sg-poss & nonrefl-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc ].
; di
2nd-sg-fem-poss-pron := 2nd-sg-poss-word & sg-poss & nonrefl-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem ].
; ditt
2nd-sg-neut-poss-pron := 2nd-sg-poss-word & sg-poss & nonrefl-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
; dine
2nd-sg-plur-poss-pron := 2nd-sg-poss-word & plur-poss & nonrefl-pron-word.

; deres (combines with all genders, and both numbers, and expresses all gend)
2nd-pl-poss-pron := 2nd-pl-poss-word & nonrefl-pron-word.


; hans (combines with all genders, and both numbers)
3rd-sg-masc-poss-pron := 3rd-sg-masc-poss & nonrefl-pron-word.
; hennes (combines with all genders, and both numbers)
3rd-sg-fem-poss-pron := 3rd-sg-fem-poss & nonrefl-pron-word.
; dens (combines with all genders, and both numbers)
3rd-sg-neut-msc-poss-pron := 3rd-sg-neut-msc-poss & nonrefl-pron-word.
; dets (combines with all genders, and both numbers)
3rd-sg-neut-nt-poss-pron := 3rd-sg-neut-nt-poss & nonrefl-pron-word.
; deres (combines with all genders, and both numbers)
3rd-plural-poss-pron := 3rd-plural-poss & nonrefl-pron-word.

;Pre-possessors

; min
; masc-or-fem-sg? see above - masc-sg 
1st-mascsg-poss-pron-pre := 1st-mascsg-poss-pron & poss-pron-word.
; mi
1st-sg-fem-poss-pron-pre := 1st-sg-fem-poss-pron & poss-pron-word.
; mitt
1st-sg-neut-poss-pron-pre := 1st-sg-neut-poss-pron & poss-pron-word.
; mine
1st-sg-plur-poss-pron-pre := 1st-sg-plur-poss-pron & poss-pron-word.
; v√•r
; masc-or-fem-sg
1st-pl-masc-or-fem-sg-poss-pron-pre := 1st-pl-masc-or-fem-sg-poss-pron & poss-pron-word.
; v√•rt
1st-pl-neut-poss-pron-pre := 1st-pl-neut-poss-pron & poss-pron-word.
; v√•re
1st-pl-plur-poss-pron-pre := 1st-pl-plur-poss-pron & poss-pron-word.

; din
; masc-or-fem-sg? masc-sg
2nd-mascsg-poss-pron-pre := 2nd-mascsg-poss-pron & poss-pron-word.
; di
2nd-sg-fem-poss-pron-pre := 2nd-sg-fem-poss-pron & poss-pron-word.
; ditt
2nd-sg-neut-poss-pron-pre := 2nd-sg-neut-poss-pron & poss-pron-word.
; dine
2nd-sg-plur-poss-pron-pre := 2nd-sg-plur-poss-pron & poss-pron-word.
; deres (combines with all genders, and both numbers, and expresses all gend)
2nd-pl-poss-pron-pre := 2nd-pl-poss-pron & poss-pron-word.

; hans (combines with all genders, and both numbers)
3rd-sg-masc-poss-pron-pre := 3rd-sg-masc-poss-pron & poss-pron-word.
; hennes (combines with all genders, and both numbers)
3rd-sg-fem-poss-pron-pre := 3rd-sg-fem-poss-pron & poss-pron-word.
; dens (combines with all genders, and both numbers)
3rd-sg-neut-msc-poss-pron-pre := 3rd-sg-neut-msc-poss-pron & poss-pron-word.
; dets (combines with all genders, and both numbers)
3rd-sg-neut-nt-poss-pron-pre := 3rd-sg-neut-nt-poss-pron & poss-pron-word.
; deres (combines with all genders, and both numbers)
3rd-plural-poss-pron-pre := 3rd-plural-poss-pron & poss-pron-word.


;Post-possessors

; min
; masc-or-fem-sg - no
1st-mascsg-poss-pron-post := 1st-mascsg-poss-pron & poss-pron-post-word.
; mi
1st-sg-fem-poss-pron-post := 1st-sg-fem-poss-pron & poss-pron-post-word.
; mitt
1st-sg-neut-poss-pron-post := 1st-sg-neut-poss-pron & poss-pron-post-word.
; mine
1st-sg-plur-poss-pron-post := 1st-sg-plur-poss-pron & poss-pron-post-word.
; v√•r
; masc-or-fem-sg - see above
1st-pl-masc-or-fem-sg-poss-pron-post := 1st-pl-masc-or-fem-sg-poss-pron & poss-pron-post-word.
; v√•rt
1st-pl-neut-poss-pron-post := 1st-pl-neut-poss-pron & poss-pron-post-word.
; v√•re
1st-pl-plur-poss-pron-post := 1st-pl-plur-poss-pron & poss-pron-post-word.

; din
; masc-or-fem-sg? no, only masc-sg
2nd-mascsg-poss-pron-post := 2nd-mascsg-poss-pron & poss-pron-post-word.
; di
2nd-sg-fem-poss-pron-post := 2nd-sg-fem-poss-pron & poss-pron-post-word.
; ditt
2nd-sg-neut-poss-pron-post := 2nd-sg-neut-poss-pron & poss-pron-post-word.
; dine
2nd-sg-plur-poss-pron-post := 2nd-sg-plur-poss-pron & poss-pron-post-word.
; deres (combines with all genders, and both numbers, and expresses all gend)
2nd-pl-poss-pron-post := 2nd-pl-poss-pron & poss-pron-post-word.

; hans (combines with all genders, and both numbers)
3rd-sg-masc-poss-pron-post := 3rd-sg-masc-poss-pron & poss-pron-post-word.
; hennes (combines with all genders, and both numbers)
3rd-sg-fem-poss-pron-post := 3rd-sg-fem-poss-pron & poss-pron-post-word.
; dens (combines with all genders, and both numbers)
3rd-sg-neut-msc-poss-pron-post := 3rd-sg-neut-msc-poss-pron & poss-pron-post-word.
; dets (combines with all genders, and both numbers)
3rd-sg-neut-nt-poss-pron-post := 3rd-sg-neut-nt-poss-pron & poss-pron-post-word.
; deres (combines with all genders, and both numbers)
3rd-plural-poss-pron-post := 3rd-plural-poss-pron & poss-pron-post-word.


; masc-or-fem-sg - same as for non-refl
; REFLEXIVE possessives, neutral as to whether pre- or post
; min
1st-mascsg-poss-refl-pron := 1st-sg-reflposs-word & sg-poss & seg-pron-word & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc ].
; mi
1st-sg-fem-poss-refl-pron := 1st-sg-reflposs-word & sg-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem ].
; mitt
1st-sg-neut-poss-refl-pron := 1st-sg-reflposs-word & sg-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
; mine
1st-sg-plur-poss-refl-pron := 1st-sg-reflposs-word & plur-poss & seg-pron-word.

; v√•r
1st-pl-masc-or-fem-sg-poss-refl-pron := 1st-pl-reflposs-word & sg-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem-sg ].
; v√•rt
1st-pl-neut-poss-refl-pron := 1st-pl-reflposs-word & sg-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
; v√•re
1st-pl-plur-poss-refl-pron := 1st-pl-reflposs-word & plur-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG pl ].
; din
2nd-mascsg-poss-refl-pron := 2nd-sg-reflposs-word & sg-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc ].
; di
2nd-sg-fem-poss-refl-pron := 2nd-sg-reflposs-word & sg-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem ].
; ditt
2nd-sg-neut-poss-refl-pron := 2nd-sg-reflposs-word & sg-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
; dine
2nd-sg-plur-poss-refl-pron := 2nd-sg-reflposs-word & plur-poss & seg-pron-word.

; deres (combines with all genders, and both numbers, and expresses all gend)
2nd-pl-poss-refl-pron := 2nd-pl-reflposs-word & seg-pron-word.

; sin
3rd-mascsg-poss-refl-pron := 3rd-reflposs-word & sg-poss & seg-pron-word & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc ].
; si
3rd-sg-fem-poss-refl-pron := 3rd-reflposs-word & sg-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem ].
; sitt
3rd-sg-neut-poss-refl-pron := 3rd-reflposs-word & sg-poss & seg-pron-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
; sine
3rd-plur-poss-refl-pron := 3rd-reflposs-word & plur-poss & seg-pron-word.

; Pre-nominal possessive refl
; min
1st-mascsg-poss-refl-pron-pre := 1st-mascsg-poss-refl-pron & poss-pron-word.
; mi
1st-sg-fem-poss-refl-pron-pre := 1st-sg-fem-poss-refl-pron & poss-pron-word.
; mitt
1st-sg-neut-poss-refl-pron-pre := 1st-sg-neut-poss-refl-pron & poss-pron-word.
; mine
1st-sg-plur-poss-refl-pron-pre := 1st-sg-plur-poss-refl-pron & poss-pron-word.
; v√•r
1st-pl-masc-or-fem-sg-poss-refl-pron-pre := 1st-pl-masc-or-fem-sg-poss-refl-pron & poss-pron-word.
; v√•rt
1st-pl-neut-poss-refl-pron-pre := 1st-pl-neut-poss-refl-pron & poss-pron-word.
; v√•re
1st-pl-plur-poss-refl-pron-pre := 1st-pl-plur-poss-refl-pron & poss-pron-word.
; din
2nd-mascsg-poss-refl-pron-pre := 2nd-mascsg-poss-refl-pron & poss-pron-word.
; di
2nd-sg-fem-poss-refl-pron-pre := 2nd-sg-fem-poss-refl-pron & poss-pron-word.
; ditt
2nd-sg-neut-poss-refl-pron-pre := 2nd-sg-neut-poss-refl-pron & poss-pron-word.
; dine
2nd-sg-plur-poss-refl-pron-pre := 2nd-sg-plur-poss-refl-pron & poss-pron-word.
; deres (combines with all genders, and both numbers, and expresses all gend)
2nd-pl-poss-refl-pron-pre := 2nd-pl-poss-refl-pron & poss-pron-word.
; sin
3rd-mascsg-poss-refl-pron-pre := 3rd-mascsg-poss-refl-pron & poss-reflpron-word.
; si
3rd-sg-fem-poss-refl-pron-pre := 3rd-sg-fem-poss-refl-pron & poss-reflpron-word.
; sitt
3rd-sg-neut-poss-refl-pron-pre := 3rd-sg-neut-poss-refl-pron & poss-reflpron-word.
; sine
3rd-plur-poss-refl-pron-pre := 3rd-plur-poss-refl-pron & poss-reflpron-word.

; postnominal reflexive possessives
; min
1st-mascsg-poss-refl-pron-post := 1st-mascsg-poss-refl-pron & poss-pron-post-word.
; mi
1st-sg-fem-poss-refl-pron-post := 1st-sg-fem-poss-refl-pron & poss-pron-post-word.
; mitt
1st-sg-neut-poss-refl-pron-post := 1st-sg-neut-poss-refl-pron & poss-pron-post-word.
; mine
1st-sg-plur-poss-refl-pron-post := 1st-sg-plur-poss-refl-pron & poss-pron-post-word.
; v√•r
1st-pl-masc-or-fem-sg-poss-refl-pron-post := 1st-pl-masc-or-fem-sg-poss-refl-pron & poss-pron-post-word.
; v√•rt
1st-pl-neut-poss-refl-pron-post := 1st-pl-neut-poss-refl-pron & poss-pron-post-word.
; v√•re
1st-pl-plur-poss-refl-pron-post := 1st-pl-plur-poss-refl-pron & poss-pron-post-word.
; din
2nd-mascsg-poss-refl-pron-post := 2nd-mascsg-poss-refl-pron & poss-pron-post-word.
; di
2nd-sg-fem-poss-refl-pron-post := 2nd-sg-fem-poss-refl-pron & poss-pron-post-word.
; ditt
2nd-sg-neut-poss-refl-pron-post := 2nd-sg-neut-poss-refl-pron & poss-pron-post-word.
; dine
2nd-sg-plur-poss-refl-pron-post := 2nd-sg-plur-poss-refl-pron & poss-pron-post-word.
; deres (combines with all genders, and both numbers, and expresses all gend)
2nd-pl-poss-refl-pron-post := 2nd-pl-poss-refl-pron & poss-pron-post-word.
; sin
3rd-mascsg-poss-refl-pron-post := 3rd-mascsg-poss-refl-pron & poss-reflpron-post-word.
; si
3rd-sg-fem-poss-refl-pron-post := 3rd-sg-fem-poss-refl-pron & poss-reflpron-post-word.
; sitt
3rd-sg-neut-poss-refl-pron-post := 3rd-sg-neut-poss-refl-pron & poss-reflpron-post-word.
; sine
3rd-plur-poss-refl-pron-post := 3rd-plur-poss-refl-pron & poss-reflpron-post-word.

;;;;;;;;;;;;;;;;;;;;
#|
explet-pron-word := word & rule &
  [ SYNSEM.LOCAL.CAT.HEAD expl-pron,
    SYNSEM.LOCAL.CONT.HOOK.INDEX expl-ind & [ WH -,
                                              PNG.NG neutsg],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC <>,
                           COMPS <> ],
    SYNSEM.LOCAL.CONT.RELS <! arg0bare-relation & [ PRED "_expletive_rel"] !>,
    SYNSEM.LOCAL.CONT.HCONS <!!>,
    RULE card-ok].
|#

; SYNSEM.LOCAL.CONT.HOOK.INDEX expl-ind
explet-pron-word := lbl-ltop-lex-item-2rel & rule & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD expl-pron & [DEF +,
                                       KEYS.KEY explprn,
				       EXPLETIVE +],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [ WH -,
                                             PNG 3nsg ],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC <>,
                           COMPS <> ],
    SYNSEM.LOCAL.BINDING [ BOUND -,
                           REFL-I -,
                           REFL-II - ],
    SYNSEM.LOCAL.CONT.RELS <! [PRED "_expletive_pron_rel",
			       ARG0 #2,
                               LBL #3],
                               expletive-q-rel & 
			        [ARG0 #2,
                                 RSTR #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    RULE card-ok ].

#|
explet-pron-word := lbl-ltop-lex-item-3rel & rule & no-slash &
  [ SYNSEM.LOCAL.CAT.HEAD expl-pron & [DEF +,
                                       KEYS.KEY explprn],
    SYNSEM.LOCAL.CONT.HOOK.INDEX expl-ind & [ WH -,
                                             PNG 3nsg ],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
                           SPR < >,
                           SPEC <>,
                           COMPS <> ],
    SYNSEM.LOCAL.BINDING [ BOUND -,
                           REFL-I -,
                           REFL-II - ],
    SYNSEM.LOCAL.CONT.RELS <! [PRED "_expletive_pron_rel",
			       ARG0 #2,
                               LBL #3],
                                [PRED "situation-intro-rel",
				 ARG0 #2,
				 LBL #3],
                               expletive-q-rel & 
			        [ARG0 #2,
                                 RSTR #4] !>,
    SYNSEM.LOCAL.CONT.HCONS <! [HARG #4,
                                LARG #3] !>,
    RULE card-ok ].
|#


    
noun-word := word &
  [ RULE card-sensitive,
    SYNSEM.LOCAL.CAT.HEAD #3 & comm-noun,
    SYNSEM.LOCAL.XCAT [HEAD #3 ],
    SYNSEM.LOCAL.CAT.VAL.SPEC list,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS list,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PERS thirdpers,
    SYNSEM.LOCAL.AGR.PNG.PERS thirdpers,
    SYNSEM.LOCAL.BINDING.BOUND -,
    SYNSEM.BIND unbnd ].

#|
sg-noun-word := noun-word.

plain-sg-noun-word := sg-noun-word & const-ltow-rule &
  [DTR noun-lexeme & [ SYNSEM.LOCAL.DERIVED-HEAD #11,
                       SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #1 ],
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #1 & sg,
   SYNSEM.LOCAL.CAT.HEAD noun & [DEFINITE -,
                                 BARE - ],
   SYNSEM.LOCAL.CAT.VAL.SPR 1-list,
   SYNSEM.LOCAL.DERIVED-HEAD #11,
    RULE.NEEDS-CARD bool ].
|#

bare-sg-noun-word := sg-noun-word &
  [DTR bare-sg-noun-lexeme & [ SYNSEM.LOCAL.DERIVED-HEAD #11,
                               SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #1 ],
   SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #1 & sg,
   SYNSEM.LOCAL.CAT.HEAD noun & [DEFINITE -],
   SYNSEM.LOCAL.DERIVED-HEAD #11,
    RULE.NEEDS-CARD bool ].

; LH Sep1 With these changes, all numb, gend and definiteness information is introduced at lexeme level, and likewise NG and 'DEFINITE bool'
;sg-noun-word := noun-word.

; produced via an ltol-rule *not* introducing a quantifier: it has to combine with a specifier in order for a q_rel to get introduced


;plain-sg-noun-word := noun-word & const-ltow-rule &
;  [DTR sg-indef-noun-lxm & [ SYNSEM.LOCAL.DERIVED-HEAD #11 ],
;   SYNSEM.LOCAL.CAT.HEAD noun & [BARE - ],
;   SYNSEM.LOCAL.CAT.VAL.SPR 1-list,
;   SYNSEM.LOCAL.DERIVED-HEAD #11,
;    RULE.NEEDS-CARD bool ].

; collapsing bare-sg-noun-word and plain-sg-noun-word into one type, namely sg-noun-word:
#|
; produced via an ltol-rule *not* introducing a quantifier
plain-sg-noun-word := noun-word & const-ltow-rule &
  [DTR sg-indef-noun-lxm & [ SYNSEM.LOCAL.DERIVED-HEAD #11 ],
   SYNSEM.LOCAL.DERIVED-HEAD #11,
    RULE.NEEDS-CARD bool ].

; produced via an ltol-rule introducing a quantifier
bare-sg-noun-word := noun-word & const-ltow-rule &
  [DTR bare-sg-noun-lexeme & [ SYNSEM.LOCAL.DERIVED-HEAD #11 ],
   SYNSEM.LOCAL.DERIVED-HEAD #11,
    RULE.NEEDS-CARD bool ].
|#

sg-noun-word := noun-word & const-ltow-rule &
  [SYNSEM.LOCAL.CAT.VAL #1,
   SYNSEM.LOCAL.DERIVED-HEAD #11,
   DTR noun-infl-lexeme & [ SYNSEM.LOCAL.CAT.VAL #1,
                            SYNSEM.LOCAL.DERIVED-HEAD #11 ],
   RULE.NEEDS-CARD bool ].



mascsg-def-noun-word := noun-word & infl-ltow-rule &
  [ SYNSEM.LOCAL.DERIVED-HEAD #11,
    ARGS < sg-masc-def-noun-lexeme & [SYNSEM.LOCAL.DERIVED-HEAD #11] > ].

femsg-def-noun-word := noun-word & infl-ltow-rule &
  [  SYNSEM.LOCAL.DERIVED-HEAD #11,
     DTR sg-fem-def-noun-lexeme & [SYNSEM.LOCAL.DERIVED-HEAD #11] ].

neutsg-def-noun-word := noun-word & infl-ltow-rule &
  [  SYNSEM.LOCAL.DERIVED-HEAD #11,
     DTR sg-neut-def-noun-lexeme & [SYNSEM.LOCAL.DERIVED-HEAD #11]  ].

pl-def-noun-word := noun-word & infl-ltow-rule &
  [  SYNSEM.LOCAL.DERIVED-HEAD #11,
     DTR plur-def-noun-lexeme & [SYNSEM.LOCAL.DERIVED-HEAD #11] ].

plur-indef-noun-word := noun-word & infl-ltow-rule &
  [  SYNSEM.LOCAL.DERIVED-HEAD #11,
     RULE #1,
     DTR pl-indef-noun-lexeme,
     DTR.SYNSEM.LOCAL.DERIVED-HEAD #11,
     DTR.RULE #1].

;this is the normal version, so no label 'infl' on it
mascpl-indef-noun-word := plur-indef-noun-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-pl ].

mascpl-indef-noun-const-word := noun-word & const-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-pl,
    DTR pl-indef-noun-lexeme,
    RULE #1,
    DTR.RULE #1].

fempl-indef-noun-word := plur-indef-noun-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem-pl ].

fempl-indef-noun-const-word := noun-word & const-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem-pl,
    DTR pl-indef-noun-lexeme,
    RULE #1,
    DTR.RULE #1].

neutpl-indef-noun-infl-word := plur-indef-noun-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutpl ].

neutpl-indef-noun-const-word := noun-word & const-ltow-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neutpl,
    DTR pl-indef-noun-lexeme,
    RULE #1,
    DTR.RULE #1 ].



;;;;;;;;;;; VERB WORDS

; less strict XCAT-CAT relation, to allow  "g√•r fra... og blir leder": combine verb and cop
verb-word := word & lex-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [KEYS.KEY vb,
                                      INV #4,
                                      VOICE #voice],
    SYNSEM.LOCAL.XCAT [HEAD verb-all & [INV #4] ],
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E [TENSE #tense,
                                    MOOD #mood],
    SYNSEM.NON-LOCAL.SLASH #2,
    INFL-MORPH [TEMPUS #tense,
                MODUS #mood,
                DIATHESIS #voice],
    INFLECTED +,
    EXTRACTED-FROM -,
    DTR [ SYNSEM.NON-LOCAL.SLASH #2,
          INFLECTED - ]].

; removed DTR verb-general-lexeme, since presentational verbs do not belong here, due to their extra EPs
    
inf-verb-word := verb-word & const-ltow-rule &
  [ DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [VOICE active],
    SYNSEM.LOCAL.CAT.HEAD [VOICE active,
                           IMPERATIVE -,
                           DECL +],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative ].

imp-verb-word := verb-word & rule &
  [ DTR imperative-verb-lexeme,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD imperative,
    SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE +].

infl-imp-verb-word := imp-verb-word & infl-ltow-rule.

const-imp-verb-word := imp-verb-word & const-ltow-rule.

infl-ltow-verb-word := verb-word & infl-ltow-rule.
const-ltow-verb-word := verb-word & const-ltow-rule.

indicative-verb-word := verb-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
    SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE - ].

pres-verb-word := indicative-verb-word &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE pres,
  DTR.SYNSEM.LOCAL.CAT.HEAD.VOICE active  ].

infl-pres-verb-word := infl-ltow-verb-word & pres-verb-word.
const-pres-verb-word := const-ltow-verb-word & pres-verb-word.

pret-verb-word := indicative-verb-word &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE pret,
  DTR.SYNSEM.LOCAL.CAT.HEAD.VOICE active ].

infl-pret-verb-word := infl-ltow-verb-word & pret-verb-word.
const-pret-verb-word := const-ltow-verb-word & pret-verb-word.

; so far, this covers both active and passive - participle-pass-word below not activated yet
perf-part-verb-word := indicative-verb-word &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE perf,
    SYNSEM.LOCAL.CAT.HEAD.VOICE #1,
    DTR.SYNSEM.LOCAL.CAT.HEAD.VOICE #1 ].

infl-perf-part-verb-word := infl-ltow-verb-word & perf-part-verb-word.
const-perf-part-verb-word := const-ltow-verb-word & perf-part-verb-word.


s-pass-word := indicative-verb-word & infl-ltow-verb-word & 
  [ SYNSEM.LOCAL.CAT.HEAD.VOICE s-pass,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE pres,
    DTR [SYNSEM  [ LOCAL [ CAT [ HEAD verb & [ VOICE passive ]]]]]].

participle-pass-word := indicative-verb-word & infl-ltow-verb-word & 
  [ SYNSEM.LOCAL.CAT.HEAD.VOICE ptc-pass,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE perf,
    DTR [SYNSEM  [ LOCAL [ CAT [ HEAD verb & [ VOICE passive ]]]]]].
#|
participle-pass-word := indicative-verb-word & infl-ltow-verb-word & 
  [ SYNSEM.LOCAL.CAT.HEAD.VOICE ptc-pass,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE perf,
    DTR passive-lexeme ].
|#

;interjection-word := verb-word & const-ltow-rule & rule &
;  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [KEYS.KEY interjct ], 
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD hortative].

interjection-word := word & rule & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD interjection & [KEYS.KEY interjct,
				      INTERJECT +,
				      MOD <[LOCAL.CONT.HOOK.INDEX #1]>],
   SYNSEM.LOCAL.CAT.VAL.COMPS <>,
;   SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
   SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
   SYNSEM.LOCAL.CAT.VAL.SPR <>,
   SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    SYNSEM.LKEYS.KEYREL.ARG1 #1,
    SYNSEM.NON-LOCAL.SLASH <! !>,
   SYNSEM.LOCAL.CONT.RELS <! [ ] !>,
   SYNSEM.LOCAL.CONT.HCONS <! !> ].



;;;; COMPLEMENTIZERS
basic-compl := word &
  [SYNSEM.LOCAL.CAT.HEAD prep-or-comp,
   SYNSEM.LOCAL.CAT.VAL.COMPS < #1 & [LOCAL.CONT.HOOK.INDEX.E.TENSE #2 & tense ]>,
   SYNSEM.LOCAL.CAT.QVAL.DOBJECT #1,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE #2,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
   SYNSEM.LOCAL.AGR.PNG.NG neutsg ].


inf-comp := basic-compl &
  [ SYNSEM.LOCAL.CAT.HEAD infin-comp & [ TRANSPAR +,
                                         DECL +,
                                         KEYS.KEY infinit-comp-eq],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.COMPS olist,
                                   LOCAL.CAT.VAL.SUBJ < synsem >,
                                   LOCAL.CAT.VAL [SPR <>,
                                                  SPEC <>,
                                                  ICOMPS <>],    
                                   LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
                                   LOCAL.CAT.HEAD.MAIN-CL -,
                                   LOCAL.CAT.HEAD verb-all,
                                   LOCAL.CONT.HOOK.LTOP #4,
                                   LOCAL.CONT.HOOK.XARG #1 ]>, 
   SYNSEM.LOCAL.CONT.HOOK.XARG #1,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,  
   SYNSEM.LOCAL.CONT.RELS <! [PRED "_inf-mark_rel",
					      LBL #3,
                                              ARG1 #4 ] !>,
   SYNSEM.LOCAL.CONT.HCONS <! !> ].

;;;;;;;;;

inf-arbref-comp := basic-compl &
  [ SYNSEM.LOCAL.CAT.HEAD infin-comp & [ TRANSPAR -,
                                         DECL +,
                                         KEYS.KEY infinit-comp-arb ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #ind & ref-ind & [PNG.PERS thirdpers]] >,
                                   LOCAL.CAT.HEAD.MAIN-CL -,    
                                   LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
                                   LOCAL.CONT.HOOK.LTOP #4 ]>, 
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,  
   SYNSEM.LOCAL.CONT.RELS <! arg1-relation & [PRED "_inf-mark_rel",
					      LBL #3,
                                              ARG1 #4],
			   indef-q-rel & [PRED "_udef_q_rel",
					    ARG0 #ind,
					    RSTR #rstr], [ PRED "_pron_rel",
							   LBL #lbl,
							   ARG0 #ind ] !>,
   SYNSEM.LOCAL.CONT.HCONS <! [HARG #rstr,
			       LARG #lbl] !> ].



; a preposition - "...for √• .." (rais), with feature transportation from V velow to V above as main purpose
; KEYS.KEY predcomp-inf,
;                                        SELECTED +,

for-comp := basic-compl &
  [ SYNSEM.LOCAL.CAT.HEAD for-cmp & [ DECL +],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ < synsem >,    
                                   LOCAL.CAT.VAL.COMPS olist,
                                   LOCAL.CAT.VAL [SPR <>,
                                                  SPEC <>,
                                                  ICOMPS <>],
                                   LOCAL.CAT.HEAD.TRANSPAR +,
                                   LOCAL.CONT.HOOK.LTOP #3,
                                   LOCAL.CONT.HOOK.XARG #1 ]>,   
   SYNSEM.LOCAL.CONT.HOOK.XARG #1,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,  
   SYNSEM.LOCAL.CONT.RELS <! [] !>,
   SYNSEM.LOCAL.CONT.HCONS <! !> ].

;;;  DPF 020411

som-adj-pred-comp := word &
  [ SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY predcomp-adj ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < #5 & [ LOCAL.CAT.VAL.SUBJ antilist,
                                        LOCAL.CONT.HOOK.LTOP #3,
                                        LOCAL.CONT.HOOK.XARG #1 ]>, 
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT #5,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #3,  
    SYNSEM.LOCAL.CONT.RELS <! [PRED "_som_eq_rel"] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].

#|
som-adj-pred-comp := word &
  [ SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY predcomp-adj ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < #5 & [ LOCAL.CAT.VAL.SUBJ olist,
                                        LOCAL.CONT.HOOK.LTOP #3,
                                        LOCAL.CONT.HOOK.XARG #1 ]>, 
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT #5,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #3,  
    SYNSEM.LOCAL.CONT.RELS <! [PRED "_som_eq_rel"] !>,
    SYNSEM.LOCAL.CONT.HCONS <! !> ].
|#


som-adj-pred-pp-comp := som-adj-pred-comp &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD adj-reg ]> ].

som-adj-pred-clse-comp := som-adj-pred-comp &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD verb-all ]> ].

som-n-pred-comp := word &
  [ SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY predcomp-n ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ <>,    
                                   LOCAL.CAT.HEAD noun,
                                   LOCAL.CONT.HOOK.INDEX #5,
                                   LOCAL.DERIVED-HEAD - ]>,   
   SYNSEM.LOCAL.CONT.HOOK.XARG #1,   
   SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,  
   SYNSEM.LOCAL.CONT.RELS <! [ PRED "_instantiate_c_rel",
			       LBL #3,
			       ARG0 #8,
			       ARG1 #1,
			       ARG2 #5 ] !>,
   SYNSEM.LOCAL.CONT.HCONS <! !> ].


#|
som-n-pred-comp := word &
  [ SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY predcomp-n ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ <>,    
                                   LOCAL.CAT.HEAD noun,
                                   LOCAL.CONT.HOOK.INDEX #5,
                                   LOCAL.DERIVED-HEAD - ]>,   
   SYNSEM.LOCAL.CONT.HOOK.XARG #1,   
   SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,  
   SYNSEM.LOCAL.CONT.RELS <! [ PRED "_instantiate_c_rel",
			       LBL #3,
			       ARG0 #8,
			       ARG1 #1 & [ PNG.NG.NUM #num ],
			       ARG2 #5 & [ PNG.NG.NUM #num ] ] !>,
   SYNSEM.LOCAL.CONT.HCONS <! !> ].
|#
pre-subord-comp :=  basic-compl & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD glob-comp & [ TRANSPAR -,
                                       KEYS.KEY pre-comp ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD glob-comp & [ TRANSPAR - ],
				   LOCAL.CAT.VAL.SUBJ antilist,    
                                   LOCAL.CAT.VAL.COMPS olist,
                                   LOCAL.CAT.VAL [SPR <>,
                                                  SPEC <>,
                                                  ICOMPS <>],
                                   LOCAL.CAT.HEAD.MAIN-CL -,
                                   LOCAL.CAT.HEAD.IMPERATIVE -,
                                   LOCAL.CONT.HOOK.LTOP #4 ]>,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
   SYNSEM.LOCAL.CONT.RELS <! arg1-relation & [LBL #3,
                                              ARG1 #4] !>,
   SYNSEM.LOCAL.CONT.HCONS <!  !> ].


; 'semarg' from '#4'
subord-comp :=  basic-compl & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD fin-comp & [ TRANSPAR -,
                                       KEYS.KEY finit-comp ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ antilist,    
                                   LOCAL.CAT.VAL.COMPS olist,
                                   LOCAL.CAT.VAL [SPR <>,
                                                  SPEC <>,
                                                  ICOMPS <>],
                                   LOCAL.CAT.HEAD.MAIN-CL -,
                                   LOCAL.CAT.HEAD verb-all,
                                   LOCAL.CAT.HEAD.IMPERATIVE -,
                                   LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
                                   LOCAL.CONT.HOOK.LTOP #4 ]>,
   SYNSEM.LOCAL.CONT.HOOK.LTOP semarg,
   SYNSEM.LOCAL.CONT.RELS <! arg1-relation & [LBL semarg,
                                              ARG1 #4] !>,
   SYNSEM.LOCAL.CONT.HCONS <!  !> ].

; 'semarg' from '#4'
subord-maincl-comp :=  basic-compl & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD fin-comp & [ TRANSPAR -,
                                       KEYS.KEY finit-comp ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ antilist,    
                                   LOCAL.CAT.VAL.COMPS olist,
                                   LOCAL.CAT.VAL [SPR <>,
                                                  SPEC <>,
                                                  ICOMPS <>],
                                   LOCAL.CAT.HEAD.MAIN-CL +,
                                   LOCAL.CAT.HEAD verb-all,
                                   LOCAL.CAT.HEAD.IMPERATIVE -,
                                   LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
                                   LOCAL.CONT.HOOK.LTOP semarg ]>,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
   SYNSEM.LOCAL.CONT.RELS <! arg1-relation & [LBL #3,
                                              ARG1 semarg] !>,
   SYNSEM.LOCAL.CONT.HCONS <!  !> ].

decl-subord-comp := subord-comp &
  [ SYNSEM.LOCAL.CAT.HEAD.DECL +,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.DECL +,
				   LOCAL.CONT.HOOK.INDEX.SF prop ] >].

y-n-quest-subord-comp := subord-comp &
  [ SYNSEM.LOCAL.CAT.HEAD.DECL -,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.DECL -,
				   LOCAL.CAT.HEAD.WH-COMPLETE -,
				   LOCAL.CONT.HOOK.INDEX.SF ques] >].

subord-colon :=  basic-compl & lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD fin-comp & [ TRANSPAR -,
                                       KEYS.KEY finit-comp ],
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.VAL.SUBJ antilist,    
                                   LOCAL.CAT.VAL.COMPS olist,
                                   LOCAL.CAT.VAL [SPR <>,
                                                  SPEC <>,
                                                  ICOMPS <>],
                                   LOCAL.CAT.HEAD.MAIN-CL +,
                                   LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
                                   LOCAL.CONT.HOOK.LTOP #4 ]>,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
   SYNSEM.LOCAL.CONT.RELS <! arg1-relation & [PRED "subord-colon_rel",
					      LBL #3,
                                              ARG1 #4] !>,
   SYNSEM.LOCAL.CONT.HCONS <!  !> ].

#|

interjection-lexeme := lexeme & lbl-ltop-lex-item & 
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [KEYS.KEY interjct ],
    SYNSEM.LOCAL.CAT [VAL [ SUBJ antilist,
                            SPR < >,
                            SPEC <>,
                            COMPS <>,
                            ICOMPS <> ]], 
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD hortative,
    SYNSEM.LOCAL.CONT.RELS <! arg0-relation !>,
    SYNSEM.LOCAL.CONT.HCONS <! !>, 
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.BIND unbnd ].
|#


 ;  LEXEME TYPES

top-verb-lexeme := lexeme.

; lexeme, inheriting from norm-lex-item, allows for many rels; verb-lexeme,
; by assumption, only one

verb-general-lexeme := top-verb-lexeme & lbl-ltop-lex-item & 
  [ SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    SYNSEM.LOCAL.HAS-WH-MOVED -,
    SYNSEM.LOCAL.HEAD-SUBJ-APPLIED -,
    SYNSEM.LOCAL.COMPS-BEGUN -,				;; Added to avoid s-final. EAA030811
    SYNSEM.BIND unbnd ].

verb-lexeme := verb-general-lexeme &
  [ SYNSEM.LOCAL.CAT.HEAD verb  & [VOICE active,
                                   KEYS.KEY mainvb],
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CAT.HEAD.EXPLETIVE bool] > ]]].


				    
;;; LEXICAL ENTRIES

; sove, starte, sove, revne, st√•
intrans-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-arg1-synsem,
  EXTRACTED-FROM -  ].

; g√•, l√∏pe, hoppe
intrans-arg1dir-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-arg1dir-synsem ].

; added 'sup' 31.03.09, to harmonize with Univcode
intrans-obl-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obl-n-synsem,
  EXTRACTED-FROM -  ].

intrans-locobl-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-locobl-synsem,
  EXTRACTED-FROM -  ].

; added 'sup' 31.03.09, to harmonize with Univcode
intrans-2obl-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-2obl-synsem-sup,
  EXTRACTED-FROM -  ].

; "se alvorlig p√•"
intrans-adv-obl-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-adv-obl-synsem ].

intrans-obl-sup-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obl-synsem-sup ].

intrans-obl-n-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obl-n-synsem ].

intrans-obl-decl-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obl-decl-synsem ].

; intended for same coverage as intrans-indirwhquest-pp-verb-lexeme - has PP as ICOMPS, while the other has it as COMPS
intrans-obl-interr-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obl-interr-synsem ].

; intended for same coverage as intrans-obl-interr-verb-lexeme - has PP as COMPS, while the other has it as ICOMPS
intrans-indirwhquest-pp-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-indirwhquest-pp-synsem ].

; only in semlab lex
intrans-obl-arbinf-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obl-arbinf-synsem ].

; spise p√•, gnage p√•
intrans-atel-obl-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-atel-obl-synsem ].

; no phrasal rule going with this yet. only 4 items.
; fungere, dufte
intrans-obladv-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obladv-synsem ].

intrans-obl-refl-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obl-refl-synsem ].

intrans-eventarg1-decl-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1-decl-synsem  ].

intrans-eventarg1-interr-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1-interr-synsem ].

intrans-eventarg1-absinf-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1-absinf-synsem  ].

intrans-eventarg1-decl-obl-n-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1-decl-obl-n-synsem ].
intrans-eventarg1-interr-obl-n-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1-interr-obl-n-synsem ].
intrans-eventarg1-absinf-obl-n-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1-absinf-obl-n-synsem ].

intrans-eventarg1decl-eventobldecl-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1decl-eventobldecl-synsem ].
intrans-eventarg1decl-eventoblinterr-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1decl-eventoblinterr-synsem ].
intrans-eventarg1interr-eventobldecl-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1interr-eventobldecl-synsem ]. 
intrans-eventarg1interr-eventoblinterr-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-eventarg1interr-eventoblinterr-synsem ]. 




; for "han stiller som reserve"
intrans-secpred-som-arg1-x-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-secpred-som-arg1-x-synsem ].

intrans-eventarg1-secpred-som-arg1-x-verb-lexeme := verb-general-lexeme &
  [ SYNSEM intrans-eventarg1-secpred-som-arg1-x-synsem ].

; perhaps useful
intrans-rais-from-pp-arg1-verb-lexeme := verb-general-lexeme &
  [ SYNSEM intrans-rais-from-pp-arg1-synsem ].

; new generation type - see lex-types-v.tdl
;v-intrOblEpon := verb-lexeme &
;  [ SYNSEM intrans-epon-with-pp-arg1-synsem ].

v-intrPrtclOblEpon-oblEponDECL := verb-lexeme &
  [ SYNSEM intrans-adv-epon-with-pp-arg1-synsem ].
;v-intrPrtclOblEpon-subjExpl_oblEponDECL := verb-lexeme &
;  [ SYNSEM intrans-adv-epon-with-pp-arg1-synsem ].

; forefalle_2, virke, synes, vedbli
intrans-secpred-rais-from-nonverbal-arg1-verb-lexeme := verb-general-lexeme &
[ SYNSEM intrans-secpred-rais-from-nonverbal-arg1-synsem ].

; forefalle_2, virke, synes, vedbli
epon-intrans-secpred-rais-from-nonverbal-arg1-verb-lexeme := verb-2rel-lexeme &
[ SYNSEM epon-intrans-secpred-rais-from-nonverbal-arg1-synsem ].

; TODO - LH300712 not yet working
; forefalle_2, virke, synes, vedbli
epon-predprtcl-intrans-secpred-rais-from-nonverbal-arg1-verb-lexeme := verb-3rel-lexeme &
[ SYNSEM epon-predprtcl-intrans-secpred-rais-from-nonverbal-arg1-synsem ].

; "se syk ut" - ut_6 := adv-particle-word
intrans-secpred-prtcl1-rais-from-nonverbal-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-secpred-prtcl1-rais-from-nonverbal-arg1-synsem ].

intrans-secpred-prtcl1a-rais-from-nonverbal-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-secpred-prtcl1a-rais-from-nonverbal-arg1-synsem ].

; "se ut til √• komme" - ut_6 := adv-particle-word; til_11 := prep-rais-word;
; 'non-verbal' because
; the infinitive marker "√•" ('inf-comp') heads a non-verbal projection
; flawed
intrans-secpred-prtcl2-rais-from-nonverbal-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-secpred-prtcl2-rais-from-nonverbal-arg1-synsem ].
; only in semlab, with type v-intrAdvOblRais-subjNonarg_oblRaisInf-thSitObl-EXHIBACT
intrans-adv-rais-from-pp-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-adv-rais-from-pp-arg1-synsem ].

; se ut som. se ut som om
intrans-secpred-prtcl3-rais-from-nonverbal-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-secpred-prtcl3-rais-from-nonverbal-arg1-synsem ].

intrans-secpred-argx-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-secpred-argx-synsem ].

; koke_intr-sec
intrans-secpred-argcsx-verb-lexeme := verb-2rel-lexeme-straight &
[ SYNSEM intrans-secpred-argcsx-synsem ].

;intrans-secpred-adj-argx-verb-lexeme := verb-lexeme &
;[ SYNSEM intrans-secpred-adj-argx-synsem ].
;intrans-secpred-pp-argx-verb-lexeme := verb-lexeme &
;[ SYNSEM intrans-secpred-pp-argx-synsem ].

intrans-secpred-arg1-csx-verb-lexeme := verb-2rel-lexeme-straight &
[ SYNSEM intrans-secpred-arg1-csx-synsem ].

; lade opp, bule ut, ese opp - 
intrans-telicparticle-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-telicparticle-arg1-synsem ].

; no lex-item using this - they all are subtypes - the one above, and underneath
intrans-aspectualparticle-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-telicity-particle-arg1-synsem ].

; holde p√•, drive p√•: it enforces atelicity for the whole constr.
intrans-atelicparticle-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-atelicparticle-arg1-synsem ].

; drive (og g√•)
; for "drive" in "driver og g√•r": it enforces atelicity for the whole constr.
intrans-arg1-atelic-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-arg1-atelic-synsem ].

; flawed
; for "drive/holde" in "driver/holder p√• med √•": it enforces atelicity for the whole constr.
;subj-prtcl-equi-pp-atelic-verb-lexeme := verb-lexeme &
;[ SYNSEM subj-prtcl-equi-pp-atelic-synsem ].
; ok:
subj-prtcl-equi-pp-atelic-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obl-adv-equinf-synsem ].

intrans-secpred-rais-from-verbal-arg1-verb-lexeme-sup := verb-general-lexeme &
  [ SYNSEM intrans-secpred-rais-from-verbal-arg1-synsem,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1 ].

; forefalle, , "forefalle komme"
intrans-secpred-rais-from-verbal-arg1-verb-lexeme := intrans-secpred-rais-from-verbal-arg1-verb-lexeme-sup & verb-lexeme.

; forefalle_3, vedbli "forefalle √• komme"
intrans-secpred-rais-from-infinmarked-arg1-verb-lexeme := verb-lexeme &
  [ SYNSEM intrans-secpred-rais-from-infinmarked-arg1-synsem,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1 ].

; for inheritance
aux-verb-lexeme := verb-general-lexeme & 
  [ SYNSEM.LOCAL.CAT.HEAD verb-aux & [ KEYS.KEY auxvb ],
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1 ].

; ville, m√•tte, kunne, burde, skulle
epistemic-modal-verb-lexeme := intrans-secpred-rais-from-verbal-arg1-verb-lexeme-sup & aux-verb-lexeme.

; "ha, bli" - for inheritance
intrans-secpred-rais-from-perfect-verbal-arg1-verb-lexeme := verb-general-lexeme &
  [ SYNSEM intrans-secpred-rais-from-perfect-verbal-arg1-synsem,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1 ].

; ha, f√•
aux-perf-verb-lexeme := intrans-secpred-rais-from-perfect-verbal-arg1-verb-lexeme & aux-verb-lexeme &
  [SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VOICE active ] >].

; bli (passive)
aux-pass-verb-lexeme := intrans-secpred-rais-from-perfect-verbal-arg1-verb-lexeme & aux-verb-lexeme &
  [SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.VOICE ptc-pass ] >].

; pr√∏ve, fors√∏ke
subj-equi-verb-lexeme := verb-lexeme &
[ SYNSEM subj-equi-synsem ].

; finne p√• √•
subj-equi-particle-verb-lexeme := verb-lexeme &
[ SYNSEM subj-equi-particle-synsem ].

; for inheritance
subj-equi-bare-verb-lexeme := verb-general-lexeme &
  [ SYNSEM subj-equi-bare-synsem,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1 ].

; ville, m√•tte, kunne, burde, skulle
root-modal-verb-lexeme := subj-equi-bare-verb-lexeme & aux-verb-lexeme.

; flawed
; "be om √• komme"; "snakke om √• komme"
;subj-equi-pp-verb-lexeme := verb-lexeme &
;[ SYNSEM subj-equi-pp-synsem ].
; "be om √• komme"; "snakke om √• komme"

; ok:
subj-equi-pp-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-obl-equinf-synsem ].

; "drive med √• komme"
subj-equi-pp-atelic-verb-lexeme := verb-lexeme &
[ SYNSEM subj-equi-pp-atelic-synsem ].

; se_2, treffe, lage, fort√¶re
; cannot really maintain that all objects be referential-thing - will block "fort√¶re en sekk med poteter", for instance
;trans-arg1-2-verb-lexeme := verb-lexeme &
;[ SYNSEM trans-arg1-2-synsem & [ LOCAL.CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
;                                                           OPT - ] >]] ].

trans-arg1-2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1-2-synsem & [ LOCAL.CAT.VAL [ COMPS <[ ]>]] ].

; MUST MAKE A COMMON EXCL SUPERTYPE OF INHER-COMPL AND referential-thing,
; to make head-verb-comp-phrase subsume this type
;trans-arg1-2inh-verb-lexeme := verb-lexeme &
;[ SYNSEM trans-arg1-2-synsem-sup & [ LOCAL.CAT.VAL [ COMPS < [ LOCAL.CONT.HOOK.INDEX.SORT inher-compl ] >]] ].
; but making things simpler right now:
trans-arg1-2inh-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1-2-synsem-sup ].

; vaske
trans-arg1-2refl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1-2refl-synsem & [ LOCAL.CAT.VAL [ COMPS <[ ]>]] ].

; COMPS <[LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
; legge, skyte, kaste, sl√•, heade, sparke, spille, miste, slepe
trans-arg1-2dir-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1-2dir-synsem & [LOCAL [ CAT.VAL [SUBJ <[ ] >,
                                            COMPS <[ ]>]]] ].



; basere NP p√•, fortelle tull om - not discrim the governee of prep
trans-obl-sup-verb-lexeme := verb-lexeme &
[ SYNSEM trans-obl-synsem-sup ].


; basere NP p√•, fortelle tull om
trans-obl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-obl-n-synsem ].

trans-obl-decl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-obl-decl-synsem ].

trans-obl-interr-verb-lexeme := verb-lexeme &
[ SYNSEM trans-obl-interr-synsem ].

trans-obl-absinf-verb-lexeme := verb-lexeme &
[ SYNSEM trans-obl-absinf-synsem ].

; basere seg p√• - not discriminating about the governee of the prep
trans-refl-obl-sup-verb-lexeme := verb-lexeme &
[ SYNSEM trans-refl-obl-synsem-sup ].

; basere seg p√•
trans-refl-obl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-refl-obl-synsem ].

trans-refl-obl-decl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-refl-obl-decl-synsem ].

trans-refl-obl-interr-verb-lexeme := verb-lexeme &
[ SYNSEM trans-refl-obl-interr-synsem ].

trans-refl-obl-absinf-verb-lexeme := verb-lexeme &
[ SYNSEM trans-refl-obl-absinf-synsem ].

; "vedde 2 kroner med Marit p√• at..."
trans-2obl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-2obl-synsem ].

; "lagre kisten i skogen"
trans-locobl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-locobl-synsem ].

; "oppholde seg i skogen"
trans-refl-locobl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-refl-locobl-synsem ].

; no phrasal rule going with this yet. only 1 item: tilrede.
trans-obladv-verb-lexeme := verb-lexeme &
[ SYNSEM trans-obladv-synsem ].

trans-refl-obladv-verb-lexeme := verb-lexeme &
[ SYNSEM trans-refl-obladv-synsem ].


trans-dir-verb-lexeme := verb-lexeme &
[ SYNSEM trans-dir-synsem ].

trans-refl-dir-verb-lexeme := verb-lexeme &
[ SYNSEM trans-refl-dir-synsem ].

; for "treffe Jon i hodet": 'the head is possessed by Jon', thus #3 is the head ; and #1 is Jon. Also, for: "(?) kaste Jon n√∏tter i hodet"
; removed: 'LOCAL.CAT.HEAD.KEYS.KEY detch,' from the ICOMPS - the
; prep is quite freely selected, actually
                               
; this type is made for the types trans-pp-arg1-detached-poss-synsem-sup and ditrans-pp-arg1-2-detached-poss-synsem. The intransitive version, almost identical apart from a non-empty COMPS, is intrans-pp-detached-poss-synsem.
detached-possessor-synsem := arg1-subj-synsem &
  [ LOCAL.CAT.VAL [ COMPS < [ LOCAL [ CONT.HOOK.INDEX #1 ] ], ... >,
                    ICOMPS < [ LOCAL.CONT.HOOK.VARG #3,
                               LOCAL.CONT.HOOK.LTOP #2,
                               LOCAL.CAT.HEAD.KEYS.KEY detch ] > ],
    LKEYS [ ALTKEYREL #altkey & poss-rel &
                  [ ARG1 #1,
                    ARG2 #3 ],
            KEYREL #key & [ARGOBLQ #2] ],
    LOCAL.CONT.RELS <! #key, #altkey !> ].


;;   "Kari skrubber Jon p√• ryggen" (adv11) - two options:
; in this, Kari is what is 'on'

#|
trans-pp-arg1-detached-poss-synsem := detached-possessor-synsem &
  [ LOCAL.CAT trans-with-1icomps-pp-cat & [VAL.ICOMPS <[LOCAL.CONT.HOOK.VARG #5]>,
                                            VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #4],
    LKEYS [ ALTKEYREL [ ARG1 #4 ],
            KEYREL [ ARG1 #5 ] ] ].
|#

; ; in this, the event as such is what is 'on' - probably 
intrans-pp-detached-poss-synsem := arg1-subj-synsem &
  [ LOCAL.CAT.HEAD verb,
    LOCAL.CAT.VAL [ SUBJ < [ LOCAL [ CONT.HOOK.INDEX #1 ] ], ... >,
                    ICOMPS < [ LOCAL.CONT.HOOK.VARG #3,
                               LOCAL.CONT.HOOK.LTOP #2,
                               LOCAL.CAT.HEAD.KEYS.KEY detch ] > ],
    LKEYS [ ALTKEYREL #altkey & poss-rel &
                  [ LBL #4,
		    ARG1 #1,
                    ARG2 #3 ],
            KEYREL #key & [LBL #4,
			   ARGOBLQ #2]],
    LOCAL.CONT.RELS <! #key, #altkey !>].



; the least controversial
trans-pp-arg1-detached-poss-synsem-sup := detached-possessor-synsem &
  [ LOCAL.CAT trans-with-1icomps-pp-cat & [VAL.ICOMPS <[LOCAL.CONT.HOOK.XARG #5]>,
                                            VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #4],
    LKEYS [ ALTKEYREL [ ARG1 #4 ],
            KEYREL [ ARG0 #5,
		     ARG2 #4] ] ].

trans-pp-arg1-detached-poss-synsem := trans-pp-arg1-detached-poss-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ] >].

trans-pp-arg1-detached-poss-refl-synsem := trans-pp-arg1-detached-poss-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #1,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING [ BOUND +,
                                           REFL-I +,
                                           REFL-II -,
                                           LEX-TAME + ],
                           LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #1 ] >,
                           LOCAL.AGR.PNG #2 ] >].



;;   "Jon kyler Kari en sn√∏ball i ryggen" (adv10)
ditrans-pp-arg1-2-detached-poss-synsem := detached-possessor-synsem &
  [ LOCAL.CAT ditrans-with-icomps-pp-cat & [VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #4,
                                            VAL.COMPS.REST.FIRST.LOCAL.CONT.HOOK.INDEX #5],
    LKEYS [ ALTKEYREL [ ARG1 #4 ],
            KEYREL [ ARG2 #5 ] ]].

; has only one subtype
verb-2rel-lexeme-sup := top-verb-lexeme & 
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [VOICE active],
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.BIND unbnd ].

verb-2rel-lexeme-straight := verb-2rel-lexeme-sup & lbl-ltop-lex-item-2rel.
verb-2rel-lexeme := lbl-ltop-lex-item-2rel-lbltweak & 
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [VOICE active],
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.BIND unbnd,
    INFLECTED -].

verb-2rel-arg12a-lexeme := verb-2rel-lexeme & lbl-ltop-lex-item-2rel-lbltweak-arg12a.

verb-2rel-arg12a1-lexeme := verb-2rel-lexeme & lbl-ltop-lex-item-2rel-lbltweak-arg12a1.
verb-2rel-arg12a12-lexeme := verb-2rel-lexeme & lbl-ltop-lex-item-2rel-lbltweak-arg12a12.
verb-2rel-arg12aObl-lexeme := verb-2rel-lexeme & lbl-ltop-lex-item-2rel-lbltweak-arg12aObl.
verb-2rel-arg12a1Obl-lexeme := verb-2rel-lexeme & lbl-ltop-lex-item-2rel-lbltweak-arg12a1Obl.
verb-2rel-arg12a12Obl-lexeme := verb-2rel-lexeme & lbl-ltop-lex-item-2rel-lbltweak-arg12a12Obl.
verb-2rel-arg12ax-lexeme := verb-2rel-lexeme & lbl-ltop-lex-item-2rel-lbltweak-arg12ax.
verb-2rel-arg12a1x-lexeme := verb-2rel-lexeme & lbl-ltop-lex-item-2rel-lbltweak-arg12a1x.
verb-2rel-arg12a12x-lexeme := verb-2rel-lexeme & lbl-ltop-lex-item-2rel-lbltweak-arg12a12x.

verb-3rel-lexeme := lexeme & lbl-ltop-lex-item-3rel &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [VOICE active],
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.BIND unbnd ].


;;   "Kari fryser p√• ryggen"
intrans-pp-detached-poss-verb-lexeme := verb-2rel-lexeme-straight &
  [ SYNSEM intrans-pp-detached-poss-synsem ].

;;   "Kari skrubber Jon p√• ryggen" (adv11)
trans-pp-arg1-detached-poss-verb-lexeme := verb-2rel-lexeme-straight &
  [ SYNSEM trans-pp-arg1-detached-poss-synsem ].

;;   "Kari kl√∏r seg p√• ryggen" (adv11)
trans-pp-arg1-detached-poss-refl-verb-lexeme := verb-2rel-lexeme-straight &
  [ SYNSEM trans-pp-arg1-detached-poss-refl-synsem ].

;;   "Jon kyler Kari en sn√∏ball i ryggen" (adv10)
ditrans-pp-arg1-2-detached-poss-verb-lexeme := verb-2rel-lexeme-straight &
  [ SYNSEM ditrans-pp-arg1-2-detached-poss-synsem ].


; love
subj-equi-doublobj-verb-lexeme := verb-lexeme &
[ SYNSEM subj-equi-doublobj-synsem ].

; tillate
obj-equi-verb-lexeme := verb-lexeme &
[ SYNSEM obj-equi-synsem ].

obj-equi-refl-verb-lexeme := verb-lexeme &
[ SYNSEM obj-equi-refl-synsem ].


; be
obj-equi-bare-verb-lexeme := verb-lexeme &
[ SYNSEM obj-equi-bare-synsem ].

; oppfordre
obj-equi-pp-verb-lexeme := verb-lexeme &
[ SYNSEM obj-equi-pp-synsem ].
; forplikte seg til
obj-equi-pp-refl-verb-lexeme := verb-lexeme &
[ SYNSEM obj-equi-pp-refl-synsem ].

; "overlate til Ola √•..." - job done by trans-obl + head-actv-verb-icomp-epon-phrase
;obl-equi-verb-lexeme := verb-lexeme &
;[ SYNSEM obl-equi-synsem ].

; se_5 "se ham komme"

; han f√∏ler seg komme
trans-secpred-rais-refl-from-verbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-refl-from-verbal-arg2-synsem ].

trans-secpred-rais-from-verbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-verbal-arg2-synsem ].

; "han viser seg √• komme"
trans-secpred-rais-refl-tosubj-from-infinmarked-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-refl-tosubj-from-infinmarked-arg1-synsem ].

; "han lar seg se"
;la-seg-se-verb-lexeme := lexeme & lbl-ltop-lex-item-3rel &
la-seg-se-verb-lexeme := verb-lexeme &
[ SYNSEM la-seg-se-synsem ].

la-sangen-synge-verb-lexeme := verb-lexeme &
[ SYNSEM la-sangen-synge-synsem ].

; fortone seg syk
trans-secpred-refl-argx-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-refl-argx-synsem ].

; "han synes meg √• komme", "han forekommer meg √• komme"
trans-secpred-rais-from-infinmarked-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-infinmarked-arg1-synsem ].

; for "jeg forutsetter ham √• komme", with pass: "han forutsettes √• komme"
trans-secpred-rais-from-infinmarked-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-infinmarked-arg2-synsem ].

; for "jeg forutsetter ham skutt", with pass: "han forutsettes skutt" - Complex Passive
trans-secpred-rais-from-perfmarked-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-perfmarked-arg2-synsem ].

; han synes meg syk
trans-secpred-rais-from-adj-or-som-arg1-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-adj-or-som-arg1-synsem ].

; anse (for/som)
;trans-secpred-rais-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
;[ SYNSEM trans-secpred-rais-from-nonverbal-arg2-synsem ].

trans-secpred-lexcause-pp-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-lexcause-pp-synsem ].
trans-secpred-refl-lexcause-pp-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-refl-lexcause-pp-synsem ].

trans-secpred-rais-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-nonverbal-arg2-plain-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CONT.HOOK.INDEX ad-event]>]].
trans-secpred-som-rais-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-nonverbal-arg2-plain-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.KEYS.KEY predcomp-som,
                                      LOCAL.CONT.HOOK.INDEX ad-event]>]].

trans-secpred-for-rais-from-nonverbal-arg2-inf-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-nonverbal-arg2-inf-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.KEYS.KEY for-rais ]>]].
trans-secpred-for-rais-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-nonverbal-arg2-plain-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.KEYS.KEY predcomp-for ]>]].

trans-secpred-til-rais-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-nonverbal-arg2-plain-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.KEYS.KEY predcomp-til ]>]].
trans-secpred-til-rais-from-nonverbal-arg2-inf-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-from-nonverbal-arg2-inf-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.KEYS.KEY til-rais ]>]].


; han synes en idiot
intrans-secpred-rais-from-n-arg1-verb-lexeme := top-verb-lexeme &
[ SYNSEM intrans-secpred-rais-from-n-arg1-synsem,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [] >,
			    SPEC <>]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    SYNSEM.LOCAL.HEAD-SUBJ-APPLIED -,
    SYNSEM.BIND unbnd].


; han synes meg en idiot
trans-secpred-rais-from-n-arg1-verb-lexeme := top-verb-lexeme &
[ SYNSEM trans-secpred-rais-from-n-arg1-synsem,
  SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    SYNSEM.LOCAL.HEAD-SUBJ-APPLIED -,
    SYNSEM.BIND unbnd].

; anse seg (som) syk
;trans-secpred-rais-refl-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
;[ SYNSEM trans-secpred-rais-refl-from-nonverbal-arg2-synsem ].


trans-secpred-adj-rais-refl-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-refl-from-nonverbal-arg2-plain-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD adj-reg ]>]].

trans-secpred-som-rais-refl-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-refl-from-nonverbal-arg2-plain-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.KEYS.KEY predcomp-som ]>]].

trans-secpred-til-rais-refl-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-refl-from-nonverbal-arg2-plain-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.KEYS.KEY predcomp-til ]>]].

trans-secpred-for-rais-refl-from-nonverbal-arg2-inf-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-refl-from-nonverbal-arg2-inf-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.KEYS.KEY for-rais ]>]].
trans-secpred-for-rais-refl-from-nonverbal-arg2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-rais-refl-from-nonverbal-arg2-plain-synsem &
         [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.KEYS.KEY for-rais ]>]].

; like any other verb, except that it lexically has two relations, the one extra for introducing the 'instantiate' EP reflecting the nominal predicative
trans-secpred-rais-from-nominal-arg2-verb-lexeme := top-verb-lexeme & lbl-ltop-lex-item-2rel & 
  [ SYNSEM.LOCAL.CAT.HEAD verb  & [VOICE active,
                                 KEYS.KEY mainvb],
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.BIND unbnd,
    SYNSEM trans-secpred-rais-from-nominal-arg2-synsem,
    SYNSEM.LKEYS.KEYREL.ARG0 #11,
    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11  ].

; kalle seg en tosk
trans-secpred-rais-refl-from-nominal-arg2-verb-lexeme := top-verb-lexeme & lbl-ltop-lex-item-2rel & 
  [ SYNSEM.LOCAL.CAT.HEAD verb  & [VOICE active,
                                 KEYS.KEY mainvb],
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CAT [VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >]],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.BIND unbnd,
    SYNSEM trans-secpred-rais-refl-from-nominal-arg2-synsem,
    SYNSEM.LKEYS.KEYREL.ARG0 #11,
    SYNSEM.LKEYS.ALTKEYREL.ARG0 #11 ].

; kalle ham en venn
;trans-secpred-rais-from-nominal-arg2-verb-lexeme := verb-lexeme &
;[ SYNSEM trans-secpred-rais-from-nominal-arg2-synsem ].

; kalle seg en tosk
;trans-secpred-rais-refl-from-nominal-arg2-verb-lexeme := verb-lexeme &
;[ SYNSEM trans-secpred-rais-refl-from-nominal-arg2-synsem ].


; hoppe_3
trans-secpred-arg1-x-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-arg1-x-synsem & 
         [LOCAL.CAT.VAL [COMPS < [],
                                 [ LOCAL.CAT.HEAD prep-or-adj-or-adv ]>]]].

;LH may7-11
trans-secpred-shift-arg1-x-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-shift-arg1-x-synsem & 
         [LOCAL.CAT.VAL [COMPS < [ LOCAL.CAT.HEAD prep-or-adj-or-adv ], [] >]]].

trans-secpred-arg1-x-refl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-arg1-x-refl-synsem & 
         [LOCAL.CAT.VAL [COMPS < [],
                                 [ LOCAL.CAT.HEAD prep-or-adj-or-adv]>]] ].

; there are 425 of these in lex.large-v.tdl - "fiffe seg opp"
trans-telicparticle-arg1-x-refl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-arg1-x-refl-synsem & 
         [LOCAL.CAT.VAL [COMPS < [],
                                 [ LOCAL.CAT.HEAD adv-reg & [KEYS.KEY pcl ],
                                   LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
                                   LOCAL.CONT.HOOK.XARG #1,
                                   LKEYS.KEYREL.ARG1 #1] >]] ].

trans-telicparticle-arg1-x-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-arg1-x-synsem & 
         [LOCAL.CAT.VAL [COMPS < [],
                                 [ LOCAL.CAT.HEAD adv-reg & [KEYS.KEY pcl ],
                                   LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
                                   LOCAL.CONT.HOOK.XARG #1,
                                   LKEYS.KEYREL.ARG1 #1] >]] ].

; LH 280411
trans-telicparticle-shift-arg1-x-verb-lexeme := verb-lexeme &
[ SYNSEM trans-particleshift-non-dir-synsem & 
         [LOCAL.CAT.VAL [COMPS < [ LOCAL.CAT.HEAD adv-reg & [KEYS.KEY pcl ],
                                   LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
                                   LOCAL.CONT.HOOK.XARG #1,
                                   LKEYS.KEYREL.ARG1 #1], [ LOCAL.CAT.HEAD nominal ] >]] ].

trans-particleshift-eventobj-verb-lexeme := verb-lexeme &
[ SYNSEM trans-particleshift-eventobj-synsem ].

trans-secpred-refl-dir-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-arg1-x-refl-synsem & 
         [LOCAL.CAT.VAL [COMPS < [],
                             [ LOCAL.CONT.HOOK.INDEX ad-event & [SORT path-related-motion]] >]] ].




; sparke ballen flat
trans-secpred-arg1-2-x-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-arg1-2-x-synsem ].

; sparke_secpred-refl
trans-secpred-arg1-2-x-refl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-secpred-arg1-2-x-refl-synsem ].

; sparke_particleshift
trans-particleshift-verb-lexeme := verb-lexeme &
[ SYNSEM trans-particleshift-synsem ].

; sparke_adjshift
trans-adjshift-verb-lexeme := verb-lexeme &
[ SYNSEM trans-adjshift-synsem ].

; kle p√• seg jakken
trans-ppshift-verb-lexeme := verb-lexeme &
[ SYNSEM trans-ppshift-synsem ].

;bre p√• Ola dynen
trans-ppshift-nonrefl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-ppshift-nonrefl-synsem ].

; kle p√• gutten 
trans-ppshift-implicit-verb-lexeme := verb-lexeme &
[ SYNSEM trans-ppshift-implicit-synsem ].
; kle p√• seg 
trans-ppshift-refl-implicit-verb-lexeme := verb-lexeme &
[ SYNSEM trans-ppshift-refl-implicit-synsem ].

; se_subord
trans-subord-verb-lexeme := verb-lexeme &
[ SYNSEM trans-subord-synsem ].

;lexeme & lbl-ltop-lex-item-3rel
trans-absinfsubord-verb-lexeme := verb-lexeme &
[ SYNSEM trans-absinfsubord-synsem ].

trans-arg1absinf-absinfsubord-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1absinf-absinfsubord-synsem ].

; muliggj√∏re det √•
trans-subord-expn-verb-lexeme := verb-lexeme &
[ SYNSEM trans-subord-expn-synsem ].

; sp√∏rre_tr-interr
trans-indirwhquest-verb-lexeme := verb-lexeme &
[ SYNSEM trans-indirwhquest-synsem ].

trans-indir-y-n-quest-verb-lexeme := verb-lexeme &
[ SYNSEM trans-indir-y-n-quest-synsem ].

trans-indir-interr-verb-lexeme := verb-lexeme &
[ SYNSEM trans-indir-interr-synsem ].

; overlate, vise_1, unne
ditrans-arg1-2-3-verb-lexeme := verb-lexeme & 
[ SYNSEM ditrans-arg1-2-3-synsem ].

; unne_1 (seg)
ditrans-arg1-2-3refl-verb-lexeme := verb-lexeme & 
[ SYNSEM ditrans-arg1-2-3refl-synsem ].

; vise
ditrans-decl-verb-lexeme := verb-lexeme & 
[ SYNSEM ditrans-decl-synsem ].

; forestille_subord-refl
ditrans-refl-decl-verb-lexeme := verb-lexeme & 
[ SYNSEM ditrans-refl-decl-synsem ].

; forespeile noen √• 
ditrans-equiinf-verb-lexeme := verb-lexeme & 
[ SYNSEM ditrans-equiinf-synsem ].

; foresette seg √•
ditrans-refl-equiinf-verb-lexeme := verb-lexeme & 
[ SYNSEM ditrans-refl-equiinf-synsem ].

; sp√∏rre hvorvidt_ditr-interr
ditrans-y-n-indirwhquest-verb-lexeme := verb-lexeme &
[ SYNSEM ditrans-y-n-nonrefl-indirwhquest-synsem].
;undre seg hvorvidt
ditrans-y-n-refl-indirwhquest-verb-lexeme := verb-lexeme &
[ SYNSEM ditrans-y-n-refl-indirwhquest-synsem].
; sp√∏rre_hvem_ditr-interr
ditrans-wh-indirwhquest-verb-lexeme := verb-lexeme &
[ SYNSEM ditrans-wh-nonrefl-indirwhquest-synsem].
;undre seg hvem
ditrans-wh-refl-indirwhquest-verb-lexeme := verb-lexeme &
[ SYNSEM ditrans-wh-refl-indirwhquest-synsem].

; sp√∏rre_ditr-interr
;ditrans-indirwhquest-verb-lexeme := verb-lexeme &
;[ SYNSEM ditrans-indirwhquest-synsem ].

; undre_subord-refl
;ditrans-refl-indirwhquest-verb-lexeme := verb-lexeme & 
;[ SYNSEM ditrans-refl-indirwhquest-synsem ].

ditrans-eventarg1-decl-verb-lexeme := verb-lexeme &
  [ SYNSEM ditrans-eventarg1-decl-synsem ].
ditrans-eventarg1-interr-verb-lexeme := verb-lexeme &
  [ SYNSEM ditrans-eventarg1-interr-synsem ].
ditrans-eventarg1-absinf-verb-lexeme := verb-lexeme &
  [ SYNSEM ditrans-eventarg1-absinf-synsem ].
ditrans-eventarg1decl-eventarg2decl-verb-lexeme := verb-lexeme &
  [ SYNSEM ditrans-eventarg1decl-eventarg2decl-synsem ].
ditrans-eventarg1decl-eventarg2interr-verb-lexeme := verb-lexeme &
  [ SYNSEM ditrans-eventarg1decl-eventarg2interr-synsem ].
ditrans-eventarg1interr-eventarg2decl-verb-lexeme := verb-lexeme &
  [ SYNSEM ditrans-eventarg1interr-eventarg2decl-synsem ].
ditrans-eventarg1interr-eventarg2interr-verb-lexeme := verb-lexeme &
  [ SYNSEM ditrans-eventarg1interr-eventarg2interr-synsem ].

; suse, regne
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
;(was verb-general-lexeme)
impersonal-presentational-verb-lexeme := verb-2rel-arg12a-lexeme &
  [ SYNSEM impersonal-presentational-synsem,
    SYNSEM.LOCAL.CAT.HEAD verb  & [VOICE active,
                                   KEYS.KEY mainvb]].

; kvekke, ise, kile, kime
;impersonal-presentational-obl-verb-lexeme := verb-lexeme &
;  [ SYNSEM impersonal-presentational-obl-synsem ].

; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
impersonal-presentational-obl-verb-lexeme := verb-2rel-arg12aObl-lexeme &
  [ SYNSEM impersonal-presentational-obl-synsem ].

; tykne til, klarne opp
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
impersonal-presentational-telicparticle-verb-lexeme := verb-2rel-arg12ax-lexeme &
  [ SYNSEM impersonal-presentational-telicparticle-synsem ].

; verb-general
; sitte, v√¶re_6
;subject-presentational-verb-lexeme := lexeme & lbl-ltop-lex-item-2rel &
;  [ SYNSEM subject-presentational-synsem,
;    SYNSEM.LOCAL.CAT.HEAD verb  & [VOICE active,
;                                   KEYS.KEY mainvb]].

subject-presentational-verb-lexeme := verb-2rel-arg12a1-lexeme &
  [ SYNSEM subject-presentational-synsem,
    SYNSEM.LOCAL.CAT.HEAD verb  & [VOICE active,
                                   KEYS.KEY mainvb]].

subject-dir-presentational-verb-lexeme := verb-2rel-arg12a1-lexeme &
  [ SYNSEM subject-dir-presentational-synsem,
    SYNSEM.LOCAL.CAT.HEAD verb  & [VOICE active,
                                   KEYS.KEY mainvb]].

; verb-general
; rusle_4, komme_pres
; see experiment 021012
;subject-dir-presentational-verb-lexeme := verb-2rel-arg12a1-lexeme &
;  [ SYNSEM subject-dir-presentational-synsem ].

; "det trenger seg fram en mann"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
subject-presentational-secpred-refl-dir-verb-lexeme := verb-2rel-arg12a12-lexeme &
  [ SYNSEM subject-presentational-secpred-refl-dir-synsem ].

; verb-general
; "det bor mange i Moss"
subject-locobl-presentational-verb-lexeme := verb-2rel-arg12a1Obl-lexeme &
  [ SYNSEM subject-locobl-presentational-synsem ].

; "det hopper opp en katt"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
subject-presentational-telicparticle-verb-lexeme := verb-2rel-arg12a1x-lexeme &
  [ SYNSEM subject-presentational-telicparticle-synsem ].

; "det smetter en katt ut"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
subject-presentational-telicparticle-prtcllast-verb-lexeme := verb-2rel-arg12a1x-lexeme &
  [ SYNSEM subject-presentational-telicparticle-prtcllast-synsem ].

; tilkomme, vente "det venter meg en ulykke"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
io-presentational-verb-lexeme := verb-2rel-arg12a12-lexeme &
  [ SYNSEM io-presentational-synsem ].

;  "det setter seg en gutt"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
subject-presentational-refl-verb-lexeme := verb-2rel-arg12a12-lexeme &
  [ SYNSEM subject-presentational-refl-synsem ].

; LH 260411 - see TODO for synsem
;  "det smyger seg en gutt"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
subject-dir-presentational-refl-verb-lexeme := verb-2rel-arg12a12-lexeme &
  [ SYNSEM subject-dir-presentational-refl-synsem ].

;  "det oppholder seg en gutt i hagen"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
subject-locobl-presentational-refl-verb-lexeme := verb-2rel-arg12a12x-lexeme &
  [ SYNSEM subject-locobl-presentational-refl-synsem ].


; forekomme, foresveve - "det forekommer meg at han kommer/om han kommer"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
io-epon-verb-lexeme := verb-2rel-arg12a12-lexeme &
  [ SYNSEM io-epon-synsem ].
; "det viser seg at han kommer/om han kommer"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
io-refl-epon-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM io-refl-epon-synsem ].

; forekomme, foresveve - "det forekommer meg at han kommer/om han kommer"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
io-epon-wh-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM io-epon-wh-synsem ].
; "det viser seg at han kommer/om han kommer"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
io-refl-epon-wh-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM io-refl-epon-wh-synsem ].

; "det tar to timer √• g√• hit", "det koster fem kroner √•..."
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
meas-epon-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM meas-epon-synsem ].

; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
meas-io-epon-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM meas-io-epon-synsem ].

; forekomme, hende - "det forekommer/hender at han kommer"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-synsem ].

; "det sp√∏rs om han kommer"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-indirwhquest-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-indirwhquest-synsem ].

; not a real type
; "det (expl) beror p√• om han kommer/at han kommer"
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-oblique-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-oblique-synsem ].

; det beror p√• deg at/om han kommer
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-decl-and-yn-pp-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-decl-and-yn-pp-synsem ].
; det beror p√• deg hvem som kommer
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-wh-pp-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-wh-pp-synsem ].

; det beror p√• om du kommer at/om han kommer
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-decl-and-yn-decl-and-yn-pp-clause-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-decl-and-yn-decl-and-yn-pp-clause-synsem ].
; det beror p√• om du kommer hvem som kommer
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-decl-and-yn-wh-pp-clause-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-decl-and-yn-wh-pp-clause-synsem ].
; det beror p√• hvem som kommer at/om han kommer
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-wh-decl-and-yn-pp-clause-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-wh-decl-and-yn-pp-clause-synsem ].
; det beror p√• hvem som kommer hvem som vinner
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-wh-wh-pp-clause-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-wh-wh-pp-clause-synsem ].

; det h√∏rer med at ...
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-particle-DECL-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-particle-DECL-synsem ].

; det h√∏rer med √• ...
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-particle-inf-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-particle-inf-synsem ].

; det V med om ...
; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-particle-interr-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-particle-interr-synsem ].

; coming from presentational-synsem-2, therefore replacing verb-lexeme by lexeme, and need to suplement that in the lexeme specification:
epon-inf-verb-lexeme := verb-2rel-lexeme &
  [ SYNSEM epon-inf-synsem ].

trans-eventarg1-decl-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1-decl-synsem ].

trans-eventarg1-interr-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1-interr-synsem ].

trans-eventarg1-absinf-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1-absinf-synsem  ].

trans-eventarg1-decl-obl-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1-decl-obl-synsem ].

trans-eventarg1-interr-obl-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1-interr-obl-synsem ].

trans-eventarg1decl-eventarg2decl-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1decl-eventarg2decl-synsem ].
trans-eventarg1decl-eventarg2interr-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1decl-eventarg2interr-synsem ].
trans-eventarg1interr-eventarg2decl-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1interr-eventarg2decl-synsem ].
trans-eventarg1interr-eventarg2interr-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1interr-eventarg2interr-synsem ].

trans-eventarg1decl-eventobldecl-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1decl-eventobldecl-synsem ].
trans-eventarg1decl-eventoblinterr-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1decl-eventoblinterr-synsem ].
trans-eventarg1interr-eventobldecl-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1interr-eventobldecl-synsem ]. 
trans-eventarg1interr-eventoblinterr-verb-lexeme := verb-lexeme &
  [ SYNSEM trans-eventarg1interr-eventoblinterr-synsem ]. 


copula-lexeme := verb-general-lexeme &
   [ SYNSEM.LOCAL.CAT.HEAD [VOICE active,
                            KEYS.KEY mainvb]].

; v√¶re, bli ("suru")
copula-standard-verb-lexeme-sup := copula-lexeme &
   [ SYNSEM copula-standard-synsem ].
;LH may9-11
copula-predparticle-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-predparticle-synsem ].
copula-predprtcl-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-predprtcl-synsem ].

copula-standard-verb-lexeme := copula-standard-verb-lexeme-sup.
copula-bli-standard-verb-lexeme := copula-standard-verb-lexeme-sup &
 [ SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.DERIVED-HEAD - ] > ].

; v√¶re, bli ("aru")
copula-locpp-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-locpp-synsem ].
copula-locpp-with-nonepon-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-locpp-with-nonepon-synsem ].
copula-dirpp-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-dirpp-synsem ].
; v√¶re, bli ("aru")
copula-locadv-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-locadv-synsem ].

; v√¶re_abs
copula-standard-abs-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-standard-abs-synsem ].

copula-tough-abs-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-tough-abs-synsem ].

; v√¶re_abs-nonepon-decl
copula-adj-abs-with-nonepon-decl-verb-lexeme := copula-lexeme &
  [ SYNSEM copula-adj-abs-with-nonepon-decl-synsem ].

; v√¶re_abs-nonepon-quest
copula-adj-abs-with-nonepon-quest-verb-lexeme := copula-lexeme &
  [ SYNSEM copula-adj-abs-with-nonepon-quest-synsem ].

; v√¶re_copnom, bli_copnom
copula-nom-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-nom-synsem ].

; ... er at...
copula-clause-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-clause-synsem ].

; ...er √• ...
copula-absinf-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-absinf-synsem ].

; √• ...er √• ...
copula-arg1absinf-absinf-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-arg1absinf-absinf-synsem ].

; ... er hvorvidt/hva...
copula-indirwhquest-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-indirwhquest-synsem ].

copula-indir-y-n-quest-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-indir-y-n-quest-synsem ].

copula-noun-with-sudecl-nonepon-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-noun-with-sudecl-nonepon-synsem ].

copula-noun-with-suYN-nonepon-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-noun-with-suYN-nonepon-synsem ].

copula-noun-with-suWH-nonepon-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-noun-with-suWH-nonepon-synsem ].

copula-noun-with-suabsinf-nonepon-verb-lexeme := copula-lexeme &
   [ SYNSEM copula-noun-with-suabsinf-nonepon-synsem ].

¬§¬§¬§ := inflection.


;;; POTENTIAL LEXEMES, SEMANTICALLY MORE SPECIFIED, and NOT
;;; DESCENDING FROM predsort.tdl

; peke
intrans-arg1orient-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-arg1orient-synsem ].

; fort√¶re
trans-arg1-2tel-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1-2tel & [ LOCAL.CAT.VAL [ COMPS < [] >]] ].

; spise, vinne
trans-arg1-2tel-opt-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1-2tel & [ LOCAL.CAT.VAL [ COMPS < [] >]] ].

; fortsette_2, g√•_3, l√∏pe_2, ta_3, rusle_2, flyte_2, hoppe_2
trans-arg1dir-2length-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1dir-2length-synsem ].

trans-arg1dir-2-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1dir-2-synsem ].

trans-arg1dir-2refl-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1dir-2refl-synsem ].


;;; SEMANTICALLY ENRICHED TYPES
; verbs fitting these types are given in lex2.semlab.tdl, and depend on
; the predsort.tdl file
;; the i-synsemers
;; first types that can be subtypes of intrans-arg1-...
posture-verb-lexeme := verb-lexeme &
  [ SYNSEM posture-synsem ].
arrow-pointing-verb-lexeme := verb-lexeme &
  [ SYNSEM arrow-pointing-synsem ].
road-going-verb-lexeme := verb-lexeme &
  [ SYNSEM road-going-synsem ].
tour-going-verb-lexeme := verb-lexeme &
  [ SYNSEM tour-going-synsem ].
locomotion-verb-lexeme := verb-lexeme &
  [ SYNSEM locomotion-synsem ].

;; then types that can be subtypes of trans-arg1-2-...
directing-arrow-verb-lexeme := verb-lexeme &
  [ SYNSEM directing-arrow-synsem ].
directing-line-verb-lexeme := verb-lexeme &
  [ SYNSEM directing-line-synsem ].
directing-tour-verb-lexeme := verb-lexeme &
  [ SYNSEM directing-tour-synsem ].
ejecting-verb-lexeme := verb-lexeme &
  [ SYNSEM ejection-synsem ].

line-follow-line-verb-lexeme := verb-lexeme &
  [ SYNSEM line-follow-line-synsem ].
line-crossing-line-verb-lexeme := verb-lexeme &
  [ SYNSEM line-crossing-line-synsem ].
begleiten-verb-lexeme := verb-lexeme &
  [ SYNSEM begleiten-synsem ].
crossing-locomotors-verb-lexeme := verb-lexeme &
  [ SYNSEM crossing-locomotors-synsem ].

init-verb-lexeme := verb-lexeme &
  [ SYNSEM init-synsem ].
init-und-verb-lexeme := verb-lexeme &
  [ SYNSEM init-und-synsem ].
init-dat-verb-lexeme := verb-lexeme &
  [ SYNSEM init-dat-synsem ].
init-und-dat-verb-lexeme := verb-lexeme &
  [ SYNSEM init-und-dat-synsem ].
und-verb-lexeme := verb-lexeme &
  [ SYNSEM und-synsem ].
und-dat-verb-lexeme := verb-lexeme &
  [ SYNSEM und-dat-synsem ].
dat-verb-lexeme := verb-lexeme &
  [ SYNSEM dat-synsem ].

init-locomotion-verb-lexeme := verb-lexeme &
  [ SYNSEM init-locomotion-synsem ].


; broken ARG1 link -db jan05; 
;; other potential predsort.tdl-dependents, shaded in lexicon.tdl,
; but not present in verb-lex.tdl
basic-intrans-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-arg1-synsem & [ LKEYS.KEYREL posture-svh-rel]].
ejection-verb-lexeme := verb-lexeme &
[ SYNSEM trans-arg1-2ejection ].
intrans-dir-verb-lexeme := verb-lexeme &
[ SYNSEM intrans-arg1dir-synsem ].



;;;;; IMPERATIVE

; SYNSEM.LOCAL.OBJ-DEL-APPLIED + is in order to avoid feeding with obj-del rules
imperative-verb-lexeme := const-ltol-rule &
  [ C-CONT.RELS <! 2nd-pers-pron-rel & [PRED "addressee-rel",
					ARG0 #2 & [ PNG.NG masc ],
                                        LBL #3],
                               contextual-q-rel & [ARG0 #2,
                                                   RSTR #4] !>,
    C-CONT.HCONS #8 & <! [HARG #4,
                           LARG #3 ] !>,
    SYNSEM.LOCAL.CAT.HEAD verb-all & [ COP #10,
                                       VOICE active,
				       INV -],
    SYNSEM.LOCAL.CONT.HOOK #1, 
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD imperative,
    SYNSEM.LOCAL.CONT.HCONS #8,
    SYNSEM.LOCAL.CONT.RELS <! [],[], [] !>,
    SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE +,
;    SYNSEM.LOCAL.CAT.VAL.SPR olist,  - LH250612, outcomment to allow 'han kommer ikke', 'han unner henne ikke boken'
    SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    SYNSEM.LOCAL.CAT.VAL.COMPS #9,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #19,
    SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.NEED-IMP-UNARY +,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
    DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ COP #10 ],
    DTR.SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE -,
    DTR.SYNSEM.LOCAL.CAT.HEAD.VOICE active,
    DTR.SYNSEM.LOCAL.CONT.HOOK #1,
    DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CONT.HOOK.INDEX #2 ]>,
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #9 & list,
    DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #19,
    DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>].


;;;;;;;;;;;;; NOUN ITEMS ;;;;;;;;;;;;;;;;;

noun-item := lexeme &
  [ INFLECTION [ GEND gen,
                 NUMB num,
                 DEFINITENESS definiteness ]].
m-noun := noun-item &
  [ INFLECTION [ GEND m ]].
f-noun := noun-item &
  [ INFLECTION [ GEND f ]].
n-noun := noun-item &
  [ INFLECTION [ GEND n ]].
sing-noun := noun-item &
  [ INFLECTION [ NUMB sing ]].
plur-noun := noun-item &
  [ INFLECTION [ NUMB plur ]].
def-noun := noun-item &
  [ INFLECTION [ DEFINITENESS def ]].
indef-noun := noun-item &
  [ INFLECTION [ DEFINITENESS ind ]].

m-sing-def-noun := m-noun & sing-noun & def-noun.
m-sing-indef-noun := m-noun & sing-noun & indef-noun.
m-plur-def-noun := m-noun & plur-noun & def-noun.
m-plur-indef-noun := m-noun & plur-noun & indef-noun.
f-sing-def-noun := f-noun & sing-noun & def-noun.
f-sing-indef-noun := f-noun & sing-noun & indef-noun.
f-plur-def-noun := f-noun & plur-noun & def-noun.
f-plur-indef-noun := f-noun & plur-noun & indef-noun.
n-sing-def-noun := n-noun & sing-noun & def-noun.
n-sing-indef-noun := n-noun & sing-noun & indef-noun.
n-plur-def-noun := n-noun & plur-noun & def-noun.
n-plur-indef-noun := n-noun & plur-noun & indef-noun.

m-sing-noun := m-noun & sing-noun.
m-plur-noun := m-noun & plur-noun.
f-sing-noun := f-noun & sing-noun.
f-plur-noun := f-noun & plur-noun.
n-sing-noun := n-noun & sing-noun.
n-plur-noun := n-noun & plur-noun.

m-def-noun := m-noun & def-noun.
m-indef-noun := m-noun & indef-noun.
f-def-noun := f-noun & def-noun.
f-indef-noun := f-noun & indef-noun.
n-def-noun := n-noun & def-noun.
n-indef-noun := n-noun & indef-noun.

sing-def-noun := sing-noun & def-noun.
plur-def-noun := plur-noun & def-noun.
sing-indef-noun := sing-noun & indef-noun.
plur-indef-noun := plur-noun & indef-noun.



;;;;;;;;;;; NOUN LEXEMES;;;;;;;;;;;

noun-lxm := lexeme & no-slash &
  [ SYNSEM [ LOCAL.CAT.HEAD comm-noun,
;	     LOCAL.INHER-WH -,
	     NON-LOCAL.SLASH 0-dlist & [ LIST < > ]]].

;noun-lexeme := lbl-ltop-lex-item & rule & lexeme &
noun-lexeme := lbl-ltop-lex-item & rule & noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD comm-noun & [DEGREE positive,
				       EXPLETIVE -],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ list,
                           SPR list,
                           SPEC list,
                           COMPS <>,
                           ICOMPS list],
    SYNSEM.LOCAL.AGR.PNG.PERS thirdpers,
    SYNSEM.LKEYS.KEYREL relation,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.DERIVED-HEAD -,
    SYNSEM.LOCAL.BINDING.BOUND -,
    SYNSEM.LOCAL.BND-MOUNTABLE <>,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    INFLECTION #1,
    INFL-MORPH #1,
    EXTRINSIC-ORD status-noun-infl-lexeme ].

;neut-noun-lxm := noun-lexeme & n-noun &
;  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
;fem-noun-lxm := noun-lexeme & f-noun &
;  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem ].
;masc-noun-lxm := noun-lexeme & m-noun &
;  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc ].
neut-noun-lxm := noun-lexeme &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
fem-noun-lxm := noun-lexeme & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem ].
masc-noun-lxm := noun-lexeme & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc ].

;sg-indef-noun-lxm := noun-lexeme & sing-indef-noun &
;  [ SYNSEM.LOCAL.CAT.HEAD [DEFINITE - ],
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg ].

;; nb-infl
mascorneut-noun-lxm := noun-lexeme &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut-or-masc ].
mascorfem-noun-lxm := noun-lexeme &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem ].

; dummy exception type from Troll
ic-gend-noun-lxm := noun-lexeme.


; this type, with its immediate descendants, is in order to distinguish all the noun lexemes in lex4.na-lrg.tdl from measure-noun-lxm and its descendants, so that these 55 000 items do not all take part in rules designed for measure-nps. All of the types dir-, relanim-, reganim-, relinan- and reginan- have SORT specifications which are subtypes of 'referential-thing', hence when one day all 55 000 are annotated with regard to these options, they stay within the general large category, even though we are not explicitly subtyping them all under ref-noun-lexemes. In other words, once we glue in 'lanim-', 'ganim-', 'linan-' and 'ginan-' behind the 're' in 'neut-re-noun-lxm' etc., the ref-noun-lexeme with its immediate descendants will cease to play a role in the system. But since that day may never come, it will be a useful temporary type to have.

ref-noun-lexeme := noun-lexeme &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT referential-thing ].

neut-re-noun-lxm := ref-noun-lexeme &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut ].
fem-re-noun-lxm := ref-noun-lexeme & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG fem ].
masc-re-noun-lxm := ref-noun-lexeme & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc ].
mascorneut-re-noun-lxm := ref-noun-lexeme &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG neut-or-masc ].
mascorfem-re-noun-lxm := ref-noun-lexeme &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG masc-or-fem ].
x-re-noun-lxm := ref-noun-lexeme.

; referred to in 'measure-np' rules and lexemes:
;( no further subtypes here - but 'measure-unit' has its subtypes, and the
; rule np-mod-vp uses one of them - 'time-item' - to restrict the NP. 
; As long as no further subtypes of measure-noun-lxm are distinguished, this
; rule will still allow "*ankom to meter", alongside "ankom s√∏ndag"
measure-noun-lxm := noun-lexeme &
  [ SYNSEM [LOCAL.CONT.HOOK hook & [INDEX.SORT measure-unit ]],
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY measurnoun].

measure-length-noun-lxm := measure-noun-lxm &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT length-unit,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY measnoun ].
measure-time-noun-lxm-sup := measure-noun-lxm &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT time-item,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY meastimenoun ].
; removing ,
;    SYNSEM.LOCAL.CAT.VAL.SPEC 1-list, to get 'han veier 5 kg'
measure-weight-noun-lxm := measure-noun-lxm &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT weight-unit,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY measnoun  ].
measure-vol-noun-lxm := measure-noun-lxm &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT volume-unit,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY measnoun,
    SYNSEM.LOCAL.CAT.VAL.SPEC 1-list  ].
measure-amount-noun-lxm := measure-noun-lxm &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT amount-unit,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY measnoun  ].

measure-time-noun-lxm := measure-time-noun-lxm-sup.
;measure-specifictime-noun-lxm := measure-time-noun-lxm-sup &
;  [EXTRINSIC-ORD not-eligbl-for-noun-infl-lexeme].
measure-specifictime-noun-lxm := measure-time-noun-lxm-sup &
  [ SYNSEM.LOCAL.CAT.HEAD.DEF + ].

masc-measure-length-noun-lxm := measure-length-noun-lxm & masc-noun-lxm.
fem-measure-length-noun-lxm := measure-length-noun-lxm & fem-noun-lxm.
neut-measure-length-noun-lxm := measure-length-noun-lxm & neut-noun-lxm.
mascorneut-measure-length-noun-lxm := measure-length-noun-lxm & mascorneut-noun-lxm.
mascorfem-measure-length-noun-lxm := measure-length-noun-lxm & mascorfem-noun-lxm.

masc-measure-time-noun-lxm := measure-time-noun-lxm & masc-noun-lxm.
fem-measure-time-noun-lxm := measure-time-noun-lxm & fem-noun-lxm.
neut-measure-time-noun-lxm := measure-time-noun-lxm & neut-noun-lxm.
mascorneut-measure-time-noun-lxm := measure-time-noun-lxm & mascorneut-noun-lxm.
masc-measure-specifictime-noun-lxm := measure-specifictime-noun-lxm & masc-noun-lxm.
mascorfem-measure-time-noun-lxm := measure-time-noun-lxm & mascorfem-noun-lxm.

masc-measure-weight-noun-lxm := measure-weight-noun-lxm & masc-noun-lxm.
fem-measure-weight-noun-lxm := measure-weight-noun-lxm & fem-noun-lxm.
neut-measure-weight-noun-lxm := measure-weight-noun-lxm & neut-noun-lxm.
mascorneut-measure-weight-noun-lxm := measure-weight-noun-lxm & mascorneut-noun-lxm.

masc-measure-vol-noun-lxm := measure-vol-noun-lxm & masc-noun-lxm.
fem-measure-vol-noun-lxm := measure-vol-noun-lxm & fem-noun-lxm.
neut-measure-vol-noun-lxm := measure-vol-noun-lxm & neut-noun-lxm.
mascorneut-measure-vol-noun-lxm := measure-vol-noun-lxm & mascorneut-noun-lxm.
mascorfem-measure-vol-noun-lxm := measure-vol-noun-lxm & mascorfem-noun-lxm.

masc-measure-amount-noun-lxm := measure-amount-noun-lxm & masc-noun-lxm.
fem-measure-amount--noun-lxm := measure-amount-noun-lxm & fem-noun-lxm.
neut-measure-amount-noun-lxm := measure-amount-noun-lxm & neut-noun-lxm.
mascorneut-measure-amount-noun-lxm := measure-amount-noun-lxm & mascorneut-noun-lxm.
mascorfem-measure-amount-noun-lxm := measure-amount-noun-lxm & mascorfem-noun-lxm.



;masc-measure-noun-lxm := masc-noun-lxm & measure-noun-lxm.
;neut-measure-noun-lxm := neut-noun-lxm & measure-noun-lxm.
;fem-measure-noun-lxm := fem-noun-lxm & measure-noun-lxm.
;mascorneut-measure-noun-lxm := mascorneut-noun-lxm & measure-noun-lxm.

; relevant for 'detached possessors' constructions:
;body-part-noun-lxm := noun-lexeme &
;  [ SYNSEM [LOCAL.CONT.HOOK.INDEX.SORT body-part ] ].
;masc-bodypart-noun-lxm := masc-noun-lxm & body-part-noun-lxm.
;neut-bodypart-noun-lxm := neut-noun-lxm & body-part-noun-lxm.
;fem-bodypart-noun-lxm := fem-noun-lxm & body-part-noun-lxm.

; this is the 'nothing special' type of noun. The way the body-part and
; measure nouns work, there are certain rules in which only they
; take part. For any noun non-eligible, it only need an exclusive
; marking - 'SORT full-thing' is such a marking, and also 'SORT measure-
; unit' relative to the rules requiring body part, and vice versa.
; By assumption, no rule will require of its undergoers that they be
;'SORT full-thing'.

reg-noun-lxm := noun-lexeme &
  [ SYNSEM [LOCAL.CONT.HOOK hook & [INDEX.SORT full-thing ]],
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absnoun ].

anim-noun-lxm := noun-lexeme &
  [ SYNSEM [LOCAL.CONT.HOOK.INDEX.SORT anim-thing ],
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY animnoun ].
inanim-noun-lxm := noun-lexeme &
  [ SYNSEM [LOCAL.CONT.HOOK.INDEX.SORT inan-thing ],
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY inanimnoun ].

; a logical step - abs-noun-lxm (cf the type 'absnoun' under KEY) is
; formally bypassed

reg-anim-noun-lxm := reg-noun-lxm & anim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY reganim ].
reg-inanim-noun-lxm := reg-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY reginan ].

masc-reganim-noun-lxm := masc-noun-lxm & reg-anim-noun-lxm.
masc-reginan-noun-lxm := masc-noun-lxm & reg-inanim-noun-lxm.
fem-reganim-noun-lxm := fem-noun-lxm & reg-anim-noun-lxm.
fem-reginan-noun-lxm := fem-noun-lxm & reg-inanim-noun-lxm.
neut-reganim-noun-lxm := neut-noun-lxm & reg-anim-noun-lxm.
neut-reginan-noun-lxm := neut-noun-lxm & reg-inanim-noun-lxm.
mascorneut-reganim-noun-lxm := mascorneut-noun-lxm & reg-anim-noun-lxm.
mascorneut-reginan-noun-lxm := mascorneut-noun-lxm & reg-inanim-noun-lxm.
mascorfem-reganim-noun-lxm := mascorfem-noun-lxm & reg-anim-noun-lxm.
mascorfem-reginan-noun-lxm := mascorfem-noun-lxm & reg-inanim-noun-lxm.

; for nouns like "vei" 'road' - not generalized
;dir-noun-lxm := noun-lexeme &
;  [ SYNSEM nounsynsem-arg0dir & [LOCAL.CONT.HOOK.INDEX.SORT one-dim-thing,
;                                 LOCAL.CAT.HEAD.KEYS.KEY dirnoun ] ].

dir-noun-lxm := noun-lexeme &
  [ SYNSEM [LOCAL.CONT.HOOK.INDEX.SORT one-dim-thing,
            LOCAL.CONT.HOOK.DIRARG #1,
            LOCAL.CAT.HEAD.KEYS.KEY dirnoun,
            LKEYS.KEYREL.ARG0 #1 ] ].

masc-dir-noun-lxm := dir-noun-lxm & masc-noun-lxm.
fem-dir-noun-lxm := dir-noun-lxm & fem-noun-lxm.
neut-dir-noun-lxm := dir-noun-lxm & neut-noun-lxm.
mascorfem-dir-noun-lxm := dir-noun-lxm & mascorfem-noun-lxm.
mascorneut-dir-noun-lxm := dir-noun-lxm & mascorneut-noun-lxm.

;body-part is one subtype of this, event-nouns another - not going to that
; detail yet ('role-noun-lexeme' would be one way of continuing - see below)
relation-noun-lxm-sup := noun-lexeme &
  [ SYNSEM [LOCAL.CONT.HOOK hook ],
    SYNSEM [LOCAL.CONT.HOOK.INDEX.SORT relatum,
            LOCAL.CAT.HEAD.KEYS.KEY relnoun] ].

relation-noun-lxm := relation-noun-lxm-sup &
  [ SYNSEM.LOCAL.CAT.VAL.ICOMPS <> ].

rel-anim-noun-lxm := relation-noun-lxm & anim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relanim ].
rel-inanim-noun-lxm := relation-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relinan ].
fact-inanim-noun-lxm := relation-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY fact ].

masc-relanim-noun-lxm := masc-noun-lxm & rel-anim-noun-lxm.
masc-relinan-noun-lxm := masc-noun-lxm & rel-inanim-noun-lxm.
masc-factinan-noun-lxm := masc-noun-lxm & fact-inanim-noun-lxm.
fem-relanim-noun-lxm := fem-noun-lxm & rel-anim-noun-lxm.
fem-relinan-noun-lxm := fem-noun-lxm & rel-inanim-noun-lxm.
fem-factinan-noun-lxm := fem-noun-lxm & fact-inanim-noun-lxm.
neut-relanim-noun-lxm := neut-noun-lxm & rel-anim-noun-lxm.
neut-relinan-noun-lxm := neut-noun-lxm & rel-inanim-noun-lxm.
neut-factinan-noun-lxm := neut-noun-lxm & fact-inanim-noun-lxm.
mascorneut-relanim-noun-lxm := mascorneut-noun-lxm & rel-anim-noun-lxm.
mascorneut-relinan-noun-lxm := mascorneut-noun-lxm & rel-inanim-noun-lxm.
mascorneut-factinan-noun-lxm := mascorneut-noun-lxm & fact-inanim-noun-lxm.
mascorfem-relanim-noun-lxm := mascorfem-noun-lxm & rel-anim-noun-lxm.
mascorfem-relinan-noun-lxm := mascorfem-noun-lxm & rel-inanim-noun-lxm.
mascorfem-factinan-noun-lxm := mascorfem-noun-lxm & fact-inanim-noun-lxm.


relation-obl-noun-lxm-sup := relation-noun-lxm-sup &
  [ SYNSEM.LOCAL.KEY-SPEC #1,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY #1,
                                                  SELECTED +]]> ].

;; lhNov08: NB! the KEYS.KEY values need to be adjusted!
relation-obl-noun-lxm := relation-obl-noun-lxm-sup &
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY preprel ]]> ].

rel-anim-obl-noun-lxm := relation-obl-noun-lxm & anim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relanim ].
rel-inanim-obl-noun-lxm := relation-obl-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relinan ].
fact-inanim-obl-noun-lxm := relation-obl-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY fact ].

masc-relanim-obl-noun-lxm := masc-noun-lxm & rel-anim-obl-noun-lxm.
masc-relinan-obl-noun-lxm := masc-noun-lxm & rel-inanim-obl-noun-lxm.
masc-factinan-obl-noun-lxm := masc-noun-lxm & fact-inanim-obl-noun-lxm.
fem-relanim-obl-noun-lxm := fem-noun-lxm & rel-anim-obl-noun-lxm.
fem-relinan-obl-noun-lxm := fem-noun-lxm & rel-inanim-obl-noun-lxm.
fem-factinan-obl-noun-lxm := fem-noun-lxm & fact-inanim-obl-noun-lxm.
neut-relanim-obl-noun-lxm := neut-noun-lxm & rel-anim-obl-noun-lxm.
neut-relinan-obl-noun-lxm := neut-noun-lxm & rel-inanim-obl-noun-lxm.
neut-factinan-obl-noun-lxm := neut-noun-lxm & fact-inanim-obl-noun-lxm.
mascorfem-relanim-obl-noun-lxm := mascorfem-noun-lxm & rel-anim-obl-noun-lxm.
mascorfem-relinan-obl-noun-lxm := mascorfem-noun-lxm & rel-inanim-obl-noun-lxm.
mascorfem-factinan-obl-noun-lxm := mascorfem-noun-lxm & fact-inanim-obl-noun-lxm.


relation-obl-decl-noun-lxm := relation-obl-noun-lxm-sup &
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                             CONT.HOOK.INDEX.E.TENSE finite],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY clse ]]> ].

rel-anim-obl-decl-noun-lxm := relation-obl-decl-noun-lxm & anim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relanim ].
rel-inanim-obl-decl-noun-lxm := relation-obl-decl-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relinan ].
fact-inanim-obl-decl-noun-lxm := relation-obl-decl-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY fact ].

masc-relanim-obl-decl-noun-lxm := masc-noun-lxm & rel-anim-obl-decl-noun-lxm.
masc-relinan-obl-decl-noun-lxm := masc-noun-lxm & rel-inanim-obl-decl-noun-lxm.
masc-factinan-obl-decl-noun-lxm := masc-noun-lxm & fact-inanim-obl-decl-noun-lxm.
fem-relanim-obl-decl-noun-lxm := fem-noun-lxm & rel-anim-obl-decl-noun-lxm.
fem-relinan-obl-decl-noun-lxm := fem-noun-lxm & rel-inanim-obl-decl-noun-lxm.
fem-factinan-obl-decl-noun-lxm := fem-noun-lxm & fact-inanim-obl-decl-noun-lxm.
neut-relanim-obl-decl-noun-lxm := neut-noun-lxm & rel-anim-obl-decl-noun-lxm.
neut-relinan-obl-decl-noun-lxm := neut-noun-lxm & rel-inanim-obl-decl-noun-lxm.
neut-factinan-obl-decl-noun-lxm := neut-noun-lxm & fact-inanim-obl-decl-noun-lxm.
mascorfem-relanim-obl-decl-noun-lxm := mascorfem-noun-lxm & rel-anim-obl-decl-noun-lxm.
mascorfem-relinan-obl-decl-noun-lxm := mascorfem-noun-lxm & rel-inanim-obl-decl-noun-lxm.
mascorfem-factinan-obl-decl-noun-lxm := mascorfem-noun-lxm & fact-inanim-obl-decl-noun-lxm.


relation-obl-inf-noun-lxm := relation-obl-noun-lxm-sup &
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                             CONT.HOOK.INDEX.E.TENSE infin],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY clse ],
				  LOCAL.CAT.HEAD infin-comp]> ].

rel-anim-obl-inf-noun-lxm := relation-obl-inf-noun-lxm & anim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relanim ].
rel-inanim-obl-inf-noun-lxm := relation-obl-inf-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relinan ].
fact-inanim-obl-inf-noun-lxm := relation-obl-inf-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY fact ].

masc-relanim-obl-inf-noun-lxm := masc-noun-lxm & rel-anim-obl-inf-noun-lxm.
masc-relinan-obl-inf-noun-lxm := masc-noun-lxm & rel-inanim-obl-inf-noun-lxm.
masc-factinan-obl-inf-noun-lxm := masc-noun-lxm & fact-inanim-obl-inf-noun-lxm.
fem-relanim-obl-inf-noun-lxm := fem-noun-lxm & rel-anim-obl-inf-noun-lxm.
fem-relinan-obl-inf-noun-lxm := fem-noun-lxm & rel-inanim-obl-inf-noun-lxm.
fem-factinan-obl-inf-noun-lxm := fem-noun-lxm & fact-inanim-obl-inf-noun-lxm.
neut-relanim-obl-inf-noun-lxm := neut-noun-lxm & rel-anim-obl-inf-noun-lxm.
neut-relinan-obl-inf-noun-lxm := neut-noun-lxm & rel-inanim-obl-inf-noun-lxm.
neut-factinan-obl-inf-noun-lxm := neut-noun-lxm & fact-inanim-obl-inf-noun-lxm.
mascorfem-relanim-obl-inf-noun-lxm := mascorfem-noun-lxm & rel-anim-obl-inf-noun-lxm.
mascorfem-relinan-obl-inf-noun-lxm := mascorfem-noun-lxm & rel-inanim-obl-inf-noun-lxm.
mascorfem-factinan-obl-inf-noun-lxm := mascorfem-noun-lxm & fact-inanim-obl-inf-noun-lxm.


relation-obl-interr-noun-lxm := relation-obl-noun-lxm-sup &
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL -,
                                                             CONT.HOOK.INDEX.E.TENSE finite],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY fct-spec ]]> ].

rel-anim-obl-interr-noun-lxm := relation-obl-interr-noun-lxm & anim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relanim ].
rel-inanim-obl-interr-noun-lxm := relation-obl-interr-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY relinan ].
fact-inanim-obl-interr-noun-lxm := relation-obl-interr-noun-lxm & inanim-noun-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY fact ].

masc-relanim-obl-interr-noun-lxm := masc-noun-lxm & rel-anim-obl-interr-noun-lxm.
masc-relinan-obl-interr-noun-lxm := masc-noun-lxm & rel-inanim-obl-interr-noun-lxm.
masc-factinan-obl-interr-noun-lxm := masc-noun-lxm & fact-inanim-obl-interr-noun-lxm.
fem-relanim-obl-interr-noun-lxm := fem-noun-lxm & rel-anim-obl-interr-noun-lxm.
fem-relinan-obl-interr-noun-lxm := fem-noun-lxm & rel-inanim-obl-interr-noun-lxm.
fem-factinan-obl-interr-noun-lxm := fem-noun-lxm & fact-inanim-obl-interr-noun-lxm.
neut-relanim-obl-interr-noun-lxm := neut-noun-lxm & rel-anim-obl-interr-noun-lxm.
neut-relinan-obl-interr-noun-lxm := neut-noun-lxm & rel-inanim-obl-interr-noun-lxm.
neut-factinan-obl-interr-noun-lxm := neut-noun-lxm & fact-inanim-obl-interr-noun-lxm.
mascorfem-relanim-obl-interr-noun-lxm := mascorfem-noun-lxm & rel-anim-obl-interr-noun-lxm.
mascorfem-relinan-obl-interr-noun-lxm := mascorfem-noun-lxm & rel-inanim-obl-interr-noun-lxm.
mascorfem-factinan-obl-interr-noun-lxm := mascorfem-noun-lxm & fact-inanim-obl-interr-noun-lxm.



inher-noun-lxm := noun-lexeme &
  [ SYNSEM [LOCAL.CONT.HOOK.INDEX.SORT inher-compl ],
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY inhr-comp ].
masc-inher-noun-lxm := masc-noun-lxm & inher-noun-lxm.
fem-inher-noun-lxm := fem-noun-lxm & inher-noun-lxm.
neut-inher-noun-lxm := neut-noun-lxm & inher-noun-lxm.
mascorfem-inher-noun-lxm := mascorfem-noun-lxm & inher-noun-lxm.


; using types defined in prepsort.tdl & lex2.semlab
role-noun-lexeme := noun-lexeme.

; for event nouns with two roles, like "spising" ('eating')
; the 'roles' are supplied by the combinatory genitive rule, or by
; combining prepositions (prep-mod-n-phrase/rule)
init-und-relation-noun-lxm := role-noun-lexeme &
  [ SYNSEM [LKEYS.KEYREL.IARG.CLASS init-und-svh ],
    SYNSEM [LOCAL.CONT.HOOK.INDEX.SORT init-und ]].
masc-init-und-relation-noun-lxm := masc-noun-lxm & init-und-relation-noun-lxm.
neut-init-und-relation-noun-lxm := neut-noun-lxm & init-und-relation-noun-lxm.
fem-init-und-relation-noun-lxm := fem-noun-lxm & init-und-relation-noun-lxm.

; for event nouns with an actor role, like "skrik"
; the 'roles' are supplied by the combinatory genitive rule, or by
; combining prepositions (prep-mod-n-phrase/rule)
init-relation-noun-lxm := role-noun-lexeme &
  [ SYNSEM [LKEYS.KEYREL.IARG.CLASS init-svh ],
    SYNSEM [LOCAL.CONT.HOOK.INDEX.SORT actor ]].
masc-init-relation-noun-lxm := masc-noun-lxm & init-relation-noun-lxm.
neut-init-relation-noun-lxm := neut-noun-lxm & init-relation-noun-lxm.
fem-init-relation-noun-lxm := fem-noun-lxm & init-relation-noun-lxm.

; for event nouns with a theme role, like "fornedrelse"
; the 'roles' are supplied by the combinatory genitive rule, or by
; combining prepositions (prep-mod-n-phrase/rule)
und-relation-noun-lxm := role-noun-lexeme &
  [ SYNSEM [LKEYS.KEYREL.IARG.CLASS und-svh ],
    SYNSEM [LOCAL.CONT.HOOK.INDEX.SORT theme ]].
masc-und-relation-noun-lxm := masc-noun-lxm & und-relation-noun-lxm.
neut-und-relation-noun-lxm := neut-noun-lxm & und-relation-noun-lxm.
fem-und-relation-noun-lxm := fem-noun-lxm & und-relation-noun-lxm.

; to regulate ltol-rules
status-noun-infl-lexeme := sort.
input-to-noun-infl-lexeme := status-noun-infl-lexeme.
output-from-noun-infl-lexeme := status-noun-infl-lexeme.
not-eligbl-for-noun-infl-lexeme := status-noun-infl-lexeme.

; [bmw]
;; TODO: definiteness
infl-lexeme := const-ltol-rule & rule &
 [ INFLECTION [GEND #2, NUMB #1 ],
   C-CONT.HOOK.INDEX.PNG.NG [ GEN #2, NUM #1 ] ].

noun-infl-lexeme := infl-lexeme & noun-lxm &
  [ SYNSEM.LOCAL.CAT #1 & [ VAL [ SPR list,
                                  SUBJ list,
                                  COMPS <>,
                                  ICOMPS list,
                                  SPEC list ],
                            HEAD noun ],
    SYNSEM.LOCAL.CONT.HOOK #hook,
    SYNSEM.LOCAL.BINDING #3,
    SYNSEM.LOCAL.DERIVED-HEAD #11,
    SYNSEM.LOCAL.CMPAR-PENDING #4,
    EXTRINSIC-ORD output-from-noun-infl-lexeme,
    DTR lexeme,
    DTR.SYNSEM.LOCAL.CAT #1,
    DTR.SYNSEM.LOCAL.CONT.HOOK #hook,
    DTR.SYNSEM.LOCAL.BINDING #3,
    DTR.EXTRINSIC-ORD input-to-noun-infl-lexeme,
    DTR.SYNSEM.LOCAL.DERIVED-HEAD #11,
    DTR.SYNSEM.LOCAL.CMPAR-PENDING #4,
    INFLECTION #2 & inflection,
    DTR.INFLECTION #2 & inflection ].


quant-noun-infl-lexeme := noun-infl-lexeme &
  [ C-CONT.RELS <! #8 & [ARG0 #3,
                         RSTR #5 ] !>,
    C-CONT.HCONS #2 & <! [HARG #5,
                           LARG #6 ] !>,
    C-CONT.HOOK.INDEX #3,
    SYNSEM.LOCAL.CONT [HOOK #1,
                       HCONS #2,
                       RELS <! [],#8 !>],
    DTR.SYNSEM.LOCAL.CONT.HOOK #1 & [ LTOP #6 ]].

; changed HEAD.DEF bool from HEAD.DEF -, to get "p√• fredag". perhaps costly
bare-sg-noun-lexeme := quant-noun-infl-lexeme & sing-noun &
  [ C-CONT.RELS <! indef-q-rel & [ PRED "_indef_q_rel"] !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH -,
                                   PNG.NG sg ],
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF bool,
                       HEAD.BARE +,
                       VAL.SPR <> ]].

;HEAD.DEFINITE +,                   
def-noun-lexeme := quant-noun-infl-lexeme & def-noun &
  [ C-CONT.RELS <! def-q-rel !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ BOUNDED +,
                                   WH - ],
;    SYNSEM.LOCAL.CAT.VAL.SPR <>, ; the irule based on it requires a SPR
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.CAT [ HEAD.DEF +,
                       HEAD.BARE - ]].


def-bare-noun-lexeme := noun-infl-lexeme & def-noun &
  [ C-CONT.RELS <! !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ BOUNDED +,
                                   WH - ],
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.CAT [ HEAD.DEF +,
                       HEAD.BARE - ]].


sg-indef-cum-det-noun-lxm := noun-infl-lexeme & sing-indef-noun &
  [ SYNSEM.LOCAL.CAT.HEAD [DEFINITE -,
                           BARE - ],
    SYNSEM.LOCAL.CAT.VAL.SPR <[LOCAL.CAT.HEAD art]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg & #1 & gender,
    SYNSEM.LOCAL.MUST-CONNECT-PROJECT -,
    SYNSEM.LOCAL.CONT [ RELS #2,
                        HCONS #3 ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #1 & gender,
                           RELS #2,
                           HCONS #3] ].

sg-indef-cum-poss-noun-lxm := noun-infl-lexeme & sing-indef-noun &
  [ SYNSEM.LOCAL.CAT.HEAD [DEFINITE -,
                           BARE - ],
    SYNSEM.LOCAL.CAT.VAL.SPR <[LOCAL.CAT.HEAD poss]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg & #1 & gender,
    SYNSEM.LOCAL.CONT [ RELS #2,
                        HCONS #3 ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #1 & gender,
                           RELS #2,
                           HCONS #3] ].

sg-indef-cum-poss-and-enumerator-noun-lxm := noun-infl-lexeme & sing-indef-noun &
  [ SYNSEM.LOCAL.CAT.HEAD [DEFINITE -,
                           BARE - ],
    SYNSEM.LOCAL.CAT.VAL.SPR <[LOCAL.CAT.HEAD poss], []>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg & #1 & gender,
    SYNSEM.LOCAL.CONT [ RELS #2,
                        HCONS #3 ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #1 & gender,
                           RELS #2,
                           HCONS #3] ].

sg-indef-cum-nounspec-noun-lxm := noun-infl-lexeme & sing-indef-noun &
  [ SYNSEM.LOCAL.CAT.HEAD [DEFINITE -,
                           BARE - ],
    SYNSEM.LOCAL.CAT.VAL.SPR <[LOCAL.CAT.HEAD noun]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg & #1 & gender,
    SYNSEM.LOCAL.CONT [ RELS #2,
                        HCONS #3 ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #1 & gender,
                           RELS #2,
                           HCONS #3] ].

sg-indef-cum-quant-noun-lxm := noun-infl-lexeme & sing-indef-noun &
  [ SYNSEM.LOCAL.CAT.HEAD [DEFINITE -,
                           BARE - ],
    SYNSEM.LOCAL.CAT.VAL.SPR <[LOCAL.CAT.HEAD quant]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg & #1 & gender,
    SYNSEM.LOCAL.CONT [ RELS #2,
                        HCONS #3 ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #1 & gender,
                           RELS #2,
                           HCONS #3] ].

sg-indef-cum-card-noun-lxm := quant-noun-infl-lexeme & sing-indef-noun &
  [ SYNSEM.LOCAL.CAT.HEAD [DEFINITE -,
                           BARE - ],
    SYNSEM.LOCAL.CAT.VAL.SPR <[LOCAL.CAT.HEAD card]>,
;    SYNSEM.LOCAL.CAT.VAL.SPR 1-list,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG sg & #1 & gender,
;    SYNSEM.LOCAL.CONT [ RELS #2,
;                        HCONS #3 ],
    C-CONT [ RELS <! [PRED "_udef_q_rel" ] !>,
             HCONS <! [] !> ],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #1 & gender ]].


;                           RELS #2,
;                           HCONS #3
;					     ] ].

; this actually redoes bare-sg-noun-lexeme := quant-noun-infl-lexeme & sing-noun from above, which Elias had nullified in lrules. Seems I want it back again, mostly for the need of predicative nouns.
sg-indef-bare-noun-lxm := sing-indef-noun & quant-noun-infl-lexeme &
  [ SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #4 & gender ],
    SYNSEM.LOCAL.CAT.HEAD [DEFINITE -,
                           BARE + ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    C-CONT [ RELS <! indef-q-rel & [PRED "_indef_q_rel"] !> ],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX #1],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #4 & gender] ].

#|
sg-indef-bare-noun-lxm := noun-infl-lexeme & sing-indef-noun &
  [ SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #4 & gender ],
    SYNSEM.LOCAL.CAT.HEAD [DEFINITE -,
                           BARE + ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    C-CONT [ RELS <! indef-q-rel & [ PRED "_indef_q_rel",
					     ARG0 #1,
					     RSTR #2] !>,
             HCONS <! [HARG #2,
		       LARG #3 ]!> ],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX #1],
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #4 & gender] ].
|#

pl-indef-noun-lexeme := noun-infl-lexeme & plur-indef-noun &
  [ SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG pl & #1 & gender ],
;    SYNSEM.LOCAL.CAT.HEAD.DEF -,  ; would be resonable,but feeds possessive rule
    SYNSEM.LOCAL.CAT.HEAD.DEFINITE -,
    DTR.SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG #1 & gender]].

quant-pl-indef-noun-lexeme := pl-indef-noun-lexeme & quant-noun-infl-lexeme &
  [ C-CONT.RELS <! plurindef-q-rel !>,
    SYNSEM.LOCAL.CAT.VAL.SPR cons,
    SYNSEM.LOCAL.CAT.HEAD.BARE - ].

; designed for 'bare plural' occurrences (incl with adjectives)
leak-pl-indef-noun-lexeme := pl-indef-noun-lexeme & quant-noun-infl-lexeme &
  [ C-CONT.RELS <! plurindef-q-rel !>,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CAT.HEAD.BARE +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX [BOUNDED -,
                                  WH -],
    RULE [ NEEDS-CARD -,
           NOMORE-CARD + ] ].

nonleak-pl-indef-noun-lexeme := pl-indef-noun-lexeme &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    SYNSEM.LOCAL.CAT.HEAD.BARE -,
    RULE.NEEDS-CARD + ].

; designed for combination with cardinals (to, tre...)
;    SYNSEM.LOCAL.CAT.VAL.SPR cons & [FIRST [LOCAL.CONT.HOOK.INDEX.SORT card-unit,
cum-card-pl-indef-noun-lexeme := quant-pl-indef-noun-lexeme & nonleak-pl-indef-noun-lexeme &
  [ SYNSEM.LOCAL.MUST-CONNECT-PROJECT -,
    SYNSEM.LOCAL.CAT.HEAD.DEF -,
    SYNSEM.LOCAL.CAT.VAL.SPR 1-list & [FIRST [LOCAL.CONT.HOOK.INDEX.SORT sort,
                                            LOCAL.CAT.HEAD card & [KEYS.KEY crdnum,
								   DEGREE positive]]] ].


nonleak-nonquant-pl-indef-noun-lexeme := nonleak-pl-indef-noun-lexeme & 
  [ SYNSEM #1,
    DTR.SYNSEM #1 ].

; designed for combination with quantifiers (noen, ingen)
cum-q-pl-indef-noun-lexeme := nonleak-nonquant-pl-indef-noun-lexeme  &
  [SYNSEM.LOCAL.CAT.VAL.SPR 1-list & < expressed-synsem & [LOCAL.CAT.HEAD q ] >,
   SYNSEM.LOCAL.CAT.HEAD.DEF -].

; designed for combination with possessives (min...)
cum-posspron-pl-indef-noun-lexeme := nonleak-nonquant-pl-indef-noun-lexeme  &
  [SYNSEM.LOCAL.CAT.VAL.SPR 1-list & < expressed-synsem & [LOCAL.CAT.HEAD poss ] >].

; designed for combination with determiners (de/disse glade gutter...)
cum-det-pl-indef-noun-lexeme := quant-pl-indef-noun-lexeme  &
  [SYNSEM.LOCAL.CAT.VAL.SPR 1-list & < expressed-synsem & [LOCAL.CAT.HEAD det ] >].

;SYNSEM.LOCAL.CAT.VAL.SPR 1-plus-list & < [LOCAL.CONT.HOOK.INDEX.SORT card-unit]
cum-posspron-and-card-pl-indef-noun-lexeme := nonleak-nonquant-pl-indef-noun-lexeme  &
  [SYNSEM.LOCAL.CAT.VAL.SPR 1-plus-list & 
			    < [LOCAL.CONT.HOOK.INDEX.SORT sort], 
			      expressed-synsem & [LOCAL.CAT.HEAD poss ] >].

;SYNSEM.LOCAL.CAT.VAL.SPR 1-plus-list & < [LOCAL.CONT.HOOK.INDEX.SORT card-unit]
cum-det-and-card-pl-indef-noun-lexeme := quant-pl-indef-noun-lexeme  &
  [SYNSEM.LOCAL.CAT.VAL.SPR 1-plus-list & < [LOCAL.CONT.HOOK.INDEX.SORT sort], expressed-synsem & [LOCAL.CAT.HEAD det ] >].

; designed for combination with measure-nps (en sekk...)
cum-measure-pl-indef-noun-lexeme := nonleak-nonquant-pl-indef-noun-lexeme  &
  [SYNSEM.LOCAL.CAT.HEAD.DEF -,
   SYNSEM.LOCAL.CAT.VAL.SPR 1-list & < expressed-synsem & [LOCAL.CAT.HEAD noun,
					LOCAL.CONT.HOOK.INDEX.SORT measure-unit] >].

sg-def-noun-lexeme := def-noun-lexeme & sing-noun &
  [ SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG sg ]].

plur-def-noun-lexeme := def-noun-lexeme & plur-noun &
  [ SYNSEM.LOCAL.CONT [HOOK.INDEX.PNG.NG pl ] ].

sg-masc-def-noun-lexeme := sg-def-noun-lexeme & m-noun &
  [ C-CONT.HOOK.INDEX.PNG.NG masc-sg ].

sg-fem-def-noun-lexeme := sg-def-noun-lexeme & f-noun &
  [ C-CONT.HOOK.INDEX.PNG.NG fem-sg ].

sg-neut-def-noun-lexeme := sg-def-noun-lexeme & n-noun &
  [ C-CONT.HOOK.INDEX.PNG.NG neutsg ].

;;;;;;;; ADJECTIVE LEXEMES
#|
; SYNSEM.LKEYS.KEYREL.ARG0 individual - should be adevent, but 
; in "to centimeter h√∏yere", the measure-np-cmpar-phrase seems
; to enforce index id
; made XARG individual, to get the right ARG1 in adv-from-adj-pos-lxm.
adj-lxm := lbl-ltop-lex-item & lexeme &
  [ SYNSEM.LOCAL.CAT [ HEAD adj & [ KEYS.KEY adj-selct ],
                       VAL.SUBJ <>,
                       VAL.SPR list,
                       VAL.SPEC <>],
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #2,
    SYNSEM.LOCAL.CONT.HOOK.XPRED #1 & predsort,
    SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    SYNSEM.LKEYS.KEYREL.PRED #1,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.NON-LOCAL.SLASH <!!>,
    INFL-MORPH adjective_inflection ].
|#
; SYNSEM.LKEYS.KEYREL.ARG0 individual - should be adevent, but 
; in "to centimeter h√∏yere", the measure-np-cmpar-phrase seems
; to enforce index id
; made XARG individual, to get the right ARG1 in adv-from-adj-pos-lxm.
; LH260612: the outcomments are to make 'han synes meg syk' possible, with 'han' and 'meg' with distinct index.
adj-lxm := lbl-ltop-lex-item & lexeme &
  [ SYNSEM.LOCAL.CAT [ HEAD adj & [ KEYS.KEY adj-selct ],
                       VAL.SUBJ <>,
                       VAL.SPR list,
                       VAL.SPEC <>],
;    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #2,
    SYNSEM.LOCAL.CONT.HOOK.XPRED #1 & predsort,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #2 & [ ROLE #3 ],
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE #3,
    SYNSEM.LKEYS.KEYREL.PRED #1,
;    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.LOCAL.DERIVED-HEAD -,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.NON-LOCAL.SLASH <!!>,
    INFL-MORPH adjective_inflection ].


; fin_abs; "det er fint i Hardanger"
abs0-adj-lxm-sup := adj-lxm &
  [ SYNSEM.LOCAL.CAT [ HEAD adj-reg & [ DEGREE positive,
                                        KEYS.KEY absadj0 ]],
    SYNSEM.LKEYS.KEYREL adj0_rel,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #1 & expl-ind,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1 & ref-ind & [PNG 3nsg],
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.AGR #1,
    SYNSEM.LOCAL.CAN-MODIFY - ].

abs0-adj-lxm := abs0-adj-lxm-sup &
  [ SYNSEM.LOCAL.CAT.VAL.ICOMPS <> ].

abs-obl-adj-lxm-sup := abs0-adj-lxm-sup & 1arg-1obl & 
  [ SYNSEM.LOCAL.KEY-SPEC #1,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY #1,
                                                  SELECTED +]]> ].

abs-obl-adj-lxm := abs-obl-adj-lxm-sup & 
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY fct-spec ]]> ].


abs-obl-decl-adj-lxm := abs-obl-adj-lxm-sup &
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                             CONT.HOOK.INDEX.E.TENSE finite],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY clse ]]> ].

abs-obl-inf-adj-lxm := abs-obl-adj-lxm-sup &
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                             CONT.HOOK.INDEX.E.TENSE infin],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY clse ]]> ].

abs-obl-interr-adj-lxm := abs-obl-adj-lxm-sup &
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL -,
                                                             CONT.HOOK.INDEX.E.TENSE infin],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY fct-spec ]]> ].


; fin_abs-epon; "det er fint at han kommer", "det er fint √• komme"
; TODO, mystery: 'hyggelig √• hilse p√• deg' with oblN version of hilse, allows only reflexive deg (incorrect by itself), not pronominal.
abs-adj-epon-lxm := adj-lxm & 1arg-1comps &
  [ SYNSEM.LKEYS.KEYREL adj_rel,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absadj0,
    SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    SYNSEM.LOCAL.AGR #2,
;    SYNSEM.LOCAL.AGR [PNG.NG neutsg],
    SYNSEM.LKEYS.KEYREL.ARG1 #1 & handle,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.LTOP #1] >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    SYNSEM.LOCAL.CAN-MODIFY -  ].   
;,;
;				   LOCAL.CAT.HEAD [TRANSPAR -]

abs-adj-epon-decl-lxm := abs-adj-epon-lxm &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD fin-comp,
				   LOCAL.CAT.HEAD.DECL + ] >,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absadj0-epon,
    SYNSEM.LOCAL.CONT.HOOK.XARG [PNG.NG neutsg] ].

abs-adj-epon-infin-lxm := abs-adj-epon-lxm &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD infin-comp,
				   LOCAL.CAT.HEAD.DECL +,
				   LOCAL.CAT.HEAD.TRANSPAR -] >,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absadj0-epon,
    SYNSEM.LOCAL.CONT.HOOK.XARG [PNG.NG neutsg] ].

abs-adj-tough-lxm := abs-adj-epon-lxm &
  [ SYNSEM.LOCAL.AGR #2,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absadj0-tough,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD verb-all,
				   LOCAL.HAS-WH-MOVED +,
				   LOCAL.CONT.HOOK.XARG #2 ] > ].
; LOCAL.CAT.HEAD infin-comp,
                                   


; "uvisst om/hvorvidt han kommer /hvem/hva...hvem som..."
abs-adj-epon-quest-lxm := abs-adj-epon-lxm &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.DECL - ] >,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absadj0-epon,
    SYNSEM.LOCAL.CONT.HOOK.XARG [PNG.NG neutsg] ].

; fin_abs-nonepon; "at han kommer er fint"
abs-adj-non-epon-lxm := adj-lxm &
  [ SYNSEM.LOCAL.AGR.PNG.NG neutsg,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX event ].


abs-adj-nonepon-decl-lxm := abs-adj-non-epon-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY adj-decl-selct,
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.DECL +  ].

abs-adj-nonepon-quest-lxm := abs-adj-non-epon-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY adj-quest-selct,
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.DECL -  ].

#|
; replaced by  abs-adj-tough-lxm
;,
;                                   LOCAL.CONT.HOOK.INDEX.E.TENSE infin
tough-adj-lxm := adj-lxm & 1arg-1comps &	
  [ SYNSEM.LKEYS.KEYREL adj_rel,
    SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    SYNSEM.LOCAL.AGR #2,
    SYNSEM.LKEYS.KEYREL.ARG1 #1 & handle,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD infin-comp & [TRANSPAR -],
                                   LOCAL.CONT.HOOK.XARG #2,
                                   LOCAL.CONT.HOOK.LTOP #1 ] >].
|#

; should have built in a restr that subj be non-expl, but without a syntactic position, that's hard, since expletives now have ref-ind
stnd-adj-lxm-sup := adj-lxm & reg-mod-lex-item &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #8 & event-or-ref-index,
    SYNSEM.LOCAL.AGR #8,
    SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY propt],
    SYNSEM.LOCAL.CAT.VAL.COMPS <> ].

stnd-adj-lxm := stnd-adj-lxm-sup &
  [ SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    SYNSEM.LOCAL.CAN-MODIFY + ].

stnd-obl-adj-lxm-sup := stnd-adj-lxm-sup & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.KEY-SPEC #1,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY #1,
							       SELECTED +]]> ].

stnd-obl-adj-lxm := stnd-obl-adj-lxm-sup & 
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY fct-spec ]]> ].

stnd-dir-obl-adj-lxm := stnd-obl-adj-lxm-sup & 
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY dir ]]> ].

stnd-obl-decl-adj-lxm := stnd-obl-adj-lxm-sup & 1arg-1obl & 
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                             CONT.HOOK.INDEX.E.TENSE finite],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY clse ]]> ].

stnd-obl-inf-adj-lxm := stnd-obl-adj-lxm-sup & 1arg-1obl & 
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                             CONT.HOOK.INDEX.E.TENSE infin],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY clse ]]> ].

stnd-obl-interr-adj-lxm := stnd-obl-adj-lxm-sup & 1arg-1obl & 
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL -,
                                                             CONT.HOOK.INDEX.E.TENSE infin],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY fct-spec ]]> ].

trans-adj-lxm-sup := adj-lxm &
  [ SYNSEM.LKEYS.KEYREL adj_rel,
    SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    SYNSEM.LOCAL.AGR #2,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD nom] >].

trans-adj-lxm := trans-adj-lxm-sup & 1arg-1comps &
  [ SYNSEM.LOCAL.CAT.VAL.ICOMPS <> ].


trans-obl-adj-lxm-sup := trans-adj-lxm-sup & 2arg-1comps-1obl & 
  [ SYNSEM.LOCAL.KEY-SPEC #1,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY #1,
                                                  SELECTED +]]>].

trans-obl-adj-lxm := trans-obl-adj-lxm-sup &
  [ SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY fct-spec ]]> ].


; weak and strong adj-lxm are ltol-rules. they are both positive
; both used to be reg-mod-lex-item, before clean-up
weak-adj-lxm := lbl-ltop-lex-item & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj-reg & [ MOD < [LOCAL.CAT.HEAD noun & [DEF + ]] >,
                                      WEAK +,
                                      DEGREE positive,
                                      KEYS.KEY #7  ],
    SYNSEM.LOCAL.CAT.VAL #2,
    SYNSEM.LKEYS.KEYREL adj_rel,
    SYNSEM.LOCAL.CONT.HOOK.XARG #5,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.NON-LOCAL #3,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    DTR adj-lxm & [ SYNSEM.LOCAL.CAT.VAL #2,
                    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY #7,
                    SYNSEM.LOCAL.CONT.HOOK.XARG #5,
                    SYNSEM.NON-LOCAL #3]].


; MOD < #1 & [LOCAL.CAT.HEAD noun & [DEF - ,
;                                                                    DEFINITE -]]>
strong-adj-lxm := lbl-ltop-lex-item & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj-reg & [ MOD < #1 & [LOCAL.CAT.HEAD noun & [DEF - ,
									 DEFINITE -]]>,
                                      WEAK -,
                                      DEGREE positive,
                                      KEYS.KEY #7 ],
    SYNSEM.LOCAL.CAT.VAL #2,
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT #51,
    SYNSEM.LKEYS.KEYREL ad-rel,
    SYNSEM.LOCAL.CONT.HOOK.XARG #5,
    SYNSEM.LOCAL.CONT.HOOK.XPRED #4,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.AGR #8,
    SYNSEM.LOCAL.DERIVED-HEAD #deriv,
    SYNSEM.LOCAL.CAN-MODIFY #mod,
    SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ #der,
    SYNSEM.NON-LOCAL #3,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    DTR adj-lxm & [ SYNSEM.LOCAL.CAT.VAL #2,
                    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY #7,
                    SYNSEM.LOCAL.CAT.QVAL.SUBJECT #51,
                    SYNSEM.LOCAL.CAT.HEAD.MOD < #1 >,
                    SYNSEM.LOCAL.CONT.HOOK.XARG #5,
                    SYNSEM.LOCAL.CONT.HOOK.XPRED #4,
                    SYNSEM.LOCAL.AGR #8,
                    SYNSEM.LOCAL.DERIVED-HEAD #deriv,
		    SYNSEM.LOCAL.CAN-MODIFY #mod,
		    SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ #der,
		    SYNSEM.NON-LOCAL #3 ]].

#|
comparative-adj-lxm := lbl-ltop-lex-item-4rel & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj-reg & [ DEGREE comparative,
                                      KEYS.KEY #19 ],
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #7 & [ ROLE compare-top ],
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #9,
    SYNSEM.LOCAL.CAT.VAL.COMPS #10,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #11,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING +,
    SYNSEM.NON-LOCAL #30,
    C-CONT.RELS <! compare-rel & [ LBL #1,
                                   PRED "_exceed_c_rel",
                                   ARG0 #8,
                                   ARG1 #2,
                                   ARG2 #3 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #2,
                                                ARG2 #4 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #3,
                                                ARG2 #5 ] !>,
    C-CONT.HCONS <! !>,
    DTR adj-lxm & [ SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
                    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
                    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
                    SYNSEM.LOCAL.CONT.HOOK.XPRED #9,
                    SYNSEM.LOCAL.CAT.VAL.COMPS #10,
                    SYNSEM.LOCAL.CAT.VAL.ICOMPS #11,
                    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY #19,
                    SYNSEM.LOCAL.CONT.HCONS <! !>,
                    SYNSEM.NON-LOCAL #30 ]].
|#
; reduced number of 'measure-out's

comparative-adj-lxm := lbl-ltop-lex-item-2rel & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj-reg & [ DEGREE comparative,
 ;                                     KEYS.KEY #19,
				      COMPAR-DEP enn-cmpar],
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #7 & [ ROLE compare-top ],
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #9,
    SYNSEM.LOCAL.CAT.VAL.COMPS #10,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #11,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING #pend,
    SYNSEM.NON-LOCAL #30,
    C-CONT.RELS <! compare-rel & [ LBL #1,
                                   PRED "_exceed_c_rel",
                                   ARG0 #8,
                                   ARG1 #4,
                                   ARG2 #5 ] !>,
    C-CONT.HCONS <! !>,
    DTR adj-lxm & [ SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
                    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
                    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
                    SYNSEM.LOCAL.CONT.HOOK.XPRED #9,
                    SYNSEM.LOCAL.CAT.VAL.COMPS #10,
                    SYNSEM.LOCAL.CAT.VAL.ICOMPS #11,
		    SYNSEM.LOCAL.CMPAR-PENDING #pend,
;                    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY #19,
                    SYNSEM.LOCAL.CONT.HCONS <! !>,
                    SYNSEM.NON-LOCAL #30 ]].

#|
sup-adj-lxm := lbl-ltop-lex-item-5rel & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [ DEGREE superlative,
                                  KEYS.KEY #keys ],
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #9,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING +,
    SYNSEM.NON-LOCAL #30,
    C-CONT.RELS <! compare-rel & [ LBL #1,
                                   PRED "_exceed_c_rel",
                                   ARG0 #8,
                                   ARG1 #2,
                                   ARG2 #3 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #2,
                                                ARG2 #4 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #3,
                                                ARG2 #5],
                            arg1-relation & [ PRED #9,
                                               ARG0 #5 ] !>,
    C-CONT.HCONS <! !>,
    DTR adj-lxm & [ SYNSEM.LOCAL.CAT.HEAD adj & [ KEYS.KEY #keys ],
                    SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
                    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
                    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
                    SYNSEM.LOCAL.CONT.HOOK.XPRED #9,
                    SYNSEM.LOCAL.CONT.HCONS <! !>,
                    SYNSEM.NON-LOCAL #30 ]].
|#

sup-adj-lxm := lbl-ltop-lex-item-3rel & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [ DEGREE superlative,
                                  KEYS.KEY #keys ],
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #9,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING +,
    SYNSEM.NON-LOCAL #30,
    C-CONT.RELS <! compare-rel & [ LBL #1,
                                   PRED "_exceed_c_rel",
                                   ARG0 #8,
                                   ARG1 #4,
                                   ARG2 #5 ],
                            arg1-relation & [ PRED #9,
                                               ARG0 #5 ] !>,
    C-CONT.HCONS <! !>,
    DTR adj-lxm & [ SYNSEM.LOCAL.CAT.HEAD adj & [ KEYS.KEY #keys ],
                    SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
                    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
                    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
                    SYNSEM.LOCAL.CONT.HOOK.XPRED #9,
                    SYNSEM.LOCAL.CONT.HCONS <! !>,
                    SYNSEM.NON-LOCAL #30 ]].

sup-adj-standalone-lxm := sup-adj-lxm &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < > ].

sup-adj-cum-part-lxm := sup-adj-lxm &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CAT.HEAD part-prep,
                                 LOCAL.CONT.HOOK.XARG #10,
                                 LOCAL.CONT.HOOK.CMPAR-ARG #7] >,
    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
    C-CONT.RELS <! [], [ ARG1 #10] !>].

sup-adj-weak-lxm := sup-adj-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [LOCAL.CAT.HEAD noun & [DEF + ],
                                   LOCAL.CAT.VAL.SPR < [] > ] >,
                            WEAK + ] ].

sup-adj-strong-lxm := sup-adj-lxm &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [LOCAL.CAT.HEAD noun & [DEF - ] ] >,
                            WEAK - ] ].

sup-adj-weak-standalone-lxm := sup-adj-weak-lxm & sup-adj-standalone-lxm.
sup-adj-strong-standalone-lxm := sup-adj-strong-lxm & sup-adj-standalone-lxm.
sup-adj-weak-cum-part-lxm := sup-adj-weak-lxm & sup-adj-cum-part-lxm.
sup-adj-strong-cum-part-lxm := sup-adj-strong-lxm & sup-adj-cum-part-lxm.



; here could come one more sup-adj suitable for free-predicative combination






adv-from-adj-pos-lxm := reg-mod-lex-item & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD a & [ MOD < [LOCAL.CAT.HEAD verb-all,
                                       LOCAL.CONT.HOOK.INDEX event]>,
                                DEGREE positive,
                                KEYS.KEY index-sit ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event & [SORT non-fix-point],
    SYNSEM.LOCAL.CAT.VAL #2,
    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LKEYS.KEYREL adj_rel,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
;    SYNSEM.LOCAL.DERIVED-HEAD +, ; reasoable constraint, but heavy protests
    INFLECTION #1,
    DTR stnd-adj-lxm & [ SYNSEM.LOCAL.CAT.VAL #2,
                         SYNSEM.LOCAL.CAN-ADV-DERIV-ADJ +,
			 INFLECTION #1]].

; "fundamentalt forskjellig"
degadv-from-adj_t-pos-lxm := lbl-ltop-lex-item & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD degspr & [ DEGREE positive ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event & [SORT non-fix-point],
    SYNSEM.LOCAL.CAT.VAL [SPEC < [LOCAL.CAT.HEAD adj] >,
                          COMPS <>,
                          ICOMPS <> ],
    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LKEYS.KEYREL adj_rel,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    INFLECTION #1,
    DTR stnd-adj-lxm & [ SYNSEM.LOCAL.CAN-ADV-DERIV-ADJ +,
			 INFLECTION #1]].

; "eitrende forbannet"
degadv-from-adj_nde-pos-lxm := lbl-ltop-lex-item & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD degspr & [ DEGREE positive ],
    SYNSEM.LOCAL.CAT.VAL [SPEC < [LOCAL.CAT.HEAD adj] >,
                          COMPS <>,
                          ICOMPS <> ],
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    DTR presparticpl-adj-lxm ].

#|
adv-from-adj-cmpar-lxm-sup := lbl-ltop-lex-item-4rel & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD a & [ MOD < [LOCAL.CAT.HEAD verb,
                                       LOCAL.CONT.HOOK.INDEX #7]>,
                                KEYS.KEY index-sit1 ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event & [SORT non-fix-point],
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #9,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING +,
    C-CONT.RELS <! compare-rel & [ LBL #1,
                                   PRED "_exceed_c_rel",
                                   ARG0 #8,
                                   ARG1 #2,
                                   ARG2 #3 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #2,
                                                ARG2 #4 ],
                            measure-out-rel & [ LBL #1,
						ARG1 #3,
                                                ARG2 #5 ] !>,
    C-CONT.HCONS <! !>,
    DTR adj-lxm & [ SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
                    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
                    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
                    SYNSEM.LOCAL.CONT.HOOK.XPRED #9,
                    SYNSEM.LOCAL.CONT.HCONS <! !> ]].
|#

adv-from-adj-cmpar-lxm-sup := lbl-ltop-lex-item-2rel & const-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD a & [ MOD < [LOCAL.CAT.HEAD verb,
                                       LOCAL.CONT.HOOK.INDEX #7]>,
                                KEYS.KEY index-sit1 ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event & [SORT non-fix-point],
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #8,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #9,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.CMPAR-PENDING +,
    C-CONT.RELS <! compare-rel & [ LBL #1,
                                   PRED "_exceed_c_rel",
                                   ARG0 #8,
                                   ARG1 #4,
                                   ARG2 #5 ] !>,
    C-CONT.HCONS <! !>,
    DTR adj-lxm & [ SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
                    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
                    SYNSEM.LOCAL.CONT.HOOK.XARG #7,
                    SYNSEM.LOCAL.CONT.HOOK.XPRED #9,
                    SYNSEM.LOCAL.CONT.HCONS <! !> ]].

adv-from-adj-cmpar-lxm := adv-from-adj-cmpar-lxm-sup &
  [ SYNSEM.LOCAL.CAT.HEAD.DEGREE comparative ].

adv-from-adj-superlat-lxm := adv-from-adj-cmpar-lxm-sup &
  [ SYNSEM.LOCAL.CAT.HEAD.DEGREE superlative ].



;adv-from-adj-t-pos-lxm := adv-from-adj-pos-lxm & infl-ltol-rule.
;adv-from-adj-√∏-pos-lxm := adv-from-adj-pos-lxm & const-ltol-rule.

; PHRASAL TYPES

;without message
;non-rel-clause & 
imperative-phrase := head-valence-phrase & head-only & rule &
  [ SYNSEM.LOCAL [ CAT [ VAL [ SUBJ olist & antilist,
;			       SPR olist,
			       COMPS < >,
                               ICOMPS <> ],
                         HEAD.INV - ] ],
    SYNSEM.LOCAL.CONT.HOOK #hook,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF comm,
    SYNSEM.LOCAL.NEED-IMP-UNARY -,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    SYNSEM.NON-LOCAL #5,
    EXTRINSIC-ORD complete-imp,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD verb-all & [IMPERATIVE +,
                                                   INV -,
                                                   KEYS.KEY mainvb],
                                  VAL [ SUBJ < []  >,
                                        COMPS < >,
                                        ICOMPS <> ] ],
			    CONT.HOOK #hook],
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY +,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD imperative,
    HEAD-DTR.EXTRINSIC-ORD noncomplete-imp,
    HEAD-DTR.SYNSEM.NON-LOCAL #5,
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].


;LH may24-11
; this rule introduces a 'NIL' EP and free variables in so far not explored ways. The rule itself is commented out. Needs an overhaul before brought back into the grammar.
;                               VAL [ SUBJ < []  >,
interjection-phrase := non-rel-clause & head-valence-phrase & head-only & rule &
  [ SYNSEM.LOCAL [ CAT [ VAL [ SUBJ olist & antilist,
			       SPR olist,
			       COMPS < >,
                               ICOMPS <> ]] ],
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
    SYNSEM.LOCAL.NEED-IMP-UNARY -,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    SYNSEM.NON-LOCAL #5,
    EXTRINSIC-ORD complete-imp,
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD interjection & [KEYS.KEY interjct,
						   INTERJECT +],
                                  VAL [ SUBJ < >,
                                        COMPS < >,
                                        ICOMPS <> ] ] ],
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY +,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP <>,
 ;   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD hortative,
    HEAD-DTR.EXTRINSIC-ORD noncomplete-imp,
    HEAD-DTR.SYNSEM.NON-LOCAL #5,
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].

left-parenthesis-phrase := basic-head-spec-phrase & head-final & rule &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD parenthesis & [KEYS.KEY start-parenth ],
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    C-CONT [ RELS <! !>,
	     HCONS <! !>]].
right-parenthesis-phrase := basic-head-comp-phrase & head-initial & rule &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD parenthesis & [KEYS.KEY end-parenth ],
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    C-CONT [ RELS <! !>,
	     HCONS <! !>]].
left-quote-phrase := basic-head-spec-phrase & head-final & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD quotation-mark & [KEYS.KEY start-quote ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    C-CONT [ RELS <! !>,
	     HCONS <! !>]].
right-quote-phrase := basic-head-comp-phrase & head-initial & rule &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD quotation-mark & [KEYS.KEY end-quote ],
    C-CONT [ RELS <! !>,
	     HCONS <! !>]].


; 'SYNSEM.LOCAL.SPEC-TO-BARE-N #deriv,' only to constrain
; interaction with unary-rel -rule
; SYNSEM.LOCAL.CAT.VAL.SPR <> - made it list instead, for "de fleste av guttene";
; cf superlat-cum-part-quantity-word

head-spec-phrase-super-sup := head-final & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
    SYNSEM.LEX -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX  #1 & ref-ind,
    SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    SYNSEM.LOCAL.BINDING.BOUND -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.SPEC-TO-BARE-N #deriv,
    SYNSEM.LOCAL.BND-RESP #5,
 ;   HEAD-DTR.SYNSEM.LOCAL.MUST-COORDINATE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [EXPLETIVE -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #deriv,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #5,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [INDEX #1]].

; ,strange that this was commented out - gives mismatching det and N in NPs
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [INDEX ref-ind]

head-spec-phrase-super := basic-head-spec-phrase & head-spec-phrase-super-sup.



#|
;mal-head-spec-phrase-super := mal-basic-head-spec-phrase & head-spec-phrase-super-sup.
|#


; for "den tredje av guttene", headed by "av" - prep-part
head-spec-det-adj-phrase := basic-head-spec-phrase & head-final & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX  #1 & ref-ind,
    SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEF +,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [INDEX ref-ind],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD det,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    C-CONT [ RELS <! !>,
	     HCONS <! !>]].


head-spec-phrase-cardsift-sup := head-spec-phrase-super-sup &
  [HEAD-DTR.RULE [ NEEDS-CARD bool,
                   NOMORE-CARD bool ],
   C-CONT.RELS <! !>,
   C-CONT [ HCONS <! !>] ].

head-spec-phrase-cardsift := head-spec-phrase-cardsift-sup & head-spec-phrase-super.


head-spec-phrase-cardblock-sup := head-spec-phrase-super-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #1,
    HEAD-DTR.RULE [ NEEDS-CARD bool,
                   NOMORE-CARD - ]].

head-spec-phrase-cardblock := head-spec-phrase-super & 
[ NON-HEAD-DTR.SYNSEM.LOCAL [ CONT.HOOK.INDEX #index,
				AGR #index ]].

; does 'nom' here yield overgeneration? possibly - but necessary
; for combination with part-prep


head-spec-quantor-phrase-sup := head-spec-phrase-cardblock-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    SYNSEM.LOCAL.CMPAR-PENDING #2,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
;    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -, ; 'alle gule sover' must be allowed
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING #2,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD quantor,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #3,
    C-CONT.RELS <! !>,
    C-CONT [ HCONS <! !>]  ]. 

head-spec-quantor-phrase := head-spec-phrase-cardblock & head-spec-quantor-phrase-sup &
 [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEF -,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD quant ]. 

; for "de fleste"
head-spec-def-quantor-phrase := head-spec-phrase-cardblock & head-spec-quantor-phrase-sup &
 [ SYNSEM.LOCAL.CAT.VAL.SPR cons,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEF +,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-quant & [KEYS.KEY adjquant-pre] ]. 


head-spec-plurquant-phrase := head-spec-phrase-cardblock & head-spec-quantor-phrase-sup &
 [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD cardquant ]. 

head-spec-partitive-quantor-phrase := head-spec-phrase-cardblock &
  [ SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    SYNSEM.LOCAL.CMPAR-PENDING #2,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD part-prep,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD quantor,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #3,
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !> ]. 

head-spec-art-phrase-super-sup := head-spec-phrase-cardblock-sup &
  [ SYNSEM.LOCAL.CMPAR-PENDING #2,
    HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD art,
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !>  ].

head-spec-art-phrase-sup := head-spec-art-phrase-super-sup & head-spec-phrase-cardblock.

head-spec-art-phrase := head-spec-art-phrase-2sup & head-spec-phrase-cardblock.

;LH040513 turning this to 'list' is for n-connect-spr-phrase
head-spec-art-phrase-2sup := head-spec-art-phrase-super-sup &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC list ].


head-spec-art-cum-plurspec-phrase := head-spec-art-phrase-sup &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[ LOCAL.CONT.HOOK.INDEX.PNG.NG pl ]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY takes-pl-spc ].

head-spec-art-cum-singspec-phrase := head-spec-art-phrase-sup &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[ LOCAL.CONT.HOOK.INDEX.PNG.NG sg ]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY takes-sg-spc ]. 


head-spec-card-phrase-sup := head-spec-phrase-cardblock &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD part-prep, 
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !> ]. 

head-spec-card-phrase := head-spec-card-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    NON-HEAD-DTR word].

head-cmplxspec-card-phrase := head-spec-card-phrase-sup &
  [ NON-HEAD-DTR measure-quantword-a-phrase ].


head-spec-noun-phrase := head-spec-phrase-cardblock &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    NON-HEAD-DTR.SYNSEM.LOCAL.SPEC-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD part-prep,
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !> ]. 

; SYNSEM.LOCAL.CONT.HOOK.INDEX #xarg,
;    
;
head-spec-cardderivnoun-phrase := head-spec-phrase-cardblock &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    NON-HEAD-DTR.SYNSEM.LOCAL.SPEC-TO-BARE-N +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD part-prep,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    C-CONT.RELS <! arg12-relation & [ LBL #lbl,
				      PRED "coreferential_rel",
				      ARG1 #xarg,
				      ARG2 #ind ], indef-q-rel & [PRED "_udef_q_rel",
								  ARG0 #ind,
								  RSTR #rstr], [ PRED "_pron_rel",
										 LBL #lbl,
										 ARG0 #ind ] !>,
    C-CONT.HCONS <! [HARG #rstr,
		     LARG #lbl] !> ]. 

; for "gutter flest". Mostly taken from head-spec-phrase-super, head-spec-phrase-cardblock and head-spec-quantor-phrase

head-spec-post-phrase := basic-head-spec-phrase & head-initial & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
    SYNSEM.LEX -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX  #1 & ref-ind,
    SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.BINDING.BOUND -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.SPEC-TO-BARE-N #deriv,
    SYNSEM.LOCAL.BND-RESP #5,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #10,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #10,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [DEF -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <[]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #deriv,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #5,
    HEAD-DTR.RULE [ NEEDS-CARD bool,
                   NOMORE-CARD - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-quant & [KEYS.KEY adjquant-post],
    C-CONT [ RELS <! !>,
	     HCONS <! !>]].

head-spec-adj-phrase := basic-head-spec-phrase & head-final & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX  #1 & ref-ind,
    SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    SYNSEM.LOCAL.CAT.VAL.SPR <[LOCAL.CONT.HOOK.INDEX #7]>,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD part-prep,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #7,
    C-CONT [ RELS <! !>,
	     HCONS <! !>]].

head-spec-det-phrase-sup := head-spec-phrase-cardsift-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD det].


;;; DPF addenda

head-spec-det-phrase := head-spec-det-phrase-sup & head-spec-phrase-cardsift &
  [ NON-HEAD-DTR.SYNSEM.LOCAL [ CONT.HOOK.INDEX #index,
				AGR #index ] ].



;head-spec-det-phrase := head-spec-det-phrase-sup & head-spec-phrase-cardsift. 



complex-spec-n-phrase-super := basic-head-spec-phrase & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
;    HEAD-DTR.SYNSEM.LOCAL.MUST-COORDINATE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>].

complex-spec-n-phrase-sup := complex-spec-n-phrase-super & head-final.
;complex-spec-n-prenom-phrase-sup := complex-spec-n-phrase-super & head-initial.

;; Alternative path created for normal. 30.03.11.
complex-spec-n-phrase-head-initial-sup := basic-head-spec-phrase & head-initial & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list].

complex-spec-n-phrase := complex-spec-n-phrase-sup &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    C-CONT.RELS.LIST.FIRST[LBL #8,
			   ARG1 #2,
			   ARG2 #1]].

complex-spec-n-phrase-head-initial := complex-spec-n-phrase-head-initial-sup &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    C-CONT.RELS.LIST.FIRST[LBL #8,
			   ARG1 #2,
			   ARG2 #1]].

#|

  [ C-CONT.RELS <! indef-q-rel & [ PRED "_indef_q_rel",
                                   ARG0 #1,
                                   RSTR #2 ] !>,
          C-CONT.HCONS <! [ HARG #2,
                            LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.HOOK hook & [INDEX #1 & [ WH - ]],
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF -,
                       HEAD.BARE +,
                       VAL.SPR <> ],
    SYNSEM.LOCAL.DERIVED-HEAD +,
    DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #3 ].




complex-spec-n-phrase := basic-head-spec-phrase & head-final & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    C-CONT.RELS <![LBL #8,
		   ARG1 #2,
		   ARG2 #1], indef-q-rel & [ PRED "_indef_q_rel",
					     ARG0 #2,
					     RSTR #9 ] !>,
    C-CONT.HCONS <! [ HARG #9,
                      LARG #8 ] !>].

|#


;    C-CONT [ RELS <! [ARG1 #2,
;                      ARG2 #1],... !>]].

; temporarily taken out 
; HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
; in order to enable "et par dusin", where "dusin" is not referential-thing
    
; the marking 'WH -' may need amendment to accommodate "hvor mange dusin egg"

measure-np-phrase := complex-spec-n-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [WH #9,
                                               SORT measure-item ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [DEF -],
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [KEYS.KEY measnoun],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    C-CONT [ RELS <! measure-out-rel &
		   [LBL #5], indef-q-rel & [ PRED "_indef_q_rel",
					     ARG0 #1,
					     RSTR #2]  !>,
	     HCONS <! [HARG #2,
		       LARG #5 ] !>],
    RULE.NOMORE-CARD + ].


parameter-spec-phrase := basic-head-spec-phrase & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR [SYNSEM.LOCAL.CONT.HOOK.XARG #3],
    HEAD-DTR [SYNSEM.LOCAL.CONT.HOOK.LTOP #8],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    C-CONT [ RELS <! [LBL #8,
		      ARG1 #2,
                      ARG2 #1] !>,
	     HCONS <! !>]].


klokka-spec-phrase := parameter-spec-phrase & head-initial &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [SORT time-item],
    HEAD-DTR klokka-word,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card,
    C-CONT [ RELS <! measure-out-rel !> ]].

order-spec-phrase := parameter-spec-phrase & head-initial &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [SORT referential-thing],
    HEAD-DTR klokka-word,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card,
    C-CONT [ RELS <! measure-out-rel !> ]].


; probably have NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
; HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card-nom & [KEYS.KEY crdfix],
weekday-spec-phrase := parameter-spec-phrase & head-final &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX [SORT time-item,
				  WH -],
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun & [KEYS.KEY weekday-noun,
						    DEF -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [SPR <>,
				       SUBJ <>,
				       COMPS <>,
				       ICOMPS <>],
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY crdfix],
;    the above line restricts too much, perhaps, but saying nothing gives wild consequences
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    C-CONT.RELS <! arg12-relation & [ PRED "contains-in-time-rel" ] !> ].

; "fem tusen to hundre menn"
complex-number-phrase := binary-phrase & rule &
  [ SYNSEM.LOCAL.CAT.HEAD #head & noun,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #3,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT number-unit,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    ARGS < card-cum-plurspec-mod-phrase & 
           [SYNSEM.LOCAL.CAT.HEAD #head,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT number-unit,
            SYNSEM.LOCAL.CAT.VAL.SPR < >,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -],
           card-cum-plurspec-mod-phrase & 
           [SYNSEM.LOCAL.CAT.HEAD #head,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT number-unit,
            SYNSEM.LOCAL.CAT.VAL.SPR < >,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ] >,
    C-CONT [ RELS <! accumulate-rel & [ ARG0 #3,
                                        ARG1 #1,
                                        ARG2 #2 ] !>,
	     HCONS <! !>]].

; "han hoppet fem femti"
complex-card-phrase := binary-phrase & rule &
  [ SYNSEM.LOCAL.CAT.HEAD cardquant,
    SYNSEM.LOCAL.CAT.HEAD.DEGREE positive,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT card-unit,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #3,
    ARGS < [SYNSEM.LOCAL.CAT.HEAD #head & cardnum,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT card-unit,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #1],
           [SYNSEM.LOCAL.CAT.HEAD #head,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT card-unit,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #2 ] >,
    C-CONT [ RELS <! accumulate-rel & [ ARG0 #3,
                                        ARG1 #1,
                                        ARG2 #2 ] !>,
	     HCONS <! !>]].
    

; "fem tusen femti menn"
numbernoun-plus-card-phrase := binary-phrase & rule &
  [ SYNSEM.LOCAL.CAT.HEAD #head & noun & [KEYS.KEY takes-pl-spc], ;KEY to ensure 'tusen' or 'hundre'
    SYNSEM.LOCAL.CONT.HOOK.INDEX #3,
    SYNSEM.LOCAL.CAT.VAL.SPR < >,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT number-unit,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    ARGS < [SYNSEM.LOCAL.CAT.HEAD #head,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT number-unit,
            SYNSEM.LOCAL.CAT.VAL.SPR < >,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -],
           [SYNSEM.LOCAL.CAT.HEAD cardnum,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT card-unit,
            SYNSEM.LOCAL.CAT.VAL.SPR < >,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ] >,
    C-CONT [ RELS <! accumulate-rel & [ ARG0 #3,
                                        ARG1 #1,
                                        ARG2 #2 ] !>,
	     HCONS <! !>]].

    
; "fem tusen og femti menn"
numbernoun-plus-coord-card-phrase := binary-phrase & rule &
  [ SYNSEM.LOCAL.CAT.HEAD #head & noun,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #3,
    SYNSEM.LOCAL.CAT.VAL.SPR < >,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT number-unit,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    ARGS < [SYNSEM.LOCAL.CAT.HEAD #head,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT number-unit,
            SYNSEM.LOCAL.CAT.VAL.SPR < >,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -],
           [SYNSEM.LOCAL.CAT.HEAD word-coord,
	    SYNSEM.LOCAL.XCAT.HEAD cardnum,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT card-unit,
            SYNSEM.LOCAL.XCAT.VAL.SPR < >,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ] >,
    C-CONT [ RELS <! accumulate-rel & [ ARG0 #3,
                                        ARG1 #1,
                                        ARG2 #2 ] !>,
	     HCONS <! !>]].

    
compound-noun-phrase := rule & basic-head-final &
  [ SYNSEM.LOCAL.CAT.HEAD noun,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LEX +,
    ARGS < noun-lexeme &
           [SYNSEM.LOCAL.CAT.HEAD noun,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
            SYNSEM.LOCAL.CAT.VAL.SPR < >,
            SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
            SYNSEM.LOCAL.DERIVED-HEAD -,
            SYNSEM.LEX +],
           [SYNSEM.LOCAL.CAT.HEAD noun,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
            SYNSEM.LOCAL.CAT.VAL.SPR < >,
            SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
            SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
            SYNSEM.LOCAL.DERIVED-HEAD -,
            SYNSEM.LEX + ] >,
    C-CONT [ RELS <! compound-rel & [ ARG1 #1,
                                      ARG2 #2 ] !>,
	     HCONS <! !>]].

; "mer intelligent", "like stor"
comparative-spec-a-phrase := basic-head-spec-phrase & head-final & rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj & [KEYS.KEY #key],
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CAT.VAL.COMPS #9,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #11,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    SYNSEM.LOCAL.CONT.HOOK.XARG #6,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #2 & predsort,
    SYNSEM.LOCAL.CAT.HEAD.COMPAR-DEP #key,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
    SYNSEM.LOCAL.CMPAR-PENDING +,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #6,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #9,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #11,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD cmpar-reg-adv & [KEYS.KEY #key],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #5,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING +,
    C-CONT [ RELS <! !>,
	     HCONS <! !>] ].

; "mer enn fem meter stor"
morethan2feet-spec-a-phrase := basic-head-spec-phrase & head-final & rule &
  [ SYNSEM.LOCAL.CAT.HEAD adjectival & [ DEGREE positive ],
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #4,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    ARGS < [SYNSEM.LOCAL.CAT [HEAD cmpar-close-adv,
                              VAL.SPEC < [ LOCAL.CONT.HOOK.INDEX #1 ]>,
                              VAL.COMPS <>],
            SYNSEM.LOCAL.CONT.HOOK.XARG #1,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #8],
           [ SYNSEM.LOCAL.CONT.HOOK.XARG #4,
             SYNSEM.LOCAL.CONT.HOOK.INDEX #1 ] >,
    C-CONT [ RELS <! !>,
	     HCONS <! !>] ].

; "mer enn fem meter st√∏rre", "mer enn to dusin flere"
morethan2feet-spec-a-cmpar-phrase := basic-head-spec-phrase & head-final & rule &
  [ SYNSEM.LOCAL.CAT.HEAD [ DEGREE comparative ],
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK.XARG #4,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
    SYNSEM.LOCAL.CONT.HOOK.VARG #7,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #11,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CMPAR-PENDING #9 & +,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    ARGS < [SYNSEM.LOCAL.CAT [HEAD cmpar-close-adv,
                              VAL.SPEC < [ LOCAL.CONT.HOOK.CMPAR-ARG #1 ]> ],
            SYNSEM.LOCAL.CONT.HOOK.XARG #1,
            SYNSEM.LOCAL.CONT.HOOK.LTOP #8],
           [ SYNSEM.LOCAL.CONT.HOOK.XARG #4,
             SYNSEM.LOCAL.CONT.HOOK.CMPAR-ARG #1,
             SYNSEM.LOCAL.CONT.HOOK.VARG #7,
             SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #11,
             SYNSEM.LOCAL.CMPAR-PENDING #9 ] >,
    C-CONT [ RELS <! !>,
	     HCONS <! !>] ].

; removed from the above, without harm
; ,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX #1


; "to meter lang" "???kommer to dager sent"
measure-np-a-phrase := complex-spec-n-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj & [ DEGREE positive ], - try to subsume measure-np-dir-phrase
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adj-or-adv & [ DEGREE positive ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [DEF -,
                                               KEYS.KEY takes-sg-spc],
    NON-HEAD-DTR card-cum-adj-mod-phrase & [SYNSEM.LOCAL.CAT.VAL.SPR <>],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [WH #9,
                                               SORT measure-unit,
					       BOUNDED +],
    C-CONT [ RELS <! measure-out-rel  !>,
	     HCONS <! !>],
    RULE.NOMORE-CARD + ].

; "to kilometer vestover/ mot vest"
measure-np-dir-phrase := complex-spec-n-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [WH #9,
                                               SORT measure-unit ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [ DEGREE positive ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [DEF -,
                                               KEYS.KEY takes-sg-spc],
    NON-HEAD-DTR card-cum-prep-or-adv-mod-phrase & [SYNSEM.LOCAL.CAT.VAL.SPR <>],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    C-CONT [ RELS <! measure-out-rel  !>,
	     HCONS <! !>],
    RULE.NOMORE-CARD + ].

; LH Feb18-06: removed 'NON-HEAD-DTR.SYNSEM.LEX -'
; looks as if this enforces index-id between the two sisters; should not
; "to meter st√∏rre", "to dusin flere"
measure-np-cmpar-phrase := basic-head-spec-phrase & head-final & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK comp-hook,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    SYNSEM.LOCAL.CMPAR-PENDING #10,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #11,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #11,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [WH #9,
                                               SORT measure-unit ],
;  careful here - 'adjectival' cuts it down too much... 
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adjectival & [ DEGREE comparative ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING #10,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [DEF -,
                                               KEYS.KEY measurnoun],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #3 & ref-ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.CMPAR-ARG #4]>,
    C-CONT [ RELS <! measure-out-rel & [ARG1 #3,
                                        ARG2 #4] !>,
             HCONS <! !> ],
    RULE.NOMORE-CARD + ].

; seems redundant, given measure-np-cmpar-phrase
; "to meter mer..."
measure-np-adv-phrase := complex-spec-n-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    SYNSEM.LOCAL.CMPAR-PENDING #10,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [WH #9,
                                               SORT measure-unit ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD cmpar-reg-adv,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING #10,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [DEF -,
					       KEYS.KEY measurnoun],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.BOUNDED +,
    C-CONT [ RELS <! measure-out-rel  !>,
	     HCONS <! !>],
    RULE.NOMORE-CARD + ].

; for "meget/sv√¶rt stor"
measure-quantword-a-phrase := complex-spec-n-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
;    SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CONT.HOOK.INDEX #ind,
;				 LOCAL.CONT.HOOK.LTOP #lbl ]>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    SYNSEM.LOCAL.DERIVED-HEAD #bool,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #bool,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adjectival & [ DEGREE positive ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CONT.HOOK.INDEX #ind,
;					  LOCAL.CONT.HOOK.LTOP #lbl] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD degspr,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    C-CONT [ RELS <! measure-out-rel  !>,
	     HCONS <! !>],
    RULE.NOMORE-CARD + ].

;; Alt path for mal-rule. EAA. 30.03.11.
measure-quantword-a-phrase-head-initial := complex-spec-n-phrase-head-initial &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DEGREE positive ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD degspr,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    C-CONT [ RELS <! measure-out-rel  !>,
	     HCONS <! !>],
    RULE.NOMORE-CARD + ].

; for "stor nok"; most of the specification replicates complex-spec-n-phrase
measure-a-quantword-phrase := basic-head-spec-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
;    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DEGREE positive ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR degreepos-post-spec-word,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    C-CONT [ RELS <! measure-out-rel & [ARG1 #2,
                                        ARG2 #1] !>,
	     HCONS <! !>]].

; for "sv√¶rt stor"
;measure-adv-a-phrase := measure-quantword-a-phrase &
;  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD degspr,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DEGREE positive ] ].

; for "meget stor"  - not activated - perhaps all are adv
;measure-q-a-phrase := measure-quantword-a-phrase &
;  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD q ]. 

; "mye/atskillig st√∏rre", "mange/langt flere"
measure-quantword-cmpar-phrase-sup := basic-head-spec-phrase & head-final & rule &
  [ SYNSEM.LOCAL.CAT.HEAD #adj & adjectival,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CAT.VAL.SPEC #11,
    SYNSEM.LOCAL.CONT.HOOK comp-hook,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    SYNSEM.LOCAL.CMPAR-PENDING #10,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #2 & predsort,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #adj,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC #11,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [WH #9 ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #3 & ref-ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CMPAR-PENDING #10,
					     LOCAL.CONT.HOOK.INDEX #4]>,
    C-CONT [ RELS <! measure-out-rel & [ARG1 #3,
                                        ARG2 #4] !>,
             HCONS <! !> ],
    RULE.NOMORE-CARD + ].

; from 'comparative'
measure-quantword-cmpar-phrase := measure-quantword-cmpar-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DEGREE comparative ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD q].
measure-quantword-sup-phrase := measure-quantword-cmpar-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DEGREE superlative ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD degspr ].
    
; "atskillig st√∏rre", "langt flere"
measure-adv-cmpar-phrase := measure-quantword-cmpar-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DEGREE comparative ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD degspr ].

; redundant, and not active - same as measure-quantword-cmpar-phrase
; "mye st√∏rre", "mange flere" - not activated - perhaps all are adv
measure-q-cmpar-phrase := measure-quantword-cmpar-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DEGREE comparative ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD q ].

; the WH #9 marking provides the piedpiping effect for "hvem sin gutt
; sitter", but has the consequence that both the interrogative x-
; variable and the gutt-variable carry 'WH +' in the MRS. For
; interpretation, we have to rule that only an 'x WH +' bound by
; 'interrog-q-rel' counts as a 'questioned' variable.



general-genitive-phrase := basic-head-spec-phrase & head-final & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.BINDING #35,
    SYNSEM.LOCAL.BND-RESP #bnd,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    SYNSEM.NON-LOCAL #5,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bnd,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.NON-LOCAL #5,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [INDEX #1 & [ SORT semsort ],
                                     LTOP #7 ],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #5,
    HEAD-DTR.SYNSEM.LOCAL.BINDING #35,
    C-CONT [ RELS <! [ LBL #7,
		       ARG1 #2,
                       ARG2 #1], def-q-rel & [ ARG0 #1,
                                               RSTR #6 ]  !>,
             HCONS <! [HARG #6,
                       LARG #7] !>]].

; the six thematic varieties of a genitive ('poss' is
; the 'unmarked' one)
agentive-general-genitive-phrase := general-genitive-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT init-und,
    C-CONT.RELS.LIST.FIRST agent-rel ].

undergoer-general-genitive-phrase := general-genitive-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT init-und,
    HEAD-DTR.SYNSEM.UNDERGOER-OPEN +,
    C-CONT.RELS.LIST.FIRST undergoer-rel  ].

actor-general-genitive-phrase := general-genitive-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT actor,
    HEAD-DTR.SYNSEM.UNDERGOER-OPEN +,
    C-CONT.RELS.LIST.FIRST agent-rel ].

theme-general-genitive-phrase := general-genitive-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT theme,
    HEAD-DTR.SYNSEM.UNDERGOER-OPEN +,
    C-CONT.RELS.LIST.FIRST undergoer-rel ].

poss-general-genitive-phrase := general-genitive-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
    C-CONT.RELS.LIST.FIRST poss-rel  ].

relational-general-genitive-phrase := general-genitive-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT relatum,
    C-CONT.RELS.LIST.FIRST related-rel  ].
  
; ... and the according 8 rules...

agentive-genitive-np-phrase := agentive-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD possparticle,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #8].

agentive-genitive-posspron-phrase := agentive-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD posspron].

undergoer-genitive-np-phrase := undergoer-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD possparticle,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #8].

undergoer-genitive-posspron-phrase := undergoer-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD posspron].

actor-genitive-np-phrase := actor-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD possparticle,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #8].

actor-genitive-posspron-phrase := actor-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD posspron].

theme-genitive-np-phrase := theme-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD possparticle,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #8].

theme-genitive-posspron-phrase := theme-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD posspron].


poss-genitive-np-phrase := poss-general-genitive-phrase &
  [ SYNSEM.LOCAL.BND-RESP #resp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD possparticle,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    HEAD-DTR.SYNSEM.LOCAL.POSSPRON-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp].

poss-genitive-posspron-phrase := poss-general-genitive-phrase &
  [ SYNSEM.LOCAL.BND-RESP #3,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD posspron,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
;    NON-HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-MOUNTABLE #3].

relational-genitive-np-phrase := relational-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD possparticle,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.AGR.PNG.NG #8].

relational-genitive-posspron-phrase := relational-general-genitive-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD posspron].


; this works, but maybe weekday-spec-rule is sufficient

;;weekday-genitive-np-phrase := basic-head-spec-phrase & head-final & rule &
weekday-genitive-np-phrase := general-genitive-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY weekday-noun,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [SORT semsort],
    C-CONT.RELS.LIST.FIRST poss-rel   ].


;;;; appositions

; specific like 'HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-INDEX-SIT +' in order to make sure no adv has
; combined - otherwise "huset bak skogen" gets a parse as apposition

fact-that-phrase := basic-head-spec-phrase & head-initial & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    SYNSEM.LOCAL.MUST-APP -,
    SYNSEM.LOCAL.CAN-APP -,
    SYNSEM.LOCAL.BINDING #6,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun & [ DEF +,
                                                 KEYS.KEY fact ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-INDEX-SIT +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-FIXPT +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-NONFIXPT-DIR +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <[]>,
    HEAD-DTR.SYNSEM.LOCAL.HAS-REL-CL -,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    HEAD-DTR.SYNSEM.LOCAL.BINDING #6,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD glob-comp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    C-CONT [ RELS <! reside-in-rel & [ARG1 #1,
                                      ARG2 #2] !>,
	     HCONS <! !>]].

; due to OK "Ola leder i sosialkomiteen", only weak requirements on the heads

apposition-for-introduction-phrase := basic-head-spec-phrase & head-initial & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.MUST-APP -,
    SYNSEM.LOCAL.CAN-APP -,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [ DEF +],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [PNG.NG.NUM #3, ;perhaps not warranted, but N+N combinations are running wild ...
                                                WH -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.POSSPRON-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-INDEX-SIT +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-FIXPT +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-NONFIXPT-DIR +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <[]>,
    HEAD-DTR.SYNSEM.LOCAL.HAS-REL-CL -,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -, ; perhaps too strong
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [ DEF +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind & [PNG.NG.NUM #3,
                                                              SORT referential-thing],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [COORDINABLE +,
                                                  DEF bool,
						KEYS.KEY plainnoun,
                                                  BARE bool],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    C-CONT [ RELS <! partitive-rel & [ARG1 #2,
                                      ARG2 #1] !>,
	     HCONS <! !>]].


enumeration-by-card-phrase := basic-head-spec-phrase & head-initial & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.MUST-APP -,
    SYNSEM.LOCAL.CAN-APP -,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.HEAD noun & [KEYS.KEY plainnoun],
;    SYNSEM.LOCAL.CAT.HEAD noun & [ DEF -],
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [ DEF -],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [PNG.NG.NUM #3, ;perhaps not warranted, but N+N combinations are running wild ...
                                                WH -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    HEAD-DTR.SYNSEM.LOCAL.CARD-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.POSSPRON-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-INDEX-SIT +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-FIXPT +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-NONFIXPT-DIR +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <[]>,
    HEAD-DTR.SYNSEM.LOCAL.HAS-REL-CL -,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -, ; perhaps too strong
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [ DEF +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind & [PNG.NG.NUM #3],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [COORDINABLE +,
                                                  DEF bool,
						KEYS.KEY name-of-card,
                                                  BARE bool],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    C-CONT [ RELS <! partitive-rel & [ARG1 #2,
                                      ARG2 #1] !>,
	     HCONS <! !>]].



; adjoing a comma-surrounded apposition to the head noun. Has non-restr function
; due to OK "Ola leder i sosialkomiteen", only weak requirements on the heads

rightmod-nonrestr-apposition-phrase := head-mod-phrase-simple & head-initial & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [PNG.NG.NUM #3,
                                       WH -],
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.MUST-APP -,
    SYNSEM.LOCAL.CAN-APP -,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR comma-leftmod-nonrestr-apposition-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind & [PNG.NG.NUM #3],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [DEF bool],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-APP +,
    C-CONT [ RELS <! partitive-rel & [ARG1 #2,
                                      ARG2 #1] !>,
	     HCONS <! !>]].



; adjoing an  apposition-np with comma to the right to the noun. Has restr function

rightmod-restr-apposition-phrase := basic-head-spec-phrase & head-initial & rule &
  [ RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [WH -],
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun & [ DEF + ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR comma-rightmod-apposition-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <[]>,
    C-CONT [ RELS <! partitive-rel & [ARG1 #2,
                                      ARG2 #1] !>,
	     HCONS <! !>]].



; head-subject...
#|
;;; BACKUP for mal rules

head-subject-phrase-sup := basic-head-subj-phrase & head-final & rule & 
  [SYNSEM.LOCAL.CONT.HOOK #hook,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   SYNSEM.LOCAL.CONT.HOOK.XARG #3,
   SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
   EXTRACTED-FROM #10,
   SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   SYNSEM.LOCAL.REL-CL-SOM-INIT -,
   SYNSEM.NON-LOCAL #18,
   SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV -,
					       WH-COMPLETE -],
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
   HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
   HEAD-DTR.INFLECTED +,
   HEAD-DTR.EXTRACTED-FROM #10,
   NON-HEAD-DTR.INFLECTED +,
   NON-HEAD-DTR.RULE card-ok,
   HEAD-DTR.SYNSEM.NON-LOCAL #18,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX individual & [ WH - ],
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.BINDING.REFL-I -,
   NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
   NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
   C-CONT.HOOK.INDEX.SF prop,
   C-CONT [ RELS <! !>,
            HCONS <! !> ] ].


|#

; commented out ;   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop, since '?' and '!' often go with declarative word order. SF-specification should probably only come with the marked cases, i.e., the imperative rule and head-subject-interr-phrase.
; for some reason, 'NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>' had been commented out, probably in order to avoid some wild extraparses. But needed, to avoid dem-words being accepted without a noun.
head-subject-phrase-super := basic-head-subj-phrase-sup & head-final & rule & 
  [SYNSEM.LOCAL.CONT.HOOK #hook,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   SYNSEM.LOCAL.CONT.HOOK.XARG #3,
   SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
;   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
   EXTRACTED-FROM #10,
   SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   SYNSEM.LOCAL.REL-CL-SOM-INIT -,
   SYNSEM.NON-LOCAL #18,
   SYNSEM.LOCAL.ADJ-SITE-OPEN -,
   SYNSEM.LOCAL.HEAD-SUBJ-APPLIED +,
;   SYNSEM.LOCAL.BND-RESP #bndresp,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ WH-COMPLETE -],
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
;   HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
   HEAD-DTR.INFLECTED +,
   HEAD-DTR.EXTRACTED-FROM #10,
   HEAD-DTR.SYNSEM.LOCAL.HEAD-SUBJ-APPLIED -,
;   HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
   NON-HEAD-DTR.INFLECTED +,
   NON-HEAD-DTR.RULE card-ok,
   NON-HEAD-DTR.SYNSEM.LOCAL.XLBL #2,
   HEAD-DTR.SYNSEM.NON-LOCAL #18,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX individual,
;   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX individual & [ WH - ],
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
;   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.TRANSPAR -,
   NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.BINDING.REFL-I -,
;   NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
   NON-HEAD-DTR.SYNSEM.LOCAL.MUST-COORDINATE -,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ list,
   NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
;   C-CONT.HOOK.INDEX.SF prop,
   C-CONT [ RELS <! !>,
            HCONS <! !> ] ].


head-subject-phrase-sup := head-subject-phrase-super & basic-head-subj-phrase &
[ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.INV -].

head-subject-phrase-simple := head-subject-phrase-super &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.TRANSPAR -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ ACCUSATIVE -, ; there is one construction which wants this as '+' - 'en mann √• fort√¶re sover', where identity through the relative requires full head identity. Loosened that, to only require expletive id or not - not sure if that was the main purpose ...
                                         KEYS.KEY adhoc-norm ]].

head-subject-phrase := head-subject-phrase-simple & head-subject-phrase-sup.



head-indirwhquest-subjwh-subject-phrase := head-subject-phrase-sup &
  [ NON-HEAD-DTR head-subjfiller-subord-wh-phrase ].

head-indirwhquest-objwh-subject-phrase := head-subject-phrase-sup &
  [ NON-HEAD-DTR head-filler-subord-wh-phrase ].


;without message:

;; "(mann) som || kommer"

head-relative-subject-phrase := basic-head-subj-phrase & head-final & rule & 
  [SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   SYNSEM.LOCAL.CONT.HOOK.XARG #4,
   SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
   SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
                                     DECL +,
                                     MAIN-CL -,
				     WH-COMPLETE +,
				     WH-MOVED -],
   SYNSEM.LOCAL.REL-CL-SOM-INIT +,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV - ],
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
   HEAD-DTR.INFLECTED +,
   NON-HEAD-DTR subj-relpron & [RESUMPTIVE - ],
   NON-HEAD-DTR.INFLECTED +,
   NON-HEAD-DTR.RULE card-ok,
;   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #4 & [ WH - ],
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
  NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD head & [ ACCUSATIVE - ],
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
;   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
   C-CONT [ RELS <!  !>,
            HCONS <!  !> ] ].

; for 'hvem kommer?'  (inevitably, "hest kommer" can then undergo this rule)
head-subject-interr-phrase := basic-head-subj-phrase & head-final & rule & 
  [SYNSEM.LOCAL.CAT.HEAD.DECL -,
   SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   SYNSEM.LOCAL.CONT.HOOK.INDEX #8 & [ DISC-MOVE question ],
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
   SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   SYNSEM.LOCAL.REL-CL-SOM-INIT -,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV -,
					       WH-COMPLETE -],
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
   HEAD-DTR.INFLECTED +,
   HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
   NON-HEAD-DTR.INFLECTED +,
   NON-HEAD-DTR.RESUMPTIVE -,
   NON-HEAD-DTR.RULE card-ok,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX individual & [ WH + ],
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ ACCUSATIVE -,
                                               KEYS.KEY adhoc-norm  ],
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
;   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP <>,
   C-CONT.HOOK.INDEX.SF ques,
   C-CONT [ RELS <!  !>,
            HCONS <!  !> ] ].


;;;;;;;
head-resumptsubject-interr-phrase := basic-head-subj-phrase-super & head-final & rule & 
  [SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV -,
                                      MAIN-CL -,
				      WH-COMPLETE + ],
   SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   SYNSEM.LOCAL.CONT.HOOK.INDEX #index,
   SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   SYNSEM.LOCAL.CONT.HOOK.XARG #8,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
   SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
   SYNSEM.LOCAL.REL-CL-SOM-INIT -,
   EXTRACTED-FROM #16,
   SYNSEM.NON-LOCAL.SLASH 1-dlist & [ LIST < [ CAT.HEAD nom,
					       CONT.HOOK.INDEX #ind ] > ],
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index,
 ;  HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV -,
                                               MAIN-CL - ],
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
   HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
   HEAD-DTR.INFLECTED +,
   HEAD-DTR.EXTRACTED-FROM #16,
   HEAD-DTR.SYNSEM.NON-LOCAL.SLASH 0-dlist & [ LIST < > ],
   NON-HEAD-DTR som-resumpt-word,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   NON-HEAD-DTR.INFLECTED +,
   NON-HEAD-DTR.RULE card-ok,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #12,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #ind & ref-ind & [ WH + ],
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD rel-pron & [ ACCUSATIVE -,
                                                   KEYS.KEY som-subjgap  ],
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
;   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
   C-CONT [ RELS <! !>,
            HCONS <! !> ] ].


;;;;;;
;;; ALTERED for mal rules

head-invertsubject-decl-phrase-super := another-basic-head-subj-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #3 & list,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #30,
    SYNSEM.LOCAL.CONT.HOOK #40,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
;    SYNSEM.NON-LOCAL.SLASH #7,
    SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    EXTRACTED-FROM #bool,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV +,
                                                DECL +,
					        WH-COMPLETE -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #30,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #40,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    HEAD-DTR.INFLECTED +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.COMPS-BEGUN -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
;    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #7,
    HEAD-DTR.EXTRACTED-FROM #bool,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX individual,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ ACCUSATIVE -,
                                                   KEYS.KEY adhoc-norm,
						   RELATIVPRON - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ -,
;    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #7,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    NON-HEAD-DTR.SYNSEM.LOCAL.MUST-APP +,
;    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].


head-invertsubject-decl-phrase-simple-sup := head-invertsubject-decl-phrase-super &
[ FRONT-TO-FILL +,
  HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL + ].


head-invertsubject-decl-phrase := head-invertsubject-decl-phrase-simple-sup &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CTXT non-pron-discbnd ].


head-clit-invertsubject-decl-phrase := head-invertsubject-decl-phrase-simple-sup &
 [ SYNSEM.LOCAL.CLIT-SITE-OPEN +,
   SYNSEM.LOCAL.ADJ-SITE-OPEN +,
   SYNSEM.LOCAL.CLIT-PRON-CONFIRMED -,
   HEAD-DTR.SYNSEM.LOCAL.CLIT-SITE-OPEN +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron,
   HEAD-DTR.SYNSEM.LEX +,
   NON-HEAD-DTR.SYNSEM.LEX +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CTXT pron-discbnd ].


; without message

; HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN + was in order to reduce ambig with finite main verb fronting - non-fronting
head-invertsubject-interr-phrase-sup := another-basic-head-subj-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
   SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
   SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
   SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
   SYNSEM.LOCAL.CAT.HEAD verb-all & [ MAIN-CL +,
                                       INV +,
                                       DECL -],
    SYNSEM.LOCAL.CAT.VAL.COMPS #3,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #4,
    SYNSEM.NON-LOCAL #7,
    EXTRACTED-FROM #bool,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ MAIN-CL +,
                                                INV +,
                                                DECL -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #4,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #8,
    HEAD-DTR.INFLECTED +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.COMPS-BEGUN -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    HEAD-DTR.SYNSEM.NON-LOCAL #7,
    HEAD-DTR.EXTRACTED-FROM #bool,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX individual,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD poss-subj-head & [ ACCUSATIVE -,
                                                          KEYS.KEY adhoc-norm,
							  RELATIVPRON -   ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>, ; was commented out - not clear why
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist, ; was commented out - not clear why
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ -,
    C-CONT [ RELS <! !>,
            HCONS <! !> ] ].

;;;;;;;;;;

; old version- blocks "ser gutten'a?" and "ser gutten ofte Ola?"
;head-invertsubject-interr-phrase := head-invertsubject-interr-phrase-sup &
;  [ SYNSEM.LOCAL.CLIT-SITE-OPEN -,
;    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CTXT non-pron-discbnd ].

; ADJ-SITE-OPEN -  blocked "har gutten aldri kommet", so has been relaxed
head-invertsubject-interr-phrase := head-invertsubject-interr-phrase-sup &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN bool,
;    SYNSEM.LEX -, ; requires changing the main type to neutral regarding phrase synsem - concerns avoiding "kommer senere Ola?" Same for declarative inversion. TODO
    NON-HEAD-DTR.SYNSEM.LOCAL.CTXT non-pron-discbnd ].

head-clit-invertsubject-interr-phrase := head-invertsubject-interr-phrase-sup &
 [ SYNSEM.LOCAL.CLIT-SITE-OPEN +,
   SYNSEM.LOCAL.ADJ-SITE-OPEN +,
   SYNSEM.LOCAL.CLIT-PRON-CONFIRMED -,
;   SYNSEM.LEX +,; requires changing the main type to neutral regarding phrase synsem - concerns avoiding "kommer senere Ola?" Same for declarative inversion. TODO
   HEAD-DTR.SYNSEM.LOCAL.CLIT-SITE-OPEN +,
   HEAD-DTR.SYNSEM.LEX +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron,
   NON-HEAD-DTR.SYNSEM.LEX +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CTXT pron-discbnd ].




; the BOUNDED restriction means that in ditrans, the objects have to
; agree in boundedness, excluding "gi Ola penger"
; verb-all, to accommodate copula nom 
;SYNSEM.NON-LOCAL #5, 
;NON-HEAD-DTR.SYNSEM.NON-LOCAL #5,
;SYNSEM.LOCAL.WAIT-BND-RESP #resp,
;HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #resp,

 head-verb-comp-phrase-sup := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.HEAD #head & verb-all,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.DELIMITED #2 & bool,
    SYNSEM.LOCAL.CONT.HOOK.VARG #dirarg,
    SYNSEM.LOCAL.COMPS-BEGUN +,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #has-a-v-comp,
    SYNSEM.LOCAL.HAS-WH-MOVED #hm,
;    EXTRACTED-FROM #extracted-from,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #21,
;    SYNSEM.LOCAL.BND-RESP #resp,  this identity blocked 'det setter seg en gutt', forcing collision in gender between 'det' and 'gutt' due to seg bound to gutt, by the subtype of this rule. Instead we lose the semantics of 'han ga seg selv seg selv', but we have to live with that...
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    SYNSEM.NON-LOCAL.SLASH #slash,  ; this just a desperate attempt...
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #21,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #head,
;    HEAD-DTR.EXTRACTED-FROM #extracted-from,
;    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #has-a-v-comp,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #dirarg,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
;    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ACCUSATIVE +,
					EXPLETIVE -],    
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [BOUNDED #2],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-V +,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED #hm,
;    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,  ; too strong
    NON-HEAD-DTR.SYNSEM.LOCAL.SUBJ-ONLY - ].

; note funny asymmetry here...:
;head-verb-reg-comp-phrase := head-verb-comp-phrase-sup &
;  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head ].

; ,
;                                              ANAPH-TYPE [REFL-II +]
; NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [SORT referential-thing],

; drop NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY non-measurnoun,
;    SORT referential-thing - to allow "han kaster fire"

#|
head-verb-reg-comp-phrase := head-verb-comp-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head,    
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [SORT item-specification],
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-MOUNTABLE #3 & [FIRST [ANAPH-INDX #1]],
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.BINDING [ LEX-TAME - ]].

head-verb-comp-phrase := head-verb-reg-comp-phrase &
  [ SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CTXT.DISC-BOUND - ].
|#

; not just for NPs, but also PPs as PREDICs; not any more - head-verb-prepcomp-phrase are for these
head-verb-comp-phrase := head-verb-comp-phrase-sup &
  [ SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
;    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -, ; cannot be used, blocks 'jeg ser ni av guttene', where 'ni' currently undergoes card-to-bare-n
;    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nominal-or-connect-n & [ACCUSATIVE +],    
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [SORT item-specification],; han m√• hit
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    NON-HEAD-DTR.SYNSEM.LOCAL.BINDING [ LEX-TAME - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CTXT.DISC-BOUND - ].

head-verb-prepcomp-phrase := head-verb-comp-phrase-sup &
  [ SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
;    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra,    
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [SORT item-specification],; han m√• hit
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    NON-HEAD-DTR.SYNSEM.LOCAL.BINDING [ LEX-TAME - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CTXT.DISC-BOUND - ].

head-verb-clit-comp-phrase-sup := head-verb-comp-phrase-sup &
 [ SYNSEM.LOCAL.CLIT-SITE-OPEN +,
   SYNSEM.LOCAL.ADJ-SITE-OPEN +,
   HEAD-DTR.SYNSEM.LOCAL.CLIT-SITE-OPEN +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ACCUSATIVE +],    
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron & [KEYS.KEY persprn],
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [WH -,
                                              SORT referential-thing],
   NON-HEAD-DTR.SYNSEM.LEX +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CTXT pron-discbnd ].

; for "seg" to be bound outside minimal VP
head-verb-reflclit-comp-phrase := head-verb-clit-comp-phrase-sup &
  [ SYNSEM.LOCAL.WAIT-BND-RESP #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-MOUNTABLE #3 & [FIRST [ANAPH-TYPE [REFL-II -]]],
    NON-HEAD-DTR.SYNSEM.LOCAL.BINDING [ BOUND +,
                                        REFL-I +,
                                        LEX-TAME - ]].

; for lexically bound reflexives
head-verb-tame-comp-phrase := head-verb-clit-comp-phrase-sup &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.BINDING [ BOUND +,
                                        REFL-I +,
                                        REFL-II -,
                                        LEX-TAME + ]].

; SYNSEM.LOCAL.CLIT-PRON-CONFIRMED - means that only s-adv or other 'first-after-finite-verb' can sanction the use of this rule. To eliminate ambiguity when there is no 'disambiguating' adverb
head-verb-pronclit-comp-phrase := head-verb-clit-comp-phrase-sup &
  [ SYNSEM.LOCAL.CLIT-PRON-CONFIRMED bool, ; from '-'
    SYNSEM.LOCAL.CAT.HEAD.MAIN-CL +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron,
    NON-HEAD-DTR.SYNSEM.LOCAL.BINDING [ REFL-I -,
                                        REFL-II -,
                                        LEX-TAME - ]].


; impossible/hard to restrict head-verb-comp-rule to not cover the same constructions, so commented this out in rules.tdl
head-verb-meas-comp-phrase := head-verb-comp-phrase-sup &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ACCUSATIVE +],    
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY measurnoun,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT measure-unit ].


head-verb-expl-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT #3,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.COMPS-BEGUN +,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
 	SYNSEM.LOCAL.CAT.VAL.COMPS 1-list,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD expl-pron,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX expl-ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].

; to start with a
; restr ADJ-SITE-OPEN - on NON-HEAD-DTR  in order to prevent
; "*gutten vil komme ikke". But it also prevents "jeg s√• gutten ikke komme",
; with subord negation, which should be allowed. So, deleted the restr
;SYNSEM.NON-LOCAL #4,
;    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
head-verb-verbal-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.BND-RESP #resp,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-SUBORD-OPEN +,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT -,
    SYNSEM.LOCAL.COMPS-BEGUN +,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #1,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT +,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    EXTRACTED-FROM #10,
    SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.EXTRACTED-FROM #10,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.INV -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ list,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR antilist,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    NON-HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +].


head-verb-bareinfin-comp-phrase := head-verb-verbal-comp-phrase &
  [ SYNSEM.LOCAL.BND-RESP #2,
    SYNSEM.LOCAL.CAT.HEAD.MAIN-CL #mcl,
;    SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL #mcl,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL +,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #2,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.INV -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.WH-COMPLETE - ].


head-auxverb-bareinfin-comp-phrase := head-verb-verbal-comp-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MAIN-CL #mcl,
    SYNSEM.LOCAL.BND-RESP #2,
    SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-aux,
    HEAD-DTR.SYNSEM.LEX +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL #mcl,
    NON-HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.INV -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.WH-COMPLETE -  ].

; subsumes perf participle and passive participle,and also complex passive
head-verb-perf-comp-phrase := head-verb-verbal-comp-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MAIN-CL #mcl,
    SYNSEM.LOCAL.BND-RESP #2,
    SYNSEM.LOCAL.WAIT-BND-RESP #3,
    HEAD-DTR.SYNSEM.LEX +,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-aux,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL #mcl,
    NON-HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE perf,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #3 ].

    
head-verb-indirwhquest-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-SUBORD-OPEN +,
;    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT -,
    SYNSEM.NON-LOCAL #4,
    SYNSEM.LOCAL.COMPS-BEGUN +,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #1,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.BND-RESP #3,
;    SYNSEM.LOCAL.HAS-WH-MOVED #hm,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
;    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT +,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.NON-LOCAL #4,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3,
    EXTRACTED-FROM #10,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MAIN-CL -,
    NON-HEAD-DTR.EXTRACTED-FROM #10,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ DECL - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT +,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    ;NON-HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED #hm,
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !> ].

head-verb-indirwhquest-y-n-comp-phrase := head-verb-indirwhquest-comp-phrase &
  [ NON-HEAD-DTR head-complementizer-comp-fin-phrase ].

head-verb-indirwhquest-subjwh-comp-phrase := head-verb-indirwhquest-comp-phrase &
  [ NON-HEAD-DTR head-subjfiller-subord-wh-phrase ].

head-verb-indirwhquest-objwh-comp-phrase := head-verb-indirwhquest-comp-phrase &
  [ NON-HEAD-DTR head-filler-subord-wh-phrase ].

head-verb-indirwhquest-advwh-comp-phrase := head-verb-indirwhquest-comp-phrase &
  [ NON-HEAD-DTR adv-interr-mod-front-subordcl-phrase ].



; when doing copulas, it should perhaps promote AGR-values from the adj.
; But, with the abs-adj treatment, where "fint" in e.g. "det er fint at du kom"
; is lexically neuter, no need for phrasal enforcement arises.
head-verb-adj-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.NON-LOCAL #1,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.BND-RESP #37,
;    SYNSEM.LOCAL.WAIT-BND-RESP #38,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
;    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg & [ WEAK - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
 ;   NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #1 ].

#|
head-verb-adj-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.NON-LOCAL #1,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg & [ WEAK - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #1 ].
|#

head-verb-prep-comp-phrase-sup := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.HEAD verb & [KEYS.KEY #key],
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.NON-LOCAL #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.BND-RESP #resp,
    SYNSEM.LOCAL.WAIT-BND-RESP #wresp,
    EXTRACTED-FROM #5,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb & [KEYS.KEY #key],
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD [KEYS.KEY #keys]],...>,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #wresp,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED +,
                                                     KEYS.KEY #keys],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #2,
    NON-HEAD-DTR.EXTRACTED-FROM #5 ].

;head-verb-preprais-comp-phrase := head-verb-prep-comp-phrase-sup &
;  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY rais] ].

; tentatively commenting these rules away in rules.tdl. They seem to always be paralleled by more general rules
head-verb-prepsit-comp-phrase := head-verb-prep-comp-phrase-sup &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY index-sit1] ].
; "Jon lurer p√• hva som skjer"
; having suspended prep-indirwhquest-word, this rule is non-operative
;head-verb-prepindirwhquest-comp-phrase := head-verb-prep-comp-phrase-sup &
;  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-comp & [KEYS.KEY indirqu] ].


; extending it to cover 'han er fra Kairo'
head-cop-prepadv-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD copula,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY index-sit1],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].

; previously NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv & [KEYS.KEY adv-selct] -
; changed to NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv & [KEYS.KEY dir], to make
; more inclusive
; differs from head-verb-particleshift-comp-phrase in NOT requiring one COMP 
; more. Difference could be sharpened - "sparke tilbake ballen" gets two
; parses - but if we do, we lose "gutten ser ut til √• komme"
head-verb-advparticle-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY pcl],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LEX bool ].

; assume KEYS.KEY index-sit is too strict: we also want "ha Ola tilbake"
; trying 'SELECTED -' instead of orig '+'
; MOD <> in order to avoid preps designed for modifying an adverb or prep
; but that lost us all the Path'-cases and shifted particles
;,
;						      MOD <[LOCAL.CAT.HEAD verb-all]>
; NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv -> adv. 
; before that, comment it out, since head-verb-comp-rule seems to cover all
head-verb-adverb-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    SYNSEM.LOCAL.BND-RESP #4,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv & [SELECTED -,
					      MOD <[LOCAL.CAT.HEAD verb-all]>],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #4].

head-verb-mannadverb-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD.KEYS.KEY fct-spec]>,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb & [KEYS.KEY advoblvb],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv & [KEYS.KEY adv-m,
                                              SELECTED +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1].

; this rule overlaps too much with head-verb-adverb-comp-phrase, so will be for the time being commented out.
; differs from head-verb-advparticle-comp-phrase in requiring one more COMP
; Difference should be sharpened - "sparke tilbake ballen" gets two parses
head-verb-particleshift-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CONT.HOOK.INDEX #1]>,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #2,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv-reg & [KEYS.KEY pathconsumpt-dir,
                                                  SELECTED + ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].

head-verb-ppshift-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CONT.HOOK.INDEX #1]>,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].


head-verb-som-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.WAIT-BND-RESP #2,
    SYNSEM.LOCAL.CLIT-PRON-CONFIRMED #conf,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #2,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED #conf,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY predcomp ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].

; by     SYNSEM.LOCAL.BND-RESP #2,  we manage to catch reflexives that fail to have a binder. Of course, by this point, they should have been bound anyway, but if we don't mediate the track upwards, there is no arrest made.
; However, with this, "det hjelper √• sette seg" fails to parse, because 'seg', being ref-ind, fails to unify with the expletive 'det', as the mechanics dictate. TODO is to devise a way of releasing the reflexive at the point when absinf combines, but that we don't have yet. Hence we get a lot of overgenerations of non-bound reflexives. Short term solution: create a special version of the present rule for absinf-combination.
;SYNSEM.NON-LOCAL #4,
;NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,

  head-complementizer-comp-phrase-sup := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
;    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
;    SYNSEM.LOCAL.WAIT-BND-RESP #2,
;    SYNSEM.LOCAL.BND-RESP #2,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    EXTRACTED-FROM #6,
;    SYNSEM.NON-LOCAL #nonlocal,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comp & [INV #inv],
    NON-HEAD-DTR.EXTRACTED-FROM #6,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [COMPS <>,
                                       ICOMPS <>],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    NON-HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV #inv],
;    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #2,
;    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #2,
;    NON-HEAD-DTR.SYNSEM.NON-LOCAL #nonlocal,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init ].

head-complementizer-comp-fin-phrase := head-complementizer-comp-phrase-sup & 
  [ SYNSEM.LOCAL.BND-RESP #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD fin-comp,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #2 ].

head-complementizer-comp-absinf-phrase := head-complementizer-comp-phrase-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #varg,
    HEAD-DTR [SYNSEM.LOCAL.CAT.HEAD infin-comp & [ TRANSPAR -,
						   DECL +,
						   KEYS.KEY infinit-comp-arb ]],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg].

head-complementizer-comp-equinf-phrase := head-complementizer-comp-phrase-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #varg,
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
    SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>,
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
    HEAD-DTR [SYNSEM.LOCAL.CAT.HEAD infin-comp & [ TRANSPAR +,
						   DECL +,
						   KEYS.KEY infinit-comp-eq ]],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #varg,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>].

;SYNSEM.NON-LOCAL #4,
;NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
; gave too many parses with multiple PPS:   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adj,

head-complementizer-adj-or-prep-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-comp,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj & [WEAK -,
					      KEYS.KEY propt],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <> ].

head-complementizer-noun-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ list,
    SYNSEM.NON-LOCAL #4,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comp,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD - ].

;NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #2,
 ;   NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #3,
    
; NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD infin-comp  since head-verb-comp-rule takes care of that-clauses  - - no more
;SYNSEM.NON-LOCAL #4,
;NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
head-verb-inf-or-s-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.BND-RESP #2,
    SYNSEM.LOCAL.WAIT-BND-RESP #3,
    SYNSEM.LOCAL.CAT.VAL.COMPS list,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #1,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT -,
    SYNSEM.LOCAL.COMPS-BEGUN +,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.NON-LOCAL #nonlocal,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #1,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #3,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD glob-comp & [ DECL +,
                                                KEYS.KEY comptizer ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX event & [E.MOOD indicative],
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #nonlocal ].

; "hun sier ja"
head-verb-interjct-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.BND-RESP #2,
    SYNSEM.LOCAL.CAT.VAL.COMPS list,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #1,
    SYNSEM.NON-LOCAL #4,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #1,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD interjection & [ KEYS.KEY interjct],
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX event & [E.MOOD hortative],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <> ].

; give a SORT value to those verbs that undergo this rule - "kaste
; til Ola" - and include this feature also in this rule, to
; exclude v√¶re_3 from undergoing it.
head-verb-2comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS olist,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <> ].

; actually not used Apr 23
head-cop-adj-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD copula,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].

head-cop-prep-adv-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD copula,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].

; used to have TENSE infin, perhaps for tough-adj, but must also accommodate
; "uvistt hvorvidt han kommer", where the CP is present/past
;SYNSEM.NON-LOCAL #1,
;, NON-HEAD-DTR.SYNSEM.NON-LOCAL #1
; ;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD glob-comp & [TRANSPAR -], outcomment loses 'uvisst hvem som ...'  but leaves in some unwanted inf-comps instead
head-adjective-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.BND-RESP #resp,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    SYNSEM.LOCAL.DERIVED-HEAD #deriv,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj,  ; not adj-reg - this is used for tough adj etc
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #deriv,
    NON-HEAD-DTR.INFLECTED +,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD glob-comp & [TRANSPAR -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-or-comp & [INV -],
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
 ;   NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE tense ].

head-adjective-np-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.BND-RESP #resp,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    SYNSEM.LOCAL.DERIVED-HEAD #deriv,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomps,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #deriv & -,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT - ].


head-prep-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.HEAD #head & prep-ultra & [ KEYS.KEY actv-prep ],
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.IDIOMOD #2,
;    SYNSEM.NON-LOCAL #4,
    SYNSEM.LOCAL.CAT.QVAL #71,
    SYNSEM.LOCAL.XCAT #81,
    SYNSEM.LOCAL.BND-RESP #3,
    SYNSEM.LOCAL.CAN-CMB-V #72,
    EXTRACTED-FROM #10,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #head,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #71,
    HEAD-DTR.SYNSEM lex-synsem & [IDIOMOD #2],
    HEAD-DTR.EXTRACTED-FROM #10,
    HEAD-DTR.SYNSEM.LOCAL.XCAT #81,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-V #72,
;    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
;    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD poss-subj-head & [ACCUSATIVE +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
	NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind,	; EAA. Added to avoid problems in NorMal. LH believes this to be problematic. LH. Yes, he does, we lose "..synge for √• gjenopprette livsgleden.  Made a new rule, see below  
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD bool,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-MOUNTABLE #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3 ].

head-prep-for-√•-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.IDIOMOD #2,
;    SYNSEM.NON-LOCAL #4,
    SYNSEM.LOCAL.CAT.QVAL #71,
    SYNSEM.LOCAL.XCAT #81,
    SYNSEM.LOCAL.BND-RESP #3,
    SYNSEM.LOCAL.CAN-CMB-V #72,
    SYNSEM.LOCAL.CAT.HEAD prep & [KEYS.KEY index-sit1],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PATH-TELIC -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #71,
    HEAD-DTR.SYNSEM lex-synsem & [IDIOMOD #2],
;    HEAD-DTR.EXTRACTED-FROM #10,
    HEAD-DTR.SYNSEM.LOCAL.XCAT #81,
    HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-V #72,
;    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !>,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
;    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD infin-comp & [TRANSPAR +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;	NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind,	; EAA. Added to avoid problems in NorMal. LH believes this to be problematic. LH. Yes, he does, we lose "..synge for √• gjenopprette livsgleden. This rule is to compensate
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD bool,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-MOUNTABLE #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3 ].

; removed NON-HEAD-DTR head-complementizer-comp-phrase - but why?
; for ICOMPS P+clause next step up - "om + at han kommer"
head-prep-compclause-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS list,
    SYNSEM.NON-LOCAL #4,
    SYNSEM.LOCAL.WAIT-BND-RESP #2,
    SYNSEM.LOCAL.BND-RESP #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED +,
                                                 KEYS.KEY clse ],
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR [SYNSEM.LOCAL.CONT.HOOK.INDEX event & [E.MOOD indicative,
														E.TENSE finite]],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3 ].

;,
;                                                 KEYS.KEY clse
; EAA. Added & [INV - ]¬†to the head on NON-HEAD-DTR. MalGram-reasons, but I expect this to be a vaild constraint.
head-prep-bareclause-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS list,
    SYNSEM.NON-LOCAL #4,
    SYNSEM.LOCAL.WAIT-BND-RESP #2,
    SYNSEM.LOCAL.BND-RESP #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-comp,
    ;HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adjct-comp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV -,
						    MOD <> ],
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX event & [E.MOOD indicative,
                                                        E.TENSE finite],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3 ].

; for "dersom+clause"
head-adjctcomp-bareclause-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS list,
    SYNSEM.NON-LOCAL #4,
    SYNSEM.LOCAL.WAIT-BND-RESP #2,
    SYNSEM.LOCAL.BND-RESP #3,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-comp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adjct-comp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV -,
						    MOD <> ],
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX event & [E.MOOD indicative,
                                                        E.TENSE finite],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3 ].

; for adjunct combination next step up - "l√∏pe for at han vinner"
; cf also head-prep-infclause-comp-phrase, with "√•"
head-prep-regclause-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS list,
    SYNSEM.NON-LOCAL #4,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED - ],
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR head-complementizer-comp-fin-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD fin-comp,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list ].

; removed ,
;    NON-HEAD-DTR basic-head-filler-phrase,
; to get both "lure p√• hvem som" and "lure p√• hvorvidt"
; having suspended prep-indirwhquest-word, this rule is non-operative
head-prep-indirwhquestclause-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS list,
    SYNSEM.NON-LOCAL #4,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-comp & [SELECTED +,
                                                 KEYS.KEY indirqu ],
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR  [SYNSEM.LOCAL.CONT.HOOK.INDEX event & [E.MOOD indicative,
                                                         E.TENSE finite]],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-or-comp & [ DECL - ],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list ].

; cl-adjct rather than prep-or-adv
head-prep-prepadv-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD cl-adjct,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ad-event,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].


#|
head-prep-bareclause-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS list,
    SYNSEM.NON-LOCAL #4,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY index-sit ],
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR head-subject-phrase & [SYNSEM.LOCAL.CONT.HOOK.INDEX event & [E.MOOD indicative,
                                                                              E.TENSE finite]],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR list ].
|#

; removed HEAD noun in second ARG, to at least parse other types of complement,
head-cmpardep-reg-comp-phrase := basic-head-comp-phrase & head-initial &
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-dep-reg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL.SPEC #2,
    ARGS < [SYNSEM.LOCAL.CAT [HEAD cmpar-dep-reg,
                              VAL [SPR <>,
                                   SPEC #2]]],
    [ SYNSEM.LOCAL.CAT [VAL [SPR <>,
                             SPEC <>,
                             COMPS <>]],
      SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
      SYNSEM.CMPAR-SAT - ]>,
    C-CONT [ RELS <! !>,
             HCONS <! !> ]].

head-cmpardep-close-comp-phrase := basic-head-comp-phrase & head-initial &
  [ SYNSEM.LOCAL.CAT.HEAD cmpar-dep-close,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL.SPEC #2,
    ARGS < [SYNSEM.LOCAL.CAT [HEAD cmpar-dep-close,
                              VAL [SPR <>,
                                   SPEC #2]]],
    [ SYNSEM.LOCAL.CAT [HEAD noun,
                        VAL [SPR <>,
                             SPEC <>,
                             COMPS <>]],
      SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [ SORT measure-unit ] ]>,
    C-CONT [ RELS <! !>,
             HCONS <! !> ]].

     
head-cmpadv-comp-phrase := basic-head-comp-phrase & head-initial &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #4,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.CAT.HEAD cmpar-close-adv & [ DEGREE comparative ],
    SYNSEM.LOCAL.CAT.VAL.SPEC #5,
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD cmpar-close-adv & [ DEGREE comparative ],
                                  VAL [ SPR list,
                                        SPEC #5,
                                        COMPS cons ]],
                            CONT [ HOOK.INDEX.WH #9,
                                   HOOK.XARG #2,
                                   HOOK.LTOP #4,
                                   RELS.LIST.FIRST.ARG2 #1,
                                   RELS.LIST.REST.FIRST.ARG2 #2 ]]],
    [ SYNSEM.LOCAL.CAT [HEAD cmpar-dep-close,
                        VAL [ SPR <>,
                              SPEC <>,
                              COMPS <> ]],
      SYNSEM.LOCAL.CONT.HOOK.INDEX #1 ] >,
    C-CONT [ RELS <! !>, 
             HCONS <! !> ]].


head-prep-s-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.NON-LOCAL #4,
    SYNSEM.IDIOMOD #2,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-comp,
    HEAD-DTR.SYNSEM.IDIOMOD #2,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC list,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>].

;  & [ KEYS.KEY rais ]
head-prep-rais-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #top,
    SYNSEM.NON-LOCAL #4,
;    SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>,
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
    SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
;    HEAD-DTR [SYNSEM.LOCAL.CAT.HEAD prep], tried this to get "han sover uten √• puste", with "uten..." combined via atelic-vp-mod-rule; but lost 19 rais-constr, and return to using prep-comp
    HEAD-DTR [SYNSEM.LOCAL.CAT.HEAD prep-comp],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #top,
    NON-HEAD-DTR [SYNSEM.LOCAL.CONT.HOOK.XARG #1],
    NON-HEAD-DTR [SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>,
		  SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl],
    NON-HEAD-DTR head-complementizer-comp-phrase-sup,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD infin-comp,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>].

; head-prep-comp-phrase seems to be sufficient. so, comment out the rule
; for adjunct combination next step up - "l√∏pe for √• vinne"
; cf also head-prep-regclause-comp-phrase, with "at"


head-prep-infclause-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD verb-all,
                                 LOCAL.CONT.HOOK.XARG #1] >,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.NON-LOCAL #4,
    SYNSEM.LOCAL.WAIT-BND-RESP #2,
    SYNSEM.LOCAL.BND-RESP #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep & [ KEYS.KEY index-sit1 ],
    NON-HEAD-DTR head-complementizer-comp-phrase-sup,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD infin-comp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC list,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3 ].



head-coord-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #2,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF #sf, - this is fine for v-coord, but blocks for n. Consider two different such pharses
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    SYNSEM.LOCAL.XSORT #7,
    SYNSEM.LOCAL.XCAT.HEAD.COORDINABLE #coord,
    SYNSEM.LOCAL.COORD-POL #12,
    SYNSEM.NON-LOCAL #5,
    SYNSEM.LOCAL.XCAT.VAL.SUBJ #subj,
    SYNSEM.LOCAL.CAT.VAL.COMPS #9,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #10,
    SYNSEM.LOCAL.DERIVED-HEAD #11,
    SYNSEM.LOCAL.BND-RESP #3,
    SYNSEM.LOCAL.HEAD-SUBJ-APPLIED #hs,
    FRONT-TO-FILL #8,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD coord,
    HEAD-DTR.SYNSEM.LOCAL.COORD-POL #12,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [WH #2,
;                                               SF #sf,
					       SORT #7 ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #subj,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #9,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #10,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-POL #12,
    NON-HEAD-DTR.SYNSEM.LOCAL.MUST-APP -,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-COORD-COMP +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.COORDINABLE #coord,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #5,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #11,
    NON-HEAD-DTR.SYNSEM.LOCAL.HEAD-SUBJ-APPLIED #hs,
    NON-HEAD-DTR.FRONT-TO-FILL #8 ].

;SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD #3] >,
head-wordcoord-comp-phrase := head-coord-comp-phrase &
 [ SYNSEM.LOCAL.COORD-RELEASED +,
   SYNSEM.LOCAL.XCAT.HEAD #3,
   HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD word-coord,
   HEAD-DTR.FRONT-TO-FILL #8,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #3,
   NON-HEAD-DTR.FRONT-TO-FILL #8].

head-wordcoord-nonequal-comp-phrase := head-coord-comp-phrase &
 [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD word-coord,
   SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD adv-reg & [KEYS.KEY dir]] >,
   SYNSEM.LOCAL.COORD-RELEASED +,
   SYNSEM.LOCAL.XCAT.HEAD #3 & verb-all,
   NON-HEAD-DTR.SYNSEM.LOCAL.XCAT.HEAD #3,
   NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE infin ].


#|
head-wordcoord-comp-phrase := head-coord-comp-phrase &
 [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD word-coord,
   SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD #3] >,
   SYNSEM.LOCAL.XCAT.HEAD #3,
   SYNSEM.LOCAL.COORD-RELEASED +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #3].
|#

; If we want to allow listing ,  ,  , wthout final "og" through, then
; the part 'SYNSEM.LOCAL.COORD-RELEASED -,' can be omitted
; ,
;   NON-HEAD-DTR.SYNSEM.LEX - 

head-commacoord-comp-phrase := head-coord-comp-phrase &
 [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comma-coord,
;   SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD #3] >,
   SYNSEM.LOCAL.COORD-RELEASED -,
   SYNSEM.LOCAL.XCAT.HEAD #3,
   SYNSEM.LOCAL.HAS-PUNCT +,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #3 ].

head-numbercoord-comp-phrase := head-coord-comp-phrase &
 [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD word-coord,
   SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD comm-noun,
                                LOCAL.CONT.HOOK.INDEX.SORT number-unit,
                                LOCAL.CAT.HEAD.KEYS.KEY measnoun] >,
   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD cardnum].


head-quant-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.BINDING.BOUND -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #sort,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD allquant & [KEYS.KEY #key],
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #sort,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [ DEFINITE +,
                                                KEYS.KEY #key]].

head-quant-gen-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.BINDING.BOUND -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #sort,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD allquant & [KEYS.KEY #key],
 ;   NON-HEAD-DTR poss-general-genitive-phrase & [INFLECTED +],
    NON-HEAD-DTR.C-CONT.RELS.LIST.FIRST poss-rel,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #sort,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [ DEFINITE -,
                                                KEYS.KEY #key ],
    NON-HEAD-DTR [INFLECTED +]].

head-part-prep-comp-phrase := basic-head-comp-phrase & head-initial & rule &
  [  SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #sort,
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD part-prep,
     HEAD-DTR.SYNSEM.LEX +,
     NON-HEAD-DTR.INFLECTED +,
     NON-HEAD-DTR.RULE card-ok,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
     SYNSEM.LOCAL.CONT.HCONS #1,
     SYNSEM.LOCAL.BINDING.BOUND - ,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #sort,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HCONS #1].


head-part-prep-comp-phrase2 := basic-head-comp-phrase & head-initial & rule &
  [  SYNSEM.LOCAL.CAT.VAL.SPR < [LOCAL.CAT.HEAD card] >,
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD part-prep,
     NON-HEAD-DTR.INFLECTED +,
     NON-HEAD-DTR.RULE card-ok,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>].

head-possparticle-comp-phrase-sup := basic-head-comp-phrase & head-final & rule &
  [  SYNSEM.LOCAL.CAT.VAL [SPEC < [LOCAL.CAT.HEAD.DEFINITE -,
                                   LOCAL.CAT.HEAD.DEF + ] >],
     SYNSEM.LOCAL.BND-RESP #resp,
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD possparticle,
     NON-HEAD-DTR.INFLECTED +,
     NON-HEAD-DTR.RULE card-ok,
     NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind ].


head-possparticle-comp-noun-phrase := head-possparticle-comp-phrase-sup &
 [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun ].
; maybe have more, but most other candidates can project to noun by l-rule
head-possparticle-comp-pronoun-phrase := head-possparticle-comp-phrase-sup &
 [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron  & [KEYS.KEY interr-word] ].



;,
;				    QUE 0-dlist & [ LIST null ]
;, 
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop
;HEAD-DTR.SYNSEM.LOCAL.CAT icomps-cat,
    
#|
basic-head-icomp-phrase := head-valence-phrase & head-compositional &
			  binary-headed-phrase & phrasal &
  [ SYNSEM canonical-synsem &
	   [ LOCAL.CAT [ VAL [ SUBJ #subj,
			       COMPS #comps,
			       ICOMPS #icomps,
			       SPR #spr ]],
             NON-LOCAL [ SLASH [ LIST #first,
				 LAST #last ],
			 REL 0-dlist ] ],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    EXTRACTED-FROM #11,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ VAL [ SUBJ #subj,
					COMPS #comps,
                                        ICOMPS < #synsem . #icomps >,
                                        SPR #spr ]] ],
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    NON-HEAD-DTR.EXTRACTED-FROM #11,
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL [ SLASH [ LIST #first,
					    LAST #last ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].
|#

basic-head-icomp-phrase := head-valence-phrase & head-compositional &
			  binary-headed-phrase & phrasal &
  [ SYNSEM canonical-synsem &
	   [ LOCAL.CAT [ VAL [ SUBJ #subj,
			       COMPS #comps,
			       ICOMPS #icomps,
			       SPR #spr ]],
             NON-LOCAL [ SLASH [ LIST #first,
				 LAST #last ],
			 REL 0-dlist ] ],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    EXTRACTED-FROM #11,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ VAL [ SUBJ #subj,
					COMPS #comps,
                                        ICOMPS < #synsem . #icomps >,
                                        SPR #spr ],
				  QVAL.OBL1.LOCAL.CAT.QVAL #dobj] ],
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #dobj,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.EXTRACTED-FROM #11,
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL [ SLASH [ LIST #first,
					    LAST #last ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].



; check as to 'KEYS.KEY prim-mod'
; since head-prep-comp-phrase doesn't declare any WAIT-BND-RESP, 
; the part  SYNSEM.LOCAL.WAIT-BND-RESP #38 is here idle, and we lack a way
; of propagating binding out of an infinitive - so, "Jon ber meg snakke om seg"
; does not get the "seg" bound. This remains a problem.
;SYNSEM.NON-LOCAL #2,
;NON-HEAD-DTR.SYNSEM.NON-LOCAL #2,
;NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #varg,
;HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
; perhaps too strong:    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED +], that rules out 'han bor i Oslo', where prep is 'free' locative
        
head-verb-icomp-phrase := basic-head-icomp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS list,
    SYNSEM.LOCAL.CAT.VAL.COMPS #comps,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT -,
    SYNSEM.LOCAL.BND-RESP #37,
;    SYNSEM.LOCAL.WAIT-BND-RESP #38,
    FRONT-TO-FILL #front,
    EXTRACTED-FROM #5,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #comps,
 ;   HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
 ;   HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
 ;   HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    NON-HEAD-DTR.FRONT-TO-FILL #front,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
;    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY prim-mod],
 ;   NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED +],
 ;                                                    KEYS.KEY prim-mod],
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-V +,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.EXTRACTED-FROM #5].

; [KEYS.KEY fct-actv-spec --- pass-prep
head-actv-verb-icomp-phrase := head-verb-icomp-phrase &
  [  SYNSEM.LOCAL.CAT.VAL.COMPS <>,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [VOICE active ],
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY actv-prep ]].

   ; [KEYS.KEY fct-pass-spec ]
head-pass-verb-icomp-phrase := head-verb-icomp-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [VOICE passive ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY fct-spec] ].

head-actv-verb-icomp-infinepon-phrase := head-verb-icomp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.VARG #2,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD infin-comp & [TRANSPAR +],
                                  LOCAL.CONT.HOOK [INDEX #2]]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [VOICE active ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY actv-prep ]].

;head-actv-verb-icomp-finepon-phrase := head-verb-icomp-phrase &
;  [ SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD fin-comp]>,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [VOICE active ],
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY actv-prep ]].

; SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD fin-comp,
;                                  LOCAL.CONT.HOOK [LTOP #2]]
head-actv-verb-icomp-finepon-phrase := head-verb-icomp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.VARG semarg,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD fin-comp,
                                  LOCAL.CONT.HOOK [LTOP semarg]]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [VOICE active ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY actv-prep ]].

head-actv-verb-icomp-fineponWH-phrase := head-verb-icomp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.VARG semarg,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD verb-all,
                                  LOCAL.CONT.HOOK [LTOP semarg]]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [VOICE active ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY actv-prep ]].

; not clear what distinguishes this from head-verb-icomp-phrase so much that one needs two. Tentatively comment out the rule. They double for 'det setter seg en gutt her', but with identical mrs
head-verb-loc-icomp-phrase := basic-head-icomp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS list,
    SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT -,
    SYNSEM.LOCAL.BND-RESP #37,
    SYNSEM.LOCAL.WAIT-BND-RESP #38,
    SYNSEM.NON-LOCAL #2,
    EXTRACTED-FROM #5,
    FRONT-TO-FILL #front,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    HEAD-DTR.FRONT-TO-FILL #front,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [SELECTED -,
                                                     KEYS.KEY prim-mod],
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX ref-ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [XARG #1,
                                         INDEX[SORT non-fix-point,
                                               ROLE xdim-to-xdim-spatial]],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #2,
    NON-HEAD-DTR.EXTRACTED-FROM #5 ].

head-actv-verb-loc-icomp-phrase := head-verb-loc-icomp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [VOICE active ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY actv-prep ],
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>].
; [KEYS.KEY fct-pass-spec ]
head-pass-verb-loc-icomp-phrase := head-verb-loc-icomp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [VOICE passive ],
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>].


head-verb-detachposs-phrase := basic-head-icomp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ <synsem>,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep & [SELECTED +,
                                               KEYS.KEY detch ],
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].

head-verb-preprais-comp-phrase := basic-head-icomp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    SYNSEM.LOCAL.CAT.QVAL.OBL1 #obl1,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT -,
    SYNSEM.LOCAL.BND-RESP #37,
    SYNSEM.LOCAL.WAIT-BND-RESP #38,
    SYNSEM.NON-LOCAL #2,
    SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
    SYNSEM.LOCAL.CAT.VAL.SUBJ <[LOCAL.CAT.HEAD.EXPLETIVE #expl]>,
    EXTRACTED-FROM #5,
    FRONT-TO-FILL #front,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS < #obl1 & [LOCAL.CONT.HOOK.LTOP #varg,
						    LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.OBL1 #obl1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    HEAD-DTR.FRONT-TO-FILL #front,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-comp & [KEYS.KEY rais],
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #varg,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-V +,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #2,
    NON-HEAD-DTR.EXTRACTED-FROM #5 ].



head-adjective-icomp-phrase := basic-head-icomp-phrase & head-initial & rule &
  [ SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT -,
    SYNSEM.LOCAL.CAT.VAL.COMPS #8,
    SYNSEM.LOCAL.BND-RESP #37,
    SYNSEM.LOCAL.WAIT-BND-RESP #38,
    SYNSEM.NON-LOCAL #2,
    EXTRACTED-FROM #5,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #8,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    NON-HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    NON-HEAD-DTR.INFLECTED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED +,
                                                     KEYS.KEY fct-actv-spec],
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #2,
    NON-HEAD-DTR.EXTRACTED-FROM #5 ].


correlcoord-mod-phrase := adj-head-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CORRCOORD-CLOSED +,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    HEAD-DTR.SYNSEM.LOCAL.COORD-POL #2,
    HEAD-DTR coordinating-phrase,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR correlative-coord-word & [SYNSEM.LOCAL.CAT.HEAD correl-coord & [ MOD <[LOCAL.COORD-POL #2]>]],
    C-CONT [RELS <! !>,
            HCONS <! !>]  ].


a-mod-phrase-sup := head-mod-phrase & basic-binary-headed-phrase &
  [ SYNSEM phr-synsem,
    SYNSEM.LEX -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adjectival,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #8].

;; some additional types...

a-mod-phrase := a-mod-phrase-sup & adj-head-phrase &
[C-CONT [RELS <! !>,
         HCONS <! !>]]. 

; to accept 'den snille gutt..', and 'den snille sover'- DEFINITE + > DEFINITE bool
a-mod-def-phrase := a-mod-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR cons,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEF + ].

;; Backup. Will introduce split adj-head-phrase and a-mod-phrase so that c-cont may introduce additional EP _commsg...etc so that mal sentence mrs matches ben sentence mrs.
#|

a-mod-phrase := adj-head-phrase &
  [ SYNSEM phr-synsem,
    SYNSEM.LEX -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adjectival,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #8,
    C-CONT [RELS <! !>,
            HCONS <! !>] ].

mal-a-mod-def-phrase := a-mod-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR null,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE +,
    GENRE robust].
|#

a-mod-indef-phrase := a-mod-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CAT.VAL.SPR list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEF -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE -,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.WEAK -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1 ].


;NON-HEAD-DTR.INFL-MORPH #6,
;     HEAD-DTR.INFL-MORPH #6,
     
adjective-mod-phrase-sup := a-mod-phrase-sup & rule &
  [  RULE #3,
     SYNSEM.LOCAL.DERIVED-HEAD #2,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
     HEAD-DTR.RULE #3,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
     HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
     HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #2,
     HEAD-DTR.SYNSEM.LOCAL.SPEC-TO-BARE-N -,
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
     HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj & [KEYS.KEY propt],
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAN-MODIFY + ].

adjective-mod-phrase := adjective-mod-phrase-sup & a-mod-phrase.

; makes "tre gutter" non-wh. To get "hvilke tre gutter", see below

; changing from a-mod-phrase to head-spec-phrase
; see also 'cardinal-word'
#|
card-mod-phrase-sup := complex-spec-n-phrase-sup &
  [  SYNSEM.LOCAL.CONT.HOOK.LTOP #11,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
     SYNSEM.LOCAL.BINDING [ BOUND -,
                            REFL-I - ],
     SYNSEM.LOCAL.CAT.HEAD noun & [DEF #2],
     SYNSEM.LEX -,
     RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [DEF #2],
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #11,
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #10,
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
     HEAD-DTR.RULE [ NEEDS-CARD bool,
                     NOMORE-CARD - ],
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
     C-CONT [ RELS <! quant-relation & [PRED "_udef_q_rel",
					ARG0 #5,
					RSTR #6], 
		    measure-out-rel & [ LBL #8,
					ARG1 #5,
					ARG2 #10]   !>,
	     HCONS <!  [HARG #6,
			LARG #8 ]!>]].
|#

;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #5,
; XARG inst of INDEX  - - LH130613 and why that? lets card 'en' combine with neuter noun. repaired
card-mod-phrase-sup := complex-spec-n-phrase-sup &
  [  SYNSEM.LOCAL.CONT.HOOK.LTOP #11,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
     SYNSEM.LOCAL.BINDING [ BOUND -,
                            REFL-I - ],
     SYNSEM.LOCAL.CAT.HEAD noun & [DEF #2],
     SYNSEM.LEX -,
     RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [DEF #2],
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #11,
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
     HEAD-DTR.RULE [ NEEDS-CARD bool,
                     NOMORE-CARD - ],
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #5,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #11,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG.PNG #1,
     C-CONT [ RELS <! !>,
	     HCONS <! !>]].

#|
; LH040513 - to enable n-connect-spr-phrase for '7 gutter og jeg'
card-mod-phrase := card-mod-phrase-sup &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>].
|#
card-mod-phrase := card-mod-phrase-sup.

card-cum-singspec-mod-phrase := card-mod-phrase-sup &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[ LOCAL.CAT.HEAD noun,
                                 LOCAL.CONT.HOOK.INDEX.PNG.NG sg ]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY takes-sg-spc,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1 ].

card-cum-plurspec-mod-phrase := card-mod-phrase-sup & 
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[ LOCAL.CAT.HEAD noun,
                                 LOCAL.CONT.HOOK.INDEX.PNG.NG pl ]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY takes-pl-spc,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1].

card-cum-adj-mod-phrase := card-mod-phrase-sup & 
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[ LOCAL.CAT.HEAD adj-reg ]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY takes-sg-spc,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1 ].

card-cum-prep-or-adv-mod-phrase := card-mod-phrase-sup & 
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <[ LOCAL.CAT.HEAD prep-or-adv ]>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY takes-sg-spc,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1 ].

adjective-mod-def-phrase := a-mod-def-phrase & adjective-mod-phrase.

adjective-mod-indef-phrase := a-mod-indef-phrase & adjective-mod-phrase &
  [ SYNSEM.LOCAL.CMPAR-PENDING #2,
    SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #4,
    SYNSEM.LOCAL.CAT.HEAD.COMPAR-DEP #dep,
    HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.COMPAR-DEP #dep ].

; #spr to carry on the weak adj's requirements, if any
card-mod-phrase-def := card-mod-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD.KEYS.KEY #key,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD.KEYS.KEY #key,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE +,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1 ].

card-mod-phrase-indef := card-mod-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1 ].

; for "tre gutter" to get "hvilke tre gutter"
card-mod-phrase-indef-with-interr := complex-spec-n-phrase-sup &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < expressed-synsem & [ LOCAL.CONT.HOOK.INDEX.WH + ] >,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
    SYNSEM.LOCAL.BINDING [ BOUND -,
                           REFL-I - ],
    RULE [ NEEDS-CARD -,
           NOMORE-CARD + ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card,
    HEAD-DTR.RULE [ NEEDS-CARD bool,
                    NOMORE-CARD - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #7,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
    C-CONT [ RELS <! quant-relation & [PRED "_udef_q_rel",
					ARG0 #5,
					RSTR #6], 
		    quant-relation & [PRED "_udef_q_rel",
					ARG0 #3,
					RSTR #4], 
		    measure-out-rel & [ LBL #8,
					ARG1 #3 ]   !>,
	     HCONS <![HARG #6,
			LARG #7 ], [HARG #4,
				    LARG #8 ] !>]].

; for "hvor mange gutter"
;  NON-HEAD-DTR measure-quantword-a-phrase &
interr-card-mod-phrase := a-mod-indef-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < >,
    RULE [ NEEDS-CARD - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card,
    NON-HEAD-DTR [SYNSEM.LOCAL.CONT.HOOK.INDEX.WH +],
    HEAD-DTR.RULE [ NEEDS-CARD bool,
                    NOMORE-CARD - ]].

;SYNSEM.LOCAL.CAT.HEAD.LEG-SWITCH +,
    
; "bygg femten"
;SYNSEM.LOCAL.CONT.HOOK.LTOP #11,

card-mod-phrase-head-initial-sup := complex-spec-n-phrase-head-initial &
  [  SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
     SYNSEM.LOCAL.BINDING [ BOUND -,
                            REFL-I - ],
     SYNSEM.LOCAL.CAT.HEAD noun & [DEF #2],
     SYNSEM.LEX -,
     RULE [ NEEDS-CARD -,
            NOMORE-CARD + ],
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun & [DEF #2],
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #11,
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #10,
     HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
     HEAD-DTR.RULE [ NEEDS-CARD bool,
                     NOMORE-CARD - ],
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #8,
     NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
 ;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG #1,
     C-CONT [ RELS <! measure-out-rel & [ ARG1 #5,
					ARG2 #10], 
		    quant-relation & [PRED "_udef_q_rel",
					ARG0 #10,
					RSTR #6], 
		    quant-relation & [PRED "_udef_q_rel",
					ARG0 #5,
					RSTR #12]   !>,
	     HCONS <!  [HARG #6,
			LARG #11 ], [HARG #12,
				     LARG #8 ]!>]].


card-mod-phrase-head-initial := card-mod-phrase-head-initial-sup &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>].

card-mod-phrase-head-initial-indef := card-mod-phrase-head-initial &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEFINITE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1 ].




connector-mod-phrase-sup := headed-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.HAS-PUNCT +,
    SYNSEM.LOCAL.COORD-RELEASED #18,
    SYNSEM.NON-LOCAL.SLASH <! !>,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH <! !> ].


connector-mod-phrase := connector-mod-phrase-sup &
  [ C-CONT [RELS <! !>,
            HCONS <! !>]  ].

connector-mod-phrase-2 := connector-mod-phrase-sup &
  [ C-CONT [RELS <! [] !>,
            HCONS <! !>]  ].

; both for connector-words and for punctuation
connector-leftmod-phrase := connector-mod-phrase & adj-head-phrase.
connector-leftmod-phrase-2 := connector-mod-phrase-2 & adj-head-phrase-2.
; only for punctuation
connector-rightmod-phrase := connector-mod-phrase & head-adj-phrase.

end-punctuation-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & [SORT #1],
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    SYNSEM.LOCAL.HAS-PUNCT +,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.NON-LOCAL.SLASH #slash,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    SYNSEM.LOCAL.BND-RESP #bresp,
    FRONT-TO-FILL #ftf,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bresp,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & [SORT #1],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH  #slash & <! !>,
    HEAD-DTR.FRONT-TO-FILL #ftf,
    C-CONT [RELS <! !>,
            HCONS <! !>]  ].

;MOD < [ LOCAL.CAT.HEAD verb-all ] 
punctuation-mod-for-v-phrase := phrasal &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD head] >].

punctuation-mod-for-ndir-phrase := phrasal &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD noun & [KEYS.KEY dirnoun] ] >].
punctuation-mod-for-n-phrase := phrasal &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD noun ] >].
#|
; produces the wrong tree structure for "gul og frodig sti", but ok mrs,
; as far as the fake mrs'es produced by this and the above type go
connector-mod-phrase2 := adj-head-phrase &
  [ SYNSEM #1,
    ARGS < connector, sign & [ SYNSEM #1 & [ LOCAL.CAT.HEAD adj ]] >].
|#

comma-leftmod-phrase := connector-leftmod-phrase &
  [  ARGS < p-adv-connect-punctuation, []>].
comma-rightmod-phrase-3 := connector-rightmod-phrase &
  [  ARGS < [], p-clse-connect-punctuation >].
comma-rightmod-phrase := connector-rightmod-phrase &
  [  ARGS < [], vcond-connector >].
comma-rightmod-phrase-2 := connector-rightmod-phrase &
  [  ARGS < [], vcond-connector-2 >].
comma-rightmod-interjct-phrase := connector-rightmod-phrase &
  [  ARGS < sign, interject-connect-punctuation >].
comma-rightmod-adj-interjct-phrase := connector-rightmod-phrase &
  [  ARGS < sign, adj-interject-connect-punctuation >].
comma-rightmod-quotation-phrase := connector-rightmod-phrase &
  [  ARGS < right-quote-phrase, quotation-connect-punctuation >].
comma-rightmod-relcl-phrase := connector-rightmod-phrase &
  [  ARGS < [SYNSEM.NON-LOCAL.SLASH <! !>,
             SYNSEM.LOCAL.CAT.HEAD.DECL + ], rel-cl-connect-punctuation >].
comma-leftmod-relcl-phrase := connector-leftmod-phrase &
  [  ARGS < rel-cl-nonrestr-connector, [SYNSEM.NON-LOCAL.SLASH <! !>,
                                        SYNSEM.LOCAL.CAT.HEAD.DECL + ] >].

comma-rightmod-app-phrase := connector-rightmod-phrase &
  [ SYNSEM.LOCAL.MUST-APP +,
    ARGS < [SYNSEM.NON-LOCAL.SLASH <! !> ], app-punctuation >].

comma-leftmod-app-phrase := connector-leftmod-phrase &
  [  SYNSEM.LOCAL.MUST-APP +,
     ARGS < app-nonrestr-punctuation, [SYNSEM.NON-LOCAL.SLASH <! !> ]  >].

period-mod-phrase := end-punctuation-mod-phrase &
  [  ARGS < [], end-punct >].

comma-leftmod-for-v-phrase := comma-leftmod-phrase & punctuation-mod-for-v-phrase.
comma-leftmod-for-ndir-phrase := comma-leftmod-phrase & punctuation-mod-for-ndir-phrase.
comma-rightmod-for-v-phrase := comma-rightmod-phrase-3 & punctuation-mod-for-v-phrase.
comma-rightmod-for-ndir-phrase := comma-rightmod-phrase & punctuation-mod-for-ndir-phrase.
comma-rightmod-for-inv-v-phrase := comma-rightmod-phrase & punctuation-mod-for-v-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ COMPS <>,
                           ICOMPS <>,
                           SPEC <> ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DECL +,
    HEAD-DTR.SYNSEM [LOCAL.RIGHT-ADJ-SITE-OPEN +,
                     LOCAL.CAT.HEAD.INV +]].

; actually not v-phrase at all - 'hvis[adjct-comp] han kommer, s√•...'
comma-rightmod-for-non-inv-v-phrase := comma-rightmod-phrase-2 & punctuation-mod-for-v-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ COMPS <>,
                           ICOMPS <>,
                           SPEC <> ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adjct-comp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DECL +,
    HEAD-DTR.SYNSEM [LOCAL.RIGHT-ADJ-SITE-OPEN +,
                     LOCAL.CAT.HEAD.INV -]].

;punctuation-mod-for-v-phrase &
comma-rightmod-for-interjct-v-phrase := comma-rightmod-interjct-phrase & 
  [ SYNSEM.LOCAL.CAT.VAL [ COMPS <>,
                           ICOMPS <>,
                           SPEC <> ],
    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
;    HEAD-DTR interjection-phrase & [SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop],
    NON-HEAD-DTR [SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop]].

comma-rightmod-for-quotation-v-phrase := comma-rightmod-quotation-phrase & punctuation-mod-for-v-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ COMPS <>,
                           ICOMPS <>,
                           SPEC <> ],
    HEAD-DTR right-quote-phrase ].

comma-rightmod-relsubj-som-phrase := comma-rightmod-relcl-phrase & punctuation-mod-for-n-phrase &
  [ HEAD-DTR head-relative-subject-phrase & [ SYNSEM.LOCAL.CONT.HOOK #1],
    SYNSEM.LOCAL.CONT.HOOK #1].

comma-rightmod-relsubj-√∏-phrase := comma-rightmod-relcl-phrase & punctuation-mod-for-n-phrase &
  [ HEAD-DTR unary-rel-head-filler-phrase & [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1].

comma-rightmod-relcomp-som-phrase := comma-rightmod-relcl-phrase & punctuation-mod-for-n-phrase &
  [ HEAD-DTR rel-head-filler-phrase & [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1].


comma-leftmod-nonrestr-relcomp-phrase:= comma-leftmod-relcl-phrase & punctuation-mod-for-n-phrase &
  [ HEAD-DTR comma-rightmod-relcomp-som-phrase & [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1].

comma-leftmod-nonrestr-relsubj-phrase:= comma-leftmod-relcl-phrase & punctuation-mod-for-n-phrase &
  [ HEAD-DTR comma-rightmod-relsubj-som-phrase & 
             [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
               SYNSEM.LOCAL.CAT.VAL.SPR #2 ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL.SPR #2 ].

; this is a head-adj-phrase, with comma as adjunct. It will combine with an NP,
; succeding and serving as SPR for this NP, by the rule
; comma-rightmod-restr-apposition-phrase (head-init head-spec rule)
comma-rightmod-apposition-phrase := comma-rightmod-app-phrase & punctuation-mod-for-n-phrase &
  [ HEAD-DTR [ SYNSEM.LOCAL.CONT.HOOK #1,
               SYNSEM.LOCAL.CAT.HEAD nominal],
    SYNSEM.LOCAL.CONT.HOOK #1,
    RULE #2,
    SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ SYNSEM.LOCAL.CAT.HEAD nominal ] >,
    HEAD-DTR.RULE #2 & [ NOMORE-CARD + ] ].

; this is a head-adj-phrase, with comma as adjunct. It will combine with an NP,
; succeding and serving as MOD for this NP, by the rule
; rightmod-nonrestr-apposition-phrase (head-init head-adj rule)
comma-leftmod-nonrestr-apposition-phrase := comma-leftmod-app-phrase & punctuation-mod-for-n-phrase &
  [ HEAD-DTR comma-rightmod-apposition-phrase & [ SYNSEM.LOCAL.CONT.HOOK #1],
    SYNSEM.LOCAL.CONT.HOOK #1].


; omitted: SPR antilist and SPR <> in ordr to allow "(mannen smiler.)"
; now applies for all heads
period-mod-for-v-phrase := period-mod-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ #0 & antilist,
                           COMPS #1,
                           ICOMPS #2,
                           SPR #3,
                           SPEC #4 ],
    SYNSEM.LOCAL.HAS-PERIOD +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [MAIN-CL +],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ #0 & antilist,
                                    COMPS #1,
                                    ICOMPS #2,
                                    SPR #3,
                                    SPEC #4 ]].

period-mod-for-n-or-adj-or-adv-phrase := period-mod-phrase &
  [  SYNSEM.LOCAL.CAT.VAL [ SUBJ #0 & antilist,
                           COMPS #1,
                           ICOMPS #2,
                           SPR #3,
                           SPEC #4 ],
    SYNSEM.LOCAL.HAS-PERIOD +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD n-or-adj-or-adv,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [SUBJ #0 & antilist,
                                    COMPS #1,
                                    ICOMPS #2,
                                    SPR #3,
                                    SPEC #4 ]].

period-mod-for-p-phrase := period-mod-phrase &
  [  SYNSEM.LOCAL.CAT.VAL [ SUBJ #0 & antilist,
                           COMPS #1,
                           ICOMPS #2,
                           SPR #3,
                           SPEC #4 ],
    SYNSEM.LOCAL.HAS-PERIOD +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ #0 & antilist,
                                    COMPS #1,
                                    ICOMPS #2,
                                    SPR #3,
                                    SPEC #4 ]].

period-mod-for-interjection-phrase := period-mod-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ #0 & antilist,
                           COMPS #1,
                           ICOMPS #2,
                           SPR #3,
                           SPEC #4 ],
    SYNSEM.LOCAL.HAS-PERIOD +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD interjection,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ #0 & antilist,
                                    COMPS #1,
                                    ICOMPS #2,
                                    SPR #3,
                                    SPEC #4 ]].

connect-p-adv-mod-phrase := connector-leftmod-phrase & 
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD prep-or-adv]>,
    ARGS < p-adv-connect-word, sign & [SYNSEM.LOCAL.HAS-PERIOD -] >].

connect-p-adv-dir-mod-phrase := connector-leftmod-phrase & 
  [ SYNSEM.LOCAL.WH-ISLAND +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD prep-or-adv]>,
    ARGS < p-adv-dir-connect-word, sign & [SYNSEM.LOCAL.HAS-PERIOD -] >].

connect-v-mod-phrase := connector-leftmod-phrase & 
  [ SYNSEM.LOCAL.CAT.VAL [SUBJ #subj & 1-list,
			  SPR #spr,
			  COMPS #comps,
			  ICOMPS #icomps,
			  SPEC #spec],
    SYNSEM.LOCAL.WH-ISLAND +,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.VAL.SUBJ #subj]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD verb-all]>,
    ARGS < v-connector, sign & [SYNSEM.LOCAL.HAS-PUNCT -, ; a hack, for interjec
				SYNSEM.LOCAL.HAS-PERIOD -,
				SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
				SYNSEM.LOCAL.CAT.HEAD.INV -,
				SYNSEM.LOCAL.CAT.VAL [SUBJ #subj,
						      SPR #spr,
						      COMPS #comps,
						      ICOMPS #icomps,
						      SPEC #spec]] >].
; for s-coordination
connect-v-mod-2-phrase := connector-leftmod-phrase & 
  [ SYNSEM.LOCAL.CAT.VAL [SUBJ olist,
			  SPR #spr,
			  COMPS #comps,
			  ICOMPS #icomps,
			  SPEC #spec],
    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD verb-all,
				 LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
				 LOCAL.CAT.VAL.SUBJ olist,
				 LOCAL.HAS-WH-MOVED #bool]>,
    SYNSEM.LOCAL.HAS-WH-MOVED #bool,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
				 SYNSEM.LOCAL.WH-ISLAND +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD verb-all,
					  LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
				 LOCAL.HAS-WH-MOVED #bool]>,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -, ; maybe too strong
    HEAD-DTR.FRONT-TO-FILL -,
    ARGS < v-connector, sign & [SYNSEM.LOCAL.HAS-PERIOD -,
				SYNSEM.LOCAL.CAT.VAL [SUBJ olist,
						      SPR #spr,
						      COMPS #comps,
						      ICOMPS #icomps,
						      SPEC #spec],
				SYNSEM.LOCAL.HAS-WH-MOVED #bool] >].

;connect-a-mod-phrase := connector-leftmod-phrase & 
;  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD noun]>,
;    ARGS < a-connect-word, sign >].

connect-a-mod-phrase := connector-leftmod-phrase & 
  [ SYNSEM.LOCAL.WH-ISLAND +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg & [MOD < [LOCAL.CAT.HEAD head]>],;because adjectives generally modify nouns
    ARGS < a-connector, sign & [SYNSEM.LOCAL.CAT.HEAD adj-reg,
				SYNSEM.LOCAL.CAT.VAL [COMPS <>,
						      ICOMPS <>],
				SYNSEM.LOCAL.HAS-PERIOD -]> ].

connect-interject-mod-phrase := connector-leftmod-phrase & 
  [ SYNSEM.LOCAL.WH-ISLAND +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD interjection,
    ARGS < sign & [SYNSEM.LOCAL.CAT.HEAD connect], sign & [SYNSEM.LOCAL.CAT.HEAD interjection,
							   SYNSEM.LOCAL.HAS-PERIOD -]> ].

; combines 'og' and 'Ola'
connect-n-mod-phrase := connector-leftmod-phrase-2 & 
  [ SYNSEM.LOCAL.WH-ISLAND +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.MUST-CONNECT-PROJECT -,
    SYNSEM.LOCAL.MUST-COORDINATE -,
    SYNSEM.LOCAL.XLBL #lbl,
    C-CONT.RELS <! arg12-relation & [ LBL #lbl,
				      PRED "_member-of-set_rel",
				       ARG1 #2,
				       ARG2 #1 ] !>,
    ARGS < n-connector-projection-phrase &
	   [SYNSEM.LKEYS.KEYREL.ARG0 #1 ], 
	   sign & [SYNSEM.LOCAL.CAT.HEAD nom,
		   SYNSEM.LOCAL.CONT.HOOK.INDEX #2]> ].

;n-connect-word
;SYNSEM.LOCAL.XLBL #lbl,

; spec-comp approach

; combines 'og' and 'Ola'
connect-n-comp-phrase := head-valence-phrase & head-compositional &
			  phrasal & head-initial &
  [ SYNSEM.LOCAL.CAT.HEAD connect-n,
;    SYNSEM.LOCAL.CAT.VAL.SPR #spr,
    SYNSEM.LOCAL.WH-ISLAND +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD connect-n,
    C-CONT.RELS <! arg12-relation & [ PRED "_member-of-set_rel",
				       ARG1 #2,
				       ARG2 #1 ] !>,
     NON-HEAD-DTR.SYNSEM.LOCAL.CAT [HEAD np-head & [ACCUSATIVE #acc],
				    VAL [ SUBJ <>,
;					  SPR #spr,
					  SPR olist,
					  SPEC olist,
					  COMPS <>,
					  ICOMPS <>]],
    ARGS < n-connector &
	   [SYNSEM.LOCAL.HAS-PUNCT -,
	    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 ], 
	   sign & [SYNSEM.LOCAL.CAT.HEAD np-head,
		   SYNSEM.LOCAL.HAS-PUNCT -, ; not good for n-connect-comma as head, if the comma is marked as '+'
		   SYNSEM.LOCAL.CONT.HOOK.INDEX #2]>,
    SYNSEM canonical-synsem &
	   [ LOCAL.CAT [ VAL [ SUBJ #subj,
                               COMPS #comps,
                               SPR #spr & <[LOCAL.CAT.HEAD.ACCUSATIVE #acc]> ],
                         QVAL #qval,
                         POSTHEAD #ph ],
	     LOCAL.COMPS-BEGUN +,
             NON-LOCAL [ REL 0-dlist  ]],
    FRONT-TO-FILL #front,
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ VAL [ SUBJ #subj,
                                        COMPS < #synsem . #comps >,
                                        SPR #spr ],
                                  QVAL #qval,
                                  POSTHEAD #ph ]],
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,  ; not good for n-connect-comma
    HEAD-DTR.FRONT-TO-FILL #front, 
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL [ QUE 0-dlist & [ LIST null ] ],
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem & [ LOCAL.COORD-RELEASED +,
                                                       LOCAL.MUST-APP -  ],
    C-CONT [ HCONS <! !> ] ].

; combines  jeg  +  og Ola  ( #2 = jeg)
connect-n-spr-phrase := basic-head-spec-phrase & head-final & rule &
  [ RULE [ NEEDS-CARD bool,
            NOMORE-CARD bool ],
    SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE #acc,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    SYNSEM.LOCAL.BINDING #35,
    SYNSEM.LOCAL.BND-RESP #bnd,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.WH-ISLAND +,
    SYNSEM.LOCAL.HAS-PUNCT #pkt,
    SYNSEM.NON-LOCAL #5,
    HEAD-DTR connect-n-comp-phrase,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD connect-n & [EXPLETIVE -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [SUBJ <>,
				   SPEC <>,
				   COMPS <>,
				   ICOMPS <>],				   
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.RELS.LIST.FIRST.ARG0 #1,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT #pkt,
    HEAD-DTR.SYNSEM.NON-LOCAL #5,
    HEAD-DTR.SYNSEM.LOCAL.BINDING #35,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ACCUSATIVE #acc],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH #9,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bnd,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #5,
    C-CONT [RELS <! arg12-relation & [ PRED "_member-of-set_rel",
				       ARG1 #2,
				       ARG2 #1 ] !>,
            HCONS <! !>]].

#|
,
				    VAL [ SUBJ <>,
					  SPEC <>,
					  COMPS <>,
					  ICOMPS <>]
|#

	    


#|
; this rule does not accommodate "ham selv" as an NP, as in
; "fortelle Ola om ham selv" (gives too many parses with "meg/deg selv"
REAL-selv-refl-phrase := head-adj-phrase & rule &
  [ SYNSEM.LOCAL.BINDING #2 & [REFL-II +,
                               REFL-I #3 & +,
                               LEX-TAME -],
    SYNSEM.LOCAL.BINDING.BOUND +,
    SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    SYNSEM.LOCAL.BND-MOUNTABLE < bindee & [ ANAPH-TYPE #2 & binding,
                                            ANAPH-INDX #index & ref-ind ] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron,
    HEAD-DTR.SYNSEM.LOCAL.BINDING.REFL-I #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #1 & [VARG #index,
                                          LTOP #top],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD refl-adv,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #top,
    C-CONT [RELS <! !>,
            HCONS <! !>]].
|#

REAL-selv-refl-phrase := head-adj-phrase & rule &
  [ SYNSEM.LOCAL.BINDING #2 & [REFL-II +,
                               REFL-I #3 & +,
                               LEX-TAME -],
    SYNSEM.LOCAL.BINDING.BOUND +,
    SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    SYNSEM.LOCAL.BND-RESP #resp &  < bindee & [ ANAPH-TYPE #2 & binding,
                                            ANAPH-INDX #index & ref-ind ] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron,
    HEAD-DTR.SYNSEM.LOCAL.BINDING.REFL-I #3,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #1 & [VARG #index,
                                          LTOP #top],
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD refl-adv,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #top,
    C-CONT [RELS <! !>,
            HCONS <! !>]].

; fake version compared to above, 
; by omission of  SYNSEM.LOCAL.BINDING.REFL-I #3,
selv-refl-phrase := head-adj-phrase & rule &
  [ SYNSEM.LOCAL.BINDING.REFL-II +,
    SYNSEM.LOCAL.BINDING.BOUND #2,
    SYNSEM.LOCAL.CONT.HOOK #1 & [INDEX #index,
                                 LTOP #top],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD pers-pron,
    HEAD-DTR.SYNSEM.LOCAL.BINDING.BOUND #2,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #1 & [INDEX #index,
                                          LTOP #top],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD refl-adv,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #top,
    C-CONT [RELS <! !>,
            HCONS <! !>]].



; to avoid proliferation of parses
;SYNSEM.LOCAL [ CAN-CMB-FIXPT -  - kills 'l√∏per fra x til y'
fixpt-mod := basic-binary-headed-phrase & 
  [ SYNSEM.LOCAL [ CAN-CMB-FIXPT bool],
    HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD head,
			    CONT.HOOK dir-hook,
                            CAN-CMB-FIXPT +],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.KEYS.KEY fixpt-dir]].

nonfixpt-dir-mod := basic-binary-headed-phrase & 
  [ SYNSEM.LOCAL [ CAN-CMB-NONFIXPT-DIR -],
    HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD head,
			    CONT.HOOK dir-hook,
                            CAN-CMB-NONFIXPT-DIR +],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.KEYS.KEY nonfixpt-dir]].

;; HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD head,
;;                         CAN-CMB-INDEX-SIT +],

; LTOP id to get label identity in N modification. although doesn't work
index-sit-mod := basic-binary-headed-phrase & 
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    SYNSEM.LOCAL [ CAN-CMB-INDEX-SIT -],
    HEAD-DTR.SYNSEM.LOCAL [ CONT.HOOK.LTOP #ltop],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CONT.HOOK.LTOP #ltop,
				CAT.HEAD.KEYS.KEY index-sit]].
    



; removed ,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #top
; why on earth was it there, making everything LBL h1?
;SYNSEM.NON-LOCAL #5,
;NON-HEAD-DTR.SYNSEM.NON-LOCAL #5,
; C-CONT.RELS <! !>,
            
pp-mod-phrase := head-adj-phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LEX -,
    SYNSEM.LOCAL.CONT.HOOK [INDEX #index,
			    LTOP #ltop],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
 ;   HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <[]>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [INDEX #index,
				     LTOP #ltop],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-comp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    C-CONT [RELS <! !>,
	    HCONS <! !>]].

;pp-mod-vp-phrase-unique := pp-mod-phrase &
;  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <synsem> ].

pp-freerel-mod-vp-phrase := pp-mod-phrase &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CONT.HOOK #2,
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL #3,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #4,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #2,
    HEAD-DTR.FRONT-TO-FILL #3,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #8,
    HEAD-DTR.EXTRACTED-FROM #10,
    HEAD-DTR.SYNSEM.LOCAL.DELIMTELACTV #17,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <synsem>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
                                             LOCAL.CAT.VAL [SUBJ 1-list,
                                                            COMPS <>]]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED -,
                                                     KEYS.KEY der-n√•r ] ]. 


vp-connect-phrase := head-adj-phrase & rule &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [ DECL #decl,
				   IMPERATIVE #imper ],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2 & null,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
;    SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.VAL.SUBJ 1-list]>,
    SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    SYNSEM.LOCAL.WH-ISLAND +,
;    SYNSEM.LOCAL.CAT.VAL.SPR 1-list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ DECL #decl,
					    IMPERATIVE #imper ],
    SYNSEM.LOCAL.CONT.HOOK [INDEX #index],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [INDEX #index],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE #tense,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SIT-TYPE #sitype,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <[]>,
    NON-HEAD-DTR connect-v-mod-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ DECL #decl,
						IMPERATIVE #imper ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.VAL.SUBJ olist]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE #tense,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SIT-TYPE #sitype,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    C-CONT [RELS <! !>,
            HCONS <! !>]].



s-connect-phrase-sup := head-adj-phrase & rule &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [ DECL #decl,
				       IMPERATIVE #imper ],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2 & null,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
    SYNSEM.LOCAL.CAT.VAL.SPR null,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    SYNSEM.LOCAL.WH-ISLAND +,
;    SYNSEM.LOCAL.CONT.HOOK [INDEX #index],
    ;HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [INDEX #index],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ DECL #decl,
						IMPERATIVE #imper],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED #bool,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    NON-HEAD-DTR connect-v-mod-2-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ DECL #decl,
						IMPERATIVE #imper ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX semarg,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED #bool,
    ;NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    C-CONT [RELS <! !>,
            HCONS <! !>]].

s-connect-phrase := s-connect-phrase-sup &
 [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -]].

;s-connect-inv-phrase := s-connect-phrase-sup &
; [ HEAD-DTR another-basic-head-subj-phrase ].

s-connect-inv-phrase := s-connect-phrase-sup &
 [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +],
   HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -].

#|
a-connect-phrase := head-adj-phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #2 & null,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    NON-HEAD-DTR connect-a-mod-phrase,
;    SYNSEM.LOCAL.CONT.HOOK [INDEX #index],
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [INDEX #index],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    C-CONT [RELS <! !>,
            HCONS <! !>]].
|#

; gul  +  og gr√∏nn
a-connect-phrase := head-adj-phrase & rule &
  [ NON-HEAD-DTR connect-a-mod-phrase,
;    HEAD-DTR adj-to-bare-n-rule,
    C-CONT [RELS <! !>,
            HCONS <! !>]].

; her  +  og der
p-adv-connect-phrase := head-adj-phrase & rule &
  [ NON-HEAD-DTR connect-p-adv-mod-phrase,
;    HEAD-DTR [SYNSEM.LOCAL.CAT.HEAD prep-or-adv],
    C-CONT [RELS <! !>,
            HCONS <! !>]].

; hit  +  og dit
p-adv-dir-connect-phrase := head-adj-phrase & rule &
  [ NON-HEAD-DTR connect-p-adv-dir-mod-phrase,
;    HEAD-DTR [SYNSEM.LOCAL.CAT.HEAD prep-or-adv],
    C-CONT [RELS <! !>,
            HCONS <! !>]].

; combines  jeg  +  og Ola
n-connect-phrase := head-adj-phrase-2 & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;    SYNSEM.LOCAL.MUST-COORD-PROJECT +,
    SYNSEM.LOCAL.XLBL #lbl,
    HEAD-DTR [SYNSEM.LOCAL.MUST-COORDINATE -,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #2],
    NON-HEAD-DTR connect-n-mod-phrase & [SYNSEM.LOCAL.CONT.HOOK.XARG #1,
					 SYNSEM.LOCAL.XLBL #lbl],
    C-CONT [RELS <! arg12-relation & [ LBL #lbl,
				       PRED "_member-of-set_rel",
				       ARG1 #2,
				       ARG2 #1 ] !>,
            HCONS <! !>]].

; projects 'jeg og Ola' from n-connect-phrase to a smuggling of XARG into INDEX role - required by this adjunction-based approach to n-coordination
n-coord-projection-phrase := headed-phrase &
  [ SYNSEM.LOCAL.CAT #cat,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
 ;   SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.MUST-COORD-PROJECT -,
    SYNSEM.LOCAL.CONT.RELS #rels,
    SYNSEM.LOCAL.CONT.HCONS #hcons,
    SYNSEM.LOCAL.XLBL #lbl,
    SYNSEM.LOCAL.MUST-COORDINATE #11,
    SYNSEM.NON-LOCAL #nonloc,
    HEAD-DTR #hd,
    HEAD-DTR n-connect-phrase,
    HEAD-DTR.SYNSEM.LOCAL.CAT #cat,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.RELS #rels,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HCONS #hcons,
    HEAD-DTR.SYNSEM.NON-LOCAL #nonloc,
    HEAD-DTR.SYNSEM.LOCAL.XLBL #lbl,
    HEAD-DTR.SYNSEM.LOCAL.MUST-COORDINATE #11,
    HEAD-DTR.SYNSEM.LOCAL.MUST-COORD-PROJECT +,
    ARGS < #hd > ].
    
; projects 'og' to a fs where the lbl of its first ep is 'forgotten'
n-connector-projection-phrase := headed-phrase &
  [ SYNSEM.LOCAL.CAT #cat,
 ;   SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LKEYS.KEYREL.ARG0 #1,
    SYNSEM.LOCAL.MUST-CONNECT-PROJECT -,
    SYNSEM.LOCAL.CONT.RELS #rels,
    SYNSEM.LOCAL.CONT.HCONS #hcons,
    SYNSEM.LOCAL.XLBL #lbl,
    SYNSEM.NON-LOCAL #nonloc,
    HEAD-DTR #hd,
;    HEAD-DTR n-connect-word,
    HEAD-DTR.SYNSEM.LOCAL.CAT #cat,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LKEYS.KEYREL.ARG0 #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.RELS #rels,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HCONS #hcons,
    HEAD-DTR.SYNSEM.NON-LOCAL #nonloc,
    HEAD-DTR.SYNSEM.LOCAL.XLBL #lbl,
    HEAD-DTR.SYNSEM.LOCAL.MUST-CONNECT-PROJECT +,
    ARGS < #hd > ].
   

; projects 'Ola' before joing with 'og' so that its labels are 'forgotten' before the adjunction travel up the tree
n-projection-phrase := headed-phrase &
  [ SYNSEM.LOCAL.CAT #cat,
 ;   SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LKEYS.KEYREL.ARG0 #1,
    SYNSEM.LOCAL.MUST-CONNECT-PROJECT -,
    SYNSEM.LOCAL.MUST-COORDINATE +,
    SYNSEM.LOCAL.CONT.RELS #rels,
    SYNSEM.LOCAL.CONT.HCONS #hcons,
    SYNSEM.LOCAL.XLBL #lbl,
    SYNSEM.LOCAL.BND-RESP #resp,
    SYNSEM.NON-LOCAL #nonloc,
    HEAD-DTR #hd,
;    HEAD-DTR proper-name-word,
    HEAD-DTR.SYNSEM.LOCAL.CAT #cat,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD postposspron,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LKEYS.KEYREL.ARG0 #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.RELS #rels,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HCONS #hcons,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    HEAD-DTR.SYNSEM.NON-LOCAL #nonloc,
    HEAD-DTR.SYNSEM.LOCAL.XLBL #lbl,
    HEAD-DTR.SYNSEM.LOCAL.MUST-CONNECT-PROJECT +,
    ARGS < #hd > ].



parenthesis-mod-vp-phrase := head-adj-phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #2 & null,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    SYNSEM.LOCAL.CONT.HOOK [INDEX #index],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [INDEX #index],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    NON-HEAD-DTR right-parenthesis-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    C-CONT [RELS <! !>,
            HCONS <! !>]].


postnom-poss-phrase-sup :=  basic-head-mod-phrase-simple-sup & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & ref-ind,
    SYNSEM.LOCAL.BINDING #35,
    SYNSEM.LOCAL.BND-RESP #3,
    HEAD-DTR.SYNSEM lex-synsem,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
    HEAD-DTR.SYNSEM.LOCAL.BINDING #35,
;    NON-HEAD-DTR.SYNSEM.LOCAL.BND-MOUNTABLE #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD postposspron,
    C-CONT [RELS <! !>,
            HCONS <! !>]].


; LH050513: NON-HEAD-DTR n-projection-phrase, is in order to force labels to differ between poospron and noun, to create wellformed mra
postnom-poss-phrase := postnom-poss-phrase-sup & head-adj-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [PNG.NG #4],
    SYNSEM.LOCAL.BND-RESP #bnd,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun & [DEFINITE +],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5,
    NON-HEAD-DTR n-projection-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #4,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bnd,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-MOUNTABLE #bnd,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #5]>].

telic-mod-vp-phrase := head-adj-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PATH-TELIC +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion ].


atelic-mod-vp-phrase := head-adj-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PATH-TELIC bool,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point ].

#|
; new ancestry, due to MalGram
; has been moved to exp-types.tdl, and there defined from a type defined in mal-types.tdl in turn! But the content is the same.

front-mod-vp-phrase := adj-head-phrase &
  [ SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PATH-TELIC bool,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.FRONT-TO-FILL + ].
|#

atelic-front-mod-vp-phrase := front-mod-vp-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY reg ].

telic-front-mod-vp-phrase := front-mod-vp-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY fixpt-dir ].

; does not inherit from front-mod-vp-phrase, since this inherits from 
;adj-head-phrase, where C-CONT.RELS is empty. Since this holds for all 
;'normal' front-adj, rather have this one inherit from 
; basic-head-mod-phrase-simple.
np-front-mod-vp-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD #infl,
    SYNSEM.LOCAL.CONT.HOOK [ INDEX #1,
                             LTOP #40 ],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    FRONT-TO-FILL -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #infl & non-copula & [INV +,
						       DECL +,
						       MAIN-CL +,
						       IMPERATIVE -,
						       MOD <>],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [E.TENSE finite],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [ SORT time-item ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card-nom & [KEYS.KEY crdfix],
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    C-CONT.RELS <! arg12-relation & [ PRED "time-sit-at_rel",
                                      LBL #40,
                                      ARG1 #1,
                                      ARG2 #5 ] !>,
    C-CONT.HCONS <! !>  ].



non-aspect-mod-vp-phrase := head-adj-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb ].

;perhaps split into two: one for adv modifying V-proj, where we want a
; non-null subject, and one for modify N and Adv-proj, where SUBJ is 
; empty
adv-mod-phrase := head-adj-phrase &
  [ SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #8,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv,

    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    C-CONT [RELS <! !>,
            HCONS <! !>]].

; n-or-adj-or-adv
cmpar-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR <>,
    SYNSEM.LOCAL.CMPAR-PENDING -,
    SYNSEM.CMPAR-SAT +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD n-or-adj,
    SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    RULE #7,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.COMPAR-DEP #dep,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.CMPAR-PRED #4,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG.ROLE compare-top &
			     [ COMPARE-INSTNCE #cmp ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CMPAR-PENDING +,
    HEAD-DTR.SYNSEM.CMPAR-SAT -,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    HEAD-DTR.RULE #7,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD cmpar-dep-reg & [MOD <[LOCAL.CONT.HOOK.CMPAR-PRED #4]>],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY #dep,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.ROLE compare-ref &
			     [ COMPARE-INSTNCE #cmp ],
    C-CONT [RELS <! !>,
            HCONS <! !>] ].


mod-front-phrase := var-cc_opn-adj-head-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [COMPS <>,
                          ICOMPS <>],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < anti-synsem >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    C-CONT [RELS <! !>,
            HCONS <! !>]].

#|
; temp redefined
mod-front-phrase := var-cc_opn-adj-head-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [COMPS <>,
                          ICOMPS <>],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < anti-synsem >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [ INDEX #ind, LTOP #lbl ], ;; MHS 180511 Add re-entrancy of LTOP and LBL to fix leaf/hole mismatch.
    C-CONT [RELS.LIST.FIRST fpos_prom_rel & [ ARG1 #ind, LBL #lbl ],
            HCONS <! !>]].
|#

; var-cc_opn-adj-head-phrase is defined in mal-types.tdl, in turn based on new types in matrix.tdl. Regular types shouldn't emerge from a mal-dedicated file.
front-mod-vp-phrase := var-cc_opn-adj-head-phrase &
  [ SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    FRONT-TO-FILL -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PATH-TELIC bool,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.FRONT-TO-FILL + ].


#|
mod-front-phrase := adj-head-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [COMPS <>,
                          ICOMPS <>],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    SYNSEM.LOCAL.COORD-RELEASED #18,
    SYNSEM.LOCAL.HAS-REL-CL #hrlc,		;; EAA. NorMal. 140211. PXB-NS.
    SYNSEM.LOCAL.REL-CL-SOM-INIT #rlsci,	;; EAA. NorMal. 140211. PXB-NS.
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.HAS-REL-CL #hrlc,		;; EAA. NorMal. 140211. PXB-NS.
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #rlsci,	;; EAA. NorMal. 140211. PXB-NS.
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    C-CONT [RELS <! !>,
            HCONS <! !>]].

|#

adv-mod-front-phrase := mod-front-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv ].

pp-mod-front-phrase := mod-front-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-comp ].

;adjective-mod-front-phrase := mod-front-phrase &
;  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg ].




; does not inherit from front-mod-vp-phrase, since this inherits from 
;adj-head-phrase, where C-CONT.RELS is empty. Since this holds for all 
;'normal' front-adj, rather have this one inherit from 
; basic-head-mod-phrase-simple.
; removed SYNSEM.LOCAL.ADJ-SITE-OPEN - from mother, to allow recursion, but...


   np-mod-vp-time-phrase-sup := basic-head-mod-phrase-simple & head-initial &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CAT.QVAL #4q,
    SYNSEM.LOCAL.CAT.VAL.SUBJ 1-list,
    SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1,
                                  LTOP #40 ],
;    SYNSEM.NON-LOCAL.SLASH #8,
     SYNSEM.LOCAL.DELIMTELACTV #17,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    FRONT-TO-FILL #3,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.BND-RESP #bind,
    ARGS < [ SYNSEM.LOCAL.CONT.HOOK.VARG #12,
             SYNSEM.LOCAL.CAT.HEAD verb-all & [KEYS.KEY mainvb ],
             SYNSEM.LOCAL.CAT.VAL.SUBJ 1-list,
             SYNSEM.LOCAL.CAT.VAL.COMPS <>,
             SYNSEM.LOCAL.CAT.VAL #4,
	     SYNSEM.LOCAL.CAT.QVAL #4q,
             SYNSEM.LOCAL.CONT.HOOK #2,
             SYNSEM.LOCAL.CAN-NP-MOD +,
             FRONT-TO-FILL #3,
  ;           SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.NEED-IMP-UNARY #43 & +,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
	     SYNSEM.LOCAL.BND-RESP #bind ],
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [ SORT time-item ],
             SYNSEM.LOCAL.CAT.VAL.COMPS <>,
             SYNSEM.LOCAL.CAT.VAL.SPEC <>,
             SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
             SYNSEM.LOCAL.CAT.VAL.SPR <>,
             SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
	     SYNSEM.LOCAL.CARD-TO-BARE-N -,
	     SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.LOCAL.CAT.HEAD card-nom & [KEYS.KEY crdfix,
					       BARE -],
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
                                             LOCAL.CAT.VAL [COMPS <>]]>]>,
    C-CONT.RELS <! arg12-relation & [ PRED "time-sit-at_rel",
                                      LBL #40,
                                      ARG1 #1,
                                      ARG2 #5 ] !>,
    C-CONT.HCONS <! !> ].

np-weekday-mod-vp-time-phrase := np-mod-vp-time-phrase-sup &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY weekday-noun]].

; 'LEX -' to ensure that "... 25 √•r" is not analyzed with "√•r" as vp-modifier
np-mod-vp-time-phrase := np-mod-vp-time-phrase-sup &
  [ NON-HEAD-DTR.SYNSEM.LEX bool ].

; for "kommer hver dag/hvert √•r", as opposed to "kommer onsdag"
quantnp-mod-vp-time-phrase := basic-head-mod-phrase-simple & head-initial &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CAT.QVAL #4q,
    SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1,
                                  LTOP #40 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL #3,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS < [ SYNSEM.LOCAL.CONT.HOOK.VARG #12,
             SYNSEM.LOCAL.CAT.HEAD verb-all,
             SYNSEM.LOCAL.CAT.VAL.COMPS <>,
             SYNSEM.LOCAL.CAT.VAL #4,
	     SYNSEM.LOCAL.CAT.QVAL #4q,
             SYNSEM.LOCAL.CONT.HOOK #2,
             SYNSEM.LOCAL.CAN-NP-MOD +,
             FRONT-TO-FILL #3,
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.NEED-IMP-UNARY #43 & +,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ],
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [ SORT time-item ],
             SYNSEM.LOCAL.CAT.HEAD card-nom & [KEYS.KEY timemeas-noun],
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
                                             LOCAL.CAT.VAL [COMPS <>]]>,
	     SYNSEM.LOCAL.CONT.RELS.LIST.FIRST [PRED "_univ_q_rel"]] >,
    C-CONT.RELS <! arg12-relation & [ PRED "time-sit-at_rel",
                                      LBL #40,
                                      ARG1 #1,
                                      ARG2 #5 ] !>,
    C-CONT.HCONS <! !> ].

np-mod-vp-length-phrase := basic-head-mod-phrase-simple & head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CAT.QVAL #4q,
    SYNSEM.LOCAL.CONT.HOOK #2 & [ LTOP #40 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL #3,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS < [ SYNSEM.LOCAL.CONT.HOOK.VARG #12,
             SYNSEM.LOCAL.CONT.HOOK.DIRARG #12dir,
             SYNSEM.LOCAL.CAT.HEAD verb-all,
             SYNSEM.LOCAL.CAT.VAL.COMPS <>,
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CAT.VAL.SUBJ < [] >,
	     SYNSEM.LOCAL.CAT.QVAL #4q,
             SYNSEM.LOCAL.CONT.HOOK #2,
	     SYNSEM.LOCAL.BND-RESP.FIRST.ANAPH-TYPE.BOUND -,
             SYNSEM.LOCAL.CAN-NP-MOD +,
             FRONT-TO-FILL #3,
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.NEED-IMP-UNARY #43 & +,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ],
           [ SYNSEM.LOCAL.CAT.HEAD card-nom & [KEYS.KEY measnoun],
             SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [ SORT length-unit ],
             SYNSEM.LOCAL.CAT.VAL.SPR <>,
             SYNSEM.LOCAL.CAT.VAL.SPEC <>,
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
                                             LOCAL.CAT.VAL [COMPS <>]]>]>,
    C-CONT.RELS <! arg12-relation & [ PRED "measure-out-path-of_rel",
                                      LBL #40,
                                      ARG1 #5,
                                      ARG2 #12dir ] !>,
    C-CONT.HCONS <! !> ].

#|
correlative-inv-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1,
                                  LTOP #40 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL -,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS < [ SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [E.TENSE finite,
                                                E.MOOD indicative],
             SYNSEM.LOCAL.CAT.VAL #4 & [ SUBJ antilist ],
             SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL +],
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
             SYNSEM.NON-LOCAL.SLASH #8,
             SYNSEM.LOCAL.HAS-PUNCT -,
             FRONT-TO-FILL + ],    
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [E.TENSE finite],
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL + ],
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
             SYNSEM.NON-LOCAL.SLASH #8,    
             SYNSEM.LOCAL.CONT.HOOK.VARG #12,
             SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CONT.HOOK #2,
             SYNSEM.LOCAL.CAN-NP-MOD +,
             SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ]>,
    C-CONT.RELS <! arg12-relation & [ PRED "depend-on_rel",
                                      LBL #40,
                                      ARG1 #1,
                                      ARG2 #5 ] !>,
    C-CONT.HCONS <! !> ].
|#

; comma-rightmod-for-inv-v-phrase & 
           
correlative-inv-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1,
                                  LTOP #40 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL -,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS < [ SYNSEM.LOCAL.CONT.HOOK.INDEX #5 & [E.TENSE finite],
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL +,
					       IMPERATIVE -],
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.NON-LOCAL.SLASH #8 ],    
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [E.TENSE finite],
             SYNSEM.LOCAL.CAT.VAL #4 & [ SUBJ antilist ],
             SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL + ],
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.NON-LOCAL.SLASH #8,    
             SYNSEM.LOCAL.CONT.HOOK.VARG #12,
             SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CONT.HOOK #2,
             SYNSEM.LOCAL.CAN-NP-MOD +,
             SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ]>,
    C-CONT.RELS <! arg12-relation & [ PRED "depend-on_rel",
                                      LBL #40,
                                      ARG1 #1,
                                      ARG2 #5 ] !>,
    C-CONT.HCONS <! !> ].



 correlative-interjct-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL -,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS < sign &
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX [E.TENSE finite],
             SYNSEM.LOCAL.CAT.VAL #4 & [ SUBJ antilist ],
             SYNSEM.LOCAL.CAT.HEAD interjection,
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #1]>,
             SYNSEM.NON-LOCAL.SLASH #8,
             SYNSEM.LOCAL.HAS-PUNCT -,
             FRONT-TO-FILL + ],           
           [ SYNSEM.LOCAL.CAT.VAL #4,
;             SYNSEM.LOCAL.CAT.HEAD verb-all,
 ;            SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.NON-LOCAL.SLASH #8,    
;             SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [E.TENSE finite], ; for "hei gutter"
             SYNSEM.LOCAL.CONT.HOOK.VARG #12,
             SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CONT.HOOK #2,
             SYNSEM.LOCAL.CAN-NP-MOD +,
             SYNSEM.LOCAL.HAS-PERIOD -,
             SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ]>,
 ;   C-CONT.RELS <! arg12-relation & [ PRED "interject-modified_rel",
 ;                                     LBL #40,
 ;                                     ARG1 #1,
 ;                                     ARG2 #5 ] !>,
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !> ].


; comma-rightmod-for-interjct-v-phrase & 
;comma-rightmod-interjct-phrase
correlative-interjct-comma-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL -,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.HAS-PUNCT +,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS <   comma-rightmod-interjct-phrase &
	     [ SYNSEM.LOCAL.CAT.HEAD interjection,
;             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
;	       SYNSEM.LOCAL.CONT.HOOK.INDEX [E.TENSE finite],
              SYNSEM.LOCAL.HAS-PUNCT +,
             SYNSEM.NON-LOCAL.SLASH #8 ],    
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
 ;            SYNSEM.LOCAL.CAT.VAL #4 & [ SUBJ antilist ],
 ;            SYNSEM.LOCAL.CAT.HEAD verb-all,
 ;            SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.NON-LOCAL.SLASH #8,    
             SYNSEM.LOCAL.CONT.HOOK.VARG #12,
 ;            SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CONT.HOOK #2,
 ;            SYNSEM.LOCAL.CAN-NP-MOD +,
 ;            SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.LOCAL.HAS-PERIOD -,
;             SYNSEM.LOCAL.WH-ISLAND -,  ;preventing combination with connect-v - but that is not always bad
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ]>,
    C-CONT.RELS <! !>,
 ;   C-CONT.RELS <! arg12-relation & [ PRED "interject-modified_rel",
 ;                                     LBL #40,
 ;                                     ARG1 #1,
 ;                                     ARG2 #5 ] !>,
    C-CONT.HCONS <! !> ].


correlative-adj-interjct-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL -,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS < sign &
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX [E.TENSE finite],
             SYNSEM.LOCAL.CAT.VAL #4 & [ SUBJ antilist ],
             SYNSEM.LOCAL.CAT.HEAD adj & [KEYS.KEY adj-decl-selct],
             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #1]>,
             SYNSEM.NON-LOCAL.SLASH #8,
             SYNSEM.LOCAL.HAS-PUNCT -,
             FRONT-TO-FILL + ],           
           [ SYNSEM.LOCAL.CAT.VAL #4,
;             SYNSEM.LOCAL.CAT.HEAD verb-all,
 ;            SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.NON-LOCAL.SLASH #8,    
;             SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [E.TENSE finite], ; for "hei gutter"
             SYNSEM.LOCAL.CONT.HOOK.VARG #12,
             SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CONT.HOOK #2,
             SYNSEM.LOCAL.CAN-NP-MOD +,
             SYNSEM.LOCAL.HAS-PERIOD -,
             SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ]>,
 ;   C-CONT.RELS <! arg12-relation & [ PRED "interject-modified_rel",
 ;                                     LBL #40,
 ;                                     ARG1 #1,
 ;                                     ARG2 #5 ] !>,
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !> ].



correlative-adj-interjct-comma-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM.LOCAL.CONT.HOOK #2 & [ INDEX #1 ],
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    FRONT-TO-FILL -,
    EXTRACTED-FROM #10,
 ;   SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.CAN-NP-MOD -,
    SYNSEM.LOCAL.HAS-PUNCT +,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    ARGS <   comma-rightmod-adj-interjct-phrase &
	     [ SYNSEM.LOCAL.CAT.HEAD adj,
;             SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
;	       SYNSEM.LOCAL.CONT.HOOK.INDEX [E.TENSE finite],
              SYNSEM.LOCAL.HAS-PUNCT +,
             SYNSEM.NON-LOCAL.SLASH #8 ],    
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
 ;            SYNSEM.LOCAL.CAT.VAL #4 & [ SUBJ antilist ],
 ;            SYNSEM.LOCAL.CAT.HEAD verb-all,
 ;            SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all]>,
             SYNSEM.NON-LOCAL.SLASH #8,    
 ;            SYNSEM.LOCAL.CONT.HOOK.VARG #12,
 ;            SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
             SYNSEM.LOCAL.CAT.VAL #4,
             SYNSEM.LOCAL.CONT.HOOK #2,
 ;            SYNSEM.LOCAL.CAN-NP-MOD +,
 ;            SYNSEM.LOCAL.HAS-PUNCT -,
             SYNSEM.LOCAL.HAS-PERIOD -,
;             SYNSEM.LOCAL.WH-ISLAND -,  ;preventing combination with connect-v - but that is not always bad
             SYNSEM.NON-LOCAL.SLASH #8,
             EXTRACTED-FROM #10,
             SYNSEM.LOCAL.DELIMTELACTV #17,
             SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
             SYNSEM.LOCAL.IS-A-COMPLEMENT #31 ]>,
    C-CONT.RELS <! !>,
 ;   C-CONT.RELS <! arg12-relation & [ PRED "interject-modified_rel",
 ;                                     LBL #40,
 ;                                     ARG1 #1,
 ;                                     ARG2 #5 ] !>,
    C-CONT.HCONS <! !> ].


;SYNSEM.NON-LOCAL.SLASH #8,
;NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #8,
        
;SYNSEM.LOCAL.CAT.VAL #4,
pp-mod-vp-or-derivadj-phrase := pp-mod-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #comp & null,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomp,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    SYNSEM.LOCAL.COORD-RELEASED #18,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    SYNSEM.LOCAL.BND-RESP #37,
    SYNSEM.LOCAL.WAIT-BND-RESP #38,
    FRONT-TO-FILL #3,
;    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
;    SYNSEM.NON-LOCAL.SLASH #8,
;    SYNSEM.NON-LOCAL.SLASH #8,
;    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #8,
;    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #comp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #icomp,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #4,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    NON-HEAD-DTR.FRONT-TO-FILL #3,
    HEAD-DTR.SYNSEM.LOCAL.DELIMTELACTV #17,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
;    NON-HEAD-DTR.EXTRACTED-FROM #10,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.SELECTED -,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18 ].


pp-mod-vp-phrase := pp-mod-vp-or-derivadj-phrase &
  [ SYNSEM.LOCAL.HAS-WH-MOVED #mov,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY mainvb,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED #mov,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
                                             LOCAL.CAT.VAL [COMPS <>]]> ].

#|    
pp-mod-vp-phrase := pp-mod-vp-or-derivadj-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY mainvb,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -].
|#    
pp-mod-derivadj-phrase := pp-mod-vp-or-derivadj-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD +,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep & [MOD <[LOCAL.CAT.HEAD adj-reg,
						     LOCAL.CAT.VAL [COMPS <>]]>] ].
    
pp-mod-front-vp-phrase := pp-mod-front-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                      DECL +],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    FRONT-TO-FILL -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all & [INV +],
                                             LOCAL.CAT.VAL [SUBJ list,
                                                            COMPS list]]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ].

; wait with these until mechanism for percol WH+ from NP up to PP
pp-interr-mod-front-vp-phrase := pp-mod-front-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                      DECL -],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all & [INV +],
                                             LOCAL.CAT.VAL [SUBJ list,
                                                            COMPS list]]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH + ].

atelic-front-pp-mod-vp-phrase:= pp-mod-front-vp-phrase & atelic-front-mod-vp-phrase.
atelic-front-pp-mod-vp-nonfixptdir-phrase := atelic-front-pp-mod-vp-phrase & nonfixpt-dir-mod. 
; removed '& index-sit-mod ', since adverbial clauses in front are index-sit
atelic-front-pp-mod-vp-index-sit-phrase := atelic-front-pp-mod-vp-phrase & index-sit-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1 ].
telic-front-pp-mod-vp-phrase:= pp-mod-front-vp-phrase & telic-front-mod-vp-phrase.

atelic-interr-front-pp-mod-vp-phrase := pp-interr-mod-front-vp-phrase & atelic-front-mod-vp-phrase.
atelic-interr-front-pp-mod-vp-nonfixptdir-phrase := atelic-interr-front-pp-mod-vp-phrase & nonfixpt-dir-mod.
; removed '& index-sit-mod ', since adverbial clauses in front are index-sit
atelic-interr-front-pp-mod-vp-index-sit-phrase := atelic-interr-front-pp-mod-vp-phrase & index-sit-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1 ].
telic-interr-front-pp-mod-vp-phrase:= pp-interr-mod-front-vp-phrase & telic-front-mod-vp-phrase.

; 'antilist' on second lowest line, so that V-proj with inverted subj
; and normal ones get treated alike - meaning that head-subject-rule
; applies before the application of this one. If using 'cons', that
; yields double parse for all non-inverted cases, and that gets
; explosive. For the MRSes it doesn't matter.
;;;;;;;; Dec05: commented this rule out, since not sure what's missed
pp-mod-vp-2-phrase := pp-mod-phrase &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CONT.HOOK #2,
    SYNSEM.NON-LOCAL.SLASH #8,
    FRONT-TO-FILL #3,
    EXTRACTED-FROM #10 & +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #4,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #2,
    HEAD-DTR.FRONT-TO-FILL #3,
    NON-HEAD-DTR.EXTRACTED-FROM #10,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.SELECTED -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
                                             LOCAL.CAT.VAL [SUBJ antilist,
                                                            COMPS <>]]>].

; these subtypes carry the good intention of yielding only one parse for
; "jeg sitter bak huset". But it yields an explosion in the rule
; inventory - a lot of PP-attachment rules inherit from the one above.
; Rather hope for a smart insight...
;pp-mod-vp-noninv-phrase := pp-mod-vp-phrase &
;  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD.INV -,
;                                             LOCAL.CAT.VAL [SUBJ 1-list]>].
;pp-mod-vp-inv-phrase := pp-mod-vp-phrase &
;  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD.INV +,
;                                             LOCAL.CAT.VAL [SUBJ antilist]>].

;cancelled the computation of telicity under for modification, to
;first get the Role constraints of predsort to work -db jan05
; but now get telfixing to work -lh feb05


telfix-pathtelicity-pp-mod-vp-phrase := pp-mod-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PATH-TELIC #1 & bool,
    SYNSEM.LOCAL.PATHTELFIXED +,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PATH-TELIC #1,
    HEAD-DTR.SYNSEM.LOCAL.PATHTELFIXED -,
    HEAD-DTR.SYNSEM.LOCAL.PATHTELACTV +,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT telmarking,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [TEL-FIXING +,
                                        SELECTED -,
                                        KEYS.KEY telfix]].

telfix-pathtelic-pp-mod-vp-phrase := telfix-pathtelicity-pp-mod-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PATH-TELIC +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT accomplishment-time ].

telfix-path-atelic-pp-mod-vp-phrase := telfix-pathtelicity-pp-mod-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PATH-TELIC -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT duration-time ].


telfix-delimitedness-pp-mod-vp-phrase := pp-mod-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.DELIMITED #1 & bool,
    SYNSEM.LOCAL.DELIMTELFIXED +,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.DELIMITED #1,
    HEAD-DTR.SYNSEM.LOCAL.DELIMTELFIXED -,
    HEAD-DTR.SYNSEM.LOCAL.DELIMTELACTV +,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT telmarking,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [TEL-FIXING +,
                                        SELECTED -,
                                        KEYS.KEY delimfix]].

telfix-delim-pp-mod-vp-phrase := telfix-delimitedness-pp-mod-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.DELIMITED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT accomplishment-time ].

telfix-nondelim-pp-mod-vp-phrase := telfix-delimitedness-pp-mod-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.DELIMITED -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT duration-time ].




; the HAS-PUNCT restriction on NON-HEAD perhaps applies only to subtypes
pp-mod-n-phrase := pp-mod-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD comm-noun]>,
    SYNSEM.LOCAL.BINDING #5,
    SYNSEM.LOCAL.DERIVED-HEAD #11,
    SYNSEM.LOCAL.MUST-APP #7,
    SYNSEM.LOCAL.BND-RESP #3,
    SYNSEM.NON-LOCAL.SLASH #slash,
    RULE #6,
    FRONT-TO-FILL #front,
    HEAD-DTR.SYNSEM.LOCAL.BINDING #5,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #11,
    HEAD-DTR.SYNSEM.LOCAL.MUST-APP #7,
    HEAD-DTR.RULE #6,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY non-measurnoun],
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #3,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [SELECTED -],
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT full-thing,  ; hopefully not too restrictive
    NON-HEAD-DTR.FRONT-TO-FILL #front,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash ].

pp-mod-bare-n-phrase := pp-mod-n-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD noun & [ BARE + ],
                                             LOCAL.CAT.VAL.SUBJ list,
                                             LOCAL.CAT.VAL.SPR list ]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD - ].


pp-mod-bare-n-index-sit-phrase := pp-mod-bare-n-phrase & index-sit-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT full-thing ].
pp-mod-bare-n-nonfixpt-dir-phrase := pp-mod-bare-n-phrase & nonfixpt-dir-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY dir ].
pp-mod-bare-n-fixpt-phrase := pp-mod-bare-n-phrase & fixpt-mod.
; &
;  [ NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY dir ].



pp-mod-defbare-n-phrase := pp-mod-n-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD noun & [ BARE -,
                                                                     DEFINITE + ],
                                             LOCAL.CAT.VAL.SUBJ list,
                                             LOCAL.CAT.VAL.SPR list ]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].

pp-mod-defbare-n-index-sit-phrase := pp-mod-defbare-n-phrase & index-sit-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1 ].
pp-mod-defbare-n-nonfixpt-dir-phrase := pp-mod-defbare-n-phrase & nonfixpt-dir-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY dir ].
pp-mod-defbare-n-fixpt-phrase := pp-mod-defbare-n-phrase & fixpt-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY dir ].


pp-mod-spr-n-phrase := pp-mod-n-phrase &
  [ SYNSEM.UNDERGOER-OPEN #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[UNDERGOER-OPEN #2,
                                             LOCAL.CAT.HEAD noun,
                                             LOCAL.CAT.VAL.SUBJ list,
                                             LOCAL.CAT.VAL.SPR < [] > ]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < [] > ].

pp-mod-spr-n-index-sit-phrase := pp-mod-spr-n-phrase & index-sit-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1 ].
pp-mod-spr-n-nonfixpt-dir-phrase := pp-mod-spr-n-phrase & nonfixpt-dir-mod.
pp-mod-spr-n-fixpt-phrase := pp-mod-spr-n-phrase & fixpt-mod.

; a lot of subtypes could be introduced here, like for pp-mod-n-phrase
pp-mod-rel-n-phrase := pp-mod-phrase &
  [ SYNSEM.LOCAL.DERIVED-HEAD #11,
    SYNSEM.LOCAL.BND-RESP #5,
    SYNSEM.LOCAL.CAT.VAL #val & [SUBJ null,
				 COMPS null,
				 ICOMPS null,
				 SPEC null,
				 SPR null],
    SYNSEM.NON-LOCAL #nl,
    RULE #6,
    HEAD-DTR.RULE #6,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun & [KEYS.KEY relnoun],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT relatum,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #val,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #11, ; could have '-' here, but loses 'ni av guttene' on current analysis
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #nl,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #5,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [ KEYS.KEY preprel ]].

pp-mod-relinf-phrase := pp-mod-phrase &
  [ SYNSEM.LOCAL.DERIVED-HEAD #11,
    SYNSEM.LOCAL.BND-RESP #5,
    SYNSEM.LOCAL.CAT.VAL #val & [SUBJ null,
				 COMPS null,
				 ICOMPS null,
				 SPEC null,
				 SPR null],
    RULE #6,
    HEAD-DTR.RULE #6,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun & [KEYS.KEY relnoun],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT relatum,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #ind,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #val,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD #11 & -,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #5,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [ KEYS.KEY rais ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD infin-comp & [TRANSPAR + ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.XARG #ind ].


#| mixing in types from PREDSORTS:
pp-mod-n-phrase-reg := pp-mod-n-phrase &
  [ NON-HEAD-DTR.SYNSEM.LKEYS.KEYREL.ARG0.ROLE xdim-to-xdim ].

pp-mod-n-phrase-dirarg := pp-mod-n-phrase &
  [ NON-HEAD-DTR.SYNSEM.LKEYS.KEYREL.IARG.CLASS line-to-xdim ].
|#
;LEG

pp-mod-x-phrase := pp-mod-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra & [MOD <[LOCAL.CAT.HEAD head,
							   LOCAL.CAT.VAL [SUBJ list,
									  COMPS <>]]>],
    SYNSEM.LOCAL.CONT.HOOK.XLEG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XLEG #1].


; pp modif vp, will induce leg identity
pp-mod-vp-phrase2 := pp-mod-x-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
                                             LOCAL.CAT.VAL [COMPS <>] ]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.LEG-SWITCH - ].

pp-mod-adv-dir-phrase := pp-mod-x-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.DIRARG #3]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD adv,
             SYNSEM.LOCAL.CONT.HOOK.XARG #1,
             SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
             SYNSEM.LOCAL.HAS-PUNCT -], [SYNSEM.LOCAL.CONT.HOOK.XARG #1,
                                               SYNSEM.LOCAL.CAT.HEAD.LEG-SWITCH -,
                                               SYNSEM.LOCAL.CONT.HOOK.INDEX #2]>].


pp-mod-pp-dir-phrase := pp-mod-x-phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.DIRARG #1]>,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD prep,
             SYNSEM.LOCAL.CONT.HOOK.XARG #1,
             SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
             SYNSEM.LOCAL.HAS-PUNCT - ], 
           [SYNSEM.LOCAL.CONT.HOOK.XARG #1,
            SYNSEM.LOCAL.CAT.HEAD.LEG-SWITCH -,
            SYNSEM.LOCAL.CONT.HOOK.INDEX #2]>].

; removed 'nonfixpt-dir-mod &' from top line: nonfixpt-dir is not compatible
; with nonfixpt-dir2
pp-mod-pp-orient-phrase := pp-mod-pp-dir-phrase & 
  [ ARGS < [SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT non-fix-point], 
           [SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY nonfixpt-dir2] >].

; removed 'fixpt-mod &' to get "inn til fjellet"
pp-mod-pp-fixpt-phrase := pp-mod-pp-dir-phrase  & 
  [ ARGS < [SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir ]], [SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY fixptconsumpt-dir2] >].



; adjunction to an adv modifying a verb
pp-mod-adv-orient-phrase := pp-mod-adv-dir-phrase &
  [ ARGS < orient-adv-word, [SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY nonfixpt-dir2] >].

; removed 'fixpt-mod &' to get "inn til fjellet"
pp-mod-adv-fixpt-phrase := pp-mod-adv-dir-phrase  & 
  [ ARGS < [SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir ]], [SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY fixptconsumpt-dir2] >].

; pp modif adv, inducing leg identity, and hooking onto VARG of verb 
;(next step) (only type inheriting from pp-mod-adv-dir-phrase - so could
; perhaps be a single type
;pp-mod-pp-phrase1 := pp-mod-pp-dir-phrase  &
;  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.VARG #3]>,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
;    HEAD-DTR.SYNSEM.LKEYS.KEYREL prep-path-rel ].

adv-mod-x-phrase := adv-mod-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD head,
                                             LOCAL.CAT.VAL [SUBJ list,
                                                            COMPS <>]]>,
    SYNSEM.LOCAL.CONT.HOOK.XLEG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XLEG #1].

;adv-mod-adv-orient-phrase := adv-mod-x-phrase &
;  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.VARG #2]>,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #2,
;    ARGS < orient-adv-word & [ SYNSEM.LOCAL.CAT.HEAD adv,
;                               SYNSEM.LOCAL.CONT.HOOK.XARG #1], 
;           [SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;            SYNSEM.LOCAL.CAT.HEAD.LEG-SWITCH -]>].

adv-mod-adv-dir-phrase := adv-mod-x-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.VARG #3]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #3,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD adv,
             SYNSEM.LOCAL.CONT.HOOK.XARG #1,
             SYNSEM.LOCAL.CONT.HOOK.INDEX #2], 
           [SYNSEM.LOCAL.CONT.HOOK.XARG #1,
            SYNSEM.LOCAL.CAT.HEAD.LEG-SWITCH -,
            SYNSEM.LOCAL.CONT.HOOK.INDEX #2]>].

adv-mod-adv-orient-phrase := adv-mod-adv-dir-phrase &
  [ ARGS < orient-adv-word, [SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY orient-dir] >].

; removed 'fixpt-mod &'
adv-mod-adv-fixpt-phrase := adv-mod-adv-dir-phrase  & 
  [ ARGS < [SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir ]], [SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY fixptconsumpt-dir2] >].

; this should in principle work
;adv-mod-adv-fixpt-comma-phrase := adv-mod-adv-dir-phrase  &  
;  [ NON-HEAD-DTR comma-mod-phrase & [SYNSEM.LOCAL.CAT.HEAD [KEYS.KEY dir ]]].


; adv modif adv, hooking onto VARG of verb 
; both head and non-head adv are fed by orient-adv-word; yield only
; distinct ARG0s
; "gutten rusler inn vekk"
;adv-mod-adv-phrase1 := adv-mod-adv-dir-phrase  &
;  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.VARG #1]>,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;    ARGS < orient-adv-word, [] >].

adv-mod-vp-phrase2 := adv-mod-x-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
                                             LOCAL.CAT.VAL [SUBJ <synsem-min>,
                                                            COMPS <>]]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.LEG-SWITCH - ].



; pp modif adv, event modif, identical ARG1
pp-mod-adv-reg-phrase := pp-mod-phrase & index-sit-mod &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #1]>,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD adv,
             SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
             SYNSEM.LOCAL.HAS-PUNCT -], 
	   [SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
            SYNSEM.IDIOMOD +,
            SYNSEM.LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY index-sit2]]>].


; pp modifying adv, both as event-modif, and hooking on to INDEX of verb
;pp-mod-adv-phrase2 := pp-mod-adv-reg-phrase &
;  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #1]>,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #1, ].

; pp modif pp, event modif, identical ARG1
pp-mod-pp-reg-phrase := pp-mod-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #2]>,
    SYNSEM.LOCAL.CONT.HOOK.XARG #2,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD prep,
             SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit,
             SYNSEM.LOCAL.CONT.HOOK.XARG #1], 
           [ SYNSEM.LOCAL.CONT.HOOK.XARG #1,
             SYNSEM.LOCAL.CAT.HEAD prep-ultra & [KEYS.KEY index-sit2 ]]>].

; pp modifying pp, both as event-modif, and hooking on to INDEX of verb
;pp-mod-pp-phrase2 := pp-mod-pp-reg-phrase &
;  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #1]>,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #1 ].

; forcing any adv to join after SPR has combined
adv-mod-n-phrase := adv-mod-phrase & rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    RULE #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ -,
    HEAD-DTR.RULE #2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1 ].

; these specifications of what can combine with the N seem crazy; so, try without...
#|
adv-mod-defbare-n-phrase := adv-mod-n-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD noun & [ BARE -,
                                                                     DEFINITE + ],
                                             LOCAL.CAT.VAL.SUBJ list,
                                             LOCAL.CAT.VAL.SPR list ]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>].

adv-mod-bare-n-phrase := adv-mod-n-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD noun & [ BARE + ],
                                             LOCAL.CAT.VAL.SUBJ list,
                                             LOCAL.CAT.VAL.SPR list ]>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -].
|#

; intended with ,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < [] >
; but too many parses
; this for directional nouns - 
adv-mod-spr-n-phrase := adv-mod-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    RULE #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD comm-noun,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.RULE #2,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK dir-hook,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD noun,
                                              LOCAL.CAT.VAL.SPR cons ]> ].


advdir-mod-n-phrase := adv-mod-n-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK dir-hook,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX.SORT one-dim-thing,
                                             LOCAL.CAT.HEAD.KEYS.KEY dirnoun]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY dir].

advdir-fixpt-mod-n-phrase := advdir-mod-n-phrase & fixpt-mod.

; experiment only!
#|
;advdir-fixpt-mod-bare-n-phrase := advdir-fixpt-mod-n-phrase & adv-mod-bare-n-phrase.
advdir-fixpt-mod-spr-n-phrase := advdir-fixpt-mod-n-phrase & adv-mod-spr-n-phrase.
advdir-fixpt-mod-defbare-n-phrase := advdir-fixpt-mod-n-phrase & adv-mod-defbare-n-phrase.
|#



advdir-nonfixpt-mod-n-phrase := advdir-mod-n-phrase & nonfixpt-dir-mod.

; experiment only!
#|
advdir-nonfixpt-mod-bare-n-phrase := advdir-nonfixpt-mod-n-phrase & adv-mod-bare-n-phrase.
advdir-nonfixpt-mod-spr-n-phrase := advdir-nonfixpt-mod-n-phrase & adv-mod-spr-n-phrase.
advdir-nonfixpt-mod-defbare-n-phrase := advdir-nonfixpt-mod-n-phrase & adv-mod-defbare-n-phrase.
|#

; allows "gutten/en gutt der sover",
; but excludes "*det sover [en gutt der]" 
advreg-mod-n-phrase := adv-mod-n-phrase & index-sit-mod &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.PRESENTED -,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEF +, ; tempting; "en kopp der" is a small clause
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX.SORT full-thing]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1 ].

; en kopp til
advprtcl-mod-n-phrase := adv-mod-n-phrase &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN -, 
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.PRESENTED -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.DEF -,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -, 
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX.SORT full-thing]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY pcl ].

; experiment only!
#|
advreg-mod-bare-n-phrase := advreg-mod-n-phrase & adv-mod-bare-n-phrase.
advreg-mod-spr-n-phrase := advreg-mod-n-phrase & adv-mod-spr-n-phrase.
advreg-mod-defbare-n-phrase := advreg-mod-n-phrase & adv-mod-defbare-n-phrase.
|#

; adv modif adv, event modif, identical INDEX. Head adv fed by adv-word-reg,
; non-head adv fed by adv-word-2-reg
; "gutten rusler inne borte"
adv-mod-adv-reg-phrase := adv-mod-phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #1]>,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD adv,
             SYNSEM.LOCAL.CONT.HOOK.INDEX #2], 
           [SYNSEM.LOCAL.CONT.HOOK.INDEX #2,
            SYNSEM.IDIOMOD +]>].

; inherits from the above
; adv modif adv, event modif, identical INDEX. Head adv fed by adv-word-reg,
; non-head adv fed by adv-word-2-reg
; "gutten rusler inne borte"
;adv-mod-adv-phrase2 := adv-mod-adv-reg-phrase &
;  [ SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CONT.HOOK.INDEX #1]>,
;    SYNSEM.LOCAL.CONT.HOOK.XARG #1 ].

adv-mod-vp-phrase := adv-mod-phrase & rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #2 & null,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.BND-RESP #37,
    SYNSEM.LOCAL.WAIT-BND-RESP #38,
    EXTRACTED-FROM #10,
    FRONT-TO-FILL #33,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.COORD-RELEASED #18,
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.EXTRACTED-FROM #10,
    HEAD-DTR.FRONT-TO-FILL #33,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY mainvb,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.DELIMTELACTV #17,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #8,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #37,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #38,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.SELECTED -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all,
                                             LOCAL.CAT.VAL [SUBJ cons,
                                                            COMPS <>]]> ].

adv-mod-front-vp-phrase := adv-mod-front-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                      DECL +],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
;    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,  ; her i skogen sover jeg ikke - 6 parses
    FRONT-TO-FILL -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all & [INV +],
                                             LOCAL.CAT.VAL [SUBJ list,
                                                            COMPS list]]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ].

;from + to bool in NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH +, to enable "kanskje kommer kongen?"  this is not interrogative!
adv-interr-mod-front-vp-phrase := adv-mod-front-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all & [INV +],
                                             LOCAL.CAT.VAL [SUBJ list,
                                                            COMPS list]]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH bool ].

adv-interr-mod-front-subordcl-phrase := adv-mod-front-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
				      MAIN-CL -],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
					       WH-COMPLETE -],
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all & [INV -],
                                             LOCAL.CAT.VAL [SUBJ list,
                                                            COMPS list]]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH + ].


;;;;;;;;;;;;;
; removed on Francis' request
;SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
;NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    
    
adjective-mod-vp-phrase := head-initial & rule &
  [ SYNSEM.LOCAL.CAT.VAL #4,
    SYNSEM.LOCAL.CONT.HOOK #2,
    SYNSEM.NON-LOCAL.SLASH #8,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.DELIMTELACTV #17,
    SYNSEM.LOCAL.COORD-RELEASED #18,
    FRONT-TO-FILL #3,
    EXTRACTED-FROM #10,
    SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.BND-RESP #respbind,
    SYNSEM.LOCAL.WAIT-BND-RESP #waitbind,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #respbind,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #waitbind,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY mainvb-norm,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #12,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #4,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #2,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.FRONT-TO-FILL #3,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #8,
    HEAD-DTR.EXTRACTED-FROM #10,
    HEAD-DTR.SYNSEM.LOCAL.DELIMTELACTV #17,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    HEAD-DTR.SYNSEM.LOCAL.NEED-IMP-UNARY #43,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.SELECTED -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    NON-HEAD-DTR.EXTRACTED-FROM -,
    C-CONT.HCONS <! !> ].


free-subjpred-phrase := adjective-mod-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #index1,
    SYNSEM.LOCAL.CAT.HEAD non-copula,
    SYNSEM.LOCAL.CAT.HEAD  #head,
    HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD  #head,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg & [WEAK -,
						  KEYS.KEY propt],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #index2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    C-CONT.RELS <! arg12-relation & [ PRED "coincide-in-time-rel",
                                      ARG1 #index2,
                                      ARG2 #index1 ] !> ].

; 'HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.VOICE active' blocks overgenerations
; allowed by ref to 'VARG'; but blocks free-objpred in passive ditrans
; needs more constraining: 'VARG' can be conjured up from a VP even when it has no arg12-relation head
; SYNSEM.LOCAL.CONT.HOOK.VARG #dirarg,
;    
free-objpred-phrase := adjective-mod-vp-phrase &
  [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #dirarg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #index1,
    SYNSEM.LOCAL.CAT.VAL.SUBJ 1-list,
    SYNSEM.LOCAL.CAT.HEAD  #head,
    SYNSEM.LOCAL.CAT.HEAD non-copula,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD  #head,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #dirarg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ 1-list,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.VOICE active,
    HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-WH-MOVED -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL trans-qval-sup & [DOBJECT.LOCAL.DERIVED-HEAD -,
						     DOBJECT.LOCAL.WH-ISLAND -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg & [WEAK -,
						  KEYS.KEY propt],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #dirarg,
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    C-CONT.RELS <! arg12-relation & [ PRED "coincide-in-time-rel",
                                      ARG1 #index2,
                                      ARG2 #index1 ] !> ].


;,
;    C-CONT.RELS <! arg12-relation & [ PRED "coincide-in-time-rel",
;                                      ARG1 #index2,
;                                      ARG2 #index1 ] !>

free-objpred-pp-phrase := pp-mod-vp-phrase &
  [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #dirarg,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX #index1,
    SYNSEM.LOCAL.CAT.HEAD non-copula,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [] >,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #dirarg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.VOICE active,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL trans-qval-sup & [DOBJECT synsem],
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep,
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #dirarg ].

free-subjpred-som-phrase := adjective-mod-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #index1,
    SYNSEM.LOCAL.CAT.HEAD non-copula,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [] >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY som-pred-n],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND -,
    C-CONT.RELS <! arg12-relation & [ PRED "by-virtue-of-rel",
                                      ARG1 #index1,
                                      ARG2 #index2 ] !> ].

free-objpred-som-phrase := adjective-mod-vp-phrase &
  [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #dirarg,
    SYNSEM.LOCAL.CAT.HEAD non-copula,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL trans-qval-sup,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < [] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #dirarg,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY som-pred-n],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #dirarg,
    NON-HEAD-DTR.SYNSEM.LOCAL.WH-ISLAND - ].

adjective-mod-front-vp-phrase := head-final & rule &
  [ SYNSEM.LOCAL.CAT.VAL #val,
    SYNSEM.LOCAL.CAT.VAL [COMPS <>,
                          ICOMPS <>],
    SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    SYNSEM.LOCAL.COORD-RELEASED #18,
    SYNSEM.NON-LOCAL.SLASH #8,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #1 & [LTOP #top],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #val,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED #18,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #8,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                      DECL +],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    FRONT-TO-FILL -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                               DECL +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH - ].


free-subjpred-front-phrase := adjective-mod-front-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #index1,
    SYNSEM.NON-LOCAL #5,
    SYNSEM.LOCAL.CAT.HEAD non-copula,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg & [WEAK -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index2,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #5,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    C-CONT.RELS <! arg12-relation & [ PRED "coincide-in-time-rel",
                                      ARG1 #index2,
                                      ARG2 #index1 ] !> ].

; the requirement HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL trans-qval, does not prevail across the inverted structure verb-subject, and then this applies also with intrans verbs. Therefore the rule is commented out - too many parses
free-objpred-front-phrase := adjective-mod-front-vp-phrase &
  [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #dirarg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #index1,
    SYNSEM.LOCAL.CAT.HEAD non-copula,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.VOICE active,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL trans-qval-sup,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg & [WEAK -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #dirarg,
    C-CONT.RELS <! arg12-relation & [ PRED "coincide-in-time-rel",
                                      ARG1 #index2,
                                      ARG2 #index1 ] !> ].

free-subjpred-som-front-phrase := adjective-mod-front-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #index1,
    SYNSEM.NON-LOCAL #5,
    SYNSEM.LOCAL.CAT.HEAD non-copula,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY som-pred-n],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index2,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #5,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    C-CONT.RELS <! arg12-relation & [ PRED "by-virtue-of-rel",
                                      ARG1 #index1,
                                      ARG2 #index2 ] !> ].

; the requirement HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL trans-qval, does not prevail across the inverted structure verb-subject, and then this applies also with intrans verbs. Therefore the rule is commented out - too many parses
free-objpred-som-front-phrase := adjective-mod-front-vp-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.VARG #dirarg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #index1,
    SYNSEM.LOCAL.CAT.HEAD non-copula,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL trans-qval-sup,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY som-pred-n],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index2,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #dirarg,
    C-CONT.RELS <! arg12-relation & [ PRED "by-virtue-of-rel",
                                      ARG1 #index1,
                                      ARG2 #index2 ] !> ].


;;;;;;;;;;;;;;;

;SYNSEM.LOCAL.CONT.HOOK.LTOP #1,
;,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #1
    
first-verb-specification := basic-binary-headed-phrase &
  [ SYNSEM.LOCAL.ADV-MODIFIED +,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #6,
    SYNSEM.LOCAL.CONT.HOOK.XARG #66,
    SYNSEM.LOCAL.BND-RESP #resp,
    SYNSEM.NON-LOCAL #7,
;    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
;    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN #40,
    SYNSEM.LOCAL.COMPS-BEGUN #comps,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
;    EXTRACTED-FROM #10,
;    HEAD-DTR.EXTRACTED-FROM #10,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #6,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #66,
;    HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT #31 & -,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.NON-LOCAL #7,
;    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN #40,
    HEAD-DTR.SYNSEM.LOCAL.COMPS-BEGUN #comps,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #7,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    C-CONT [RELS <! !>,
            HCONS <! !>] ].

first-verb-modification := first-verb-specification &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2 ].

;;;;;;;;;;;;;;;
s-adv-mod := first-verb-modification & 
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD s-adv ].

adv-p-first-verb-mod :=  first-verb-modification & 
  [ SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    SYNSEM.LOCAL.INVERT-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT #30,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY canbefirstafterverb-index-sit1,
                                                      SELECTED -],
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -].
;;;;;;;;;;;;;;;;;;;

main-cl-first-verb-spec-phrase := first-verb-specification & basic-head-spec-phrase &
  [ SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.BND-RESP #1,
    SYNSEM.LOCAL.CONT.HOOK #hook,
;    FRONT-TO-FILL #12,
;    HEAD-DTR.FRONT-TO-FILL #12,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ MAIN-CL +],
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD s-adv,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [COMPS <>,
                                       ICOMPS <>,
                                       SUBJ <>],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
	HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
	HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
	SYNSEM.LOCAL.HAS-PUNCT -,
	SYNSEM.LOCAL.HAS-PERIOD -].

main-cl-first-verb-mod := first-verb-modification & head-adj-phrase & 
  [ SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.WAIT-BND-RESP #1,
    FRONT-TO-FILL #12,
    HEAD-DTR.FRONT-TO-FILL #12,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ MAIN-CL +],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [COMPS <>,
                                       SPEC <>,
                                       SPR <>,
                                       ICOMPS <>,
                                       SUBJ <>],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -].

subord-cl-first-verb-mod := first-verb-modification & adj-head-phrase &
  [ SYNSEM.LOCAL.ADJ-SITE-SUBORD-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ MAIN-CL -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem >,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-SUBORD-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT - ,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -  ].

maincl-stnd-first-verb-mod := main-cl-first-verb-mod &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC #9,
    SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC #9,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [SPEC <>,
                                       SUBJ <>]  ].

maincl-invert-first-verb-mod := main-cl-first-verb-mod &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV +,
                                     IMPERATIVE - ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ list].

;;;;;

qualifadv-phrase := basic-head-spec-phrase & head-final &
  [ SYNSEM.LOCAL.ADV-MODIFIED +,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #6,
    SYNSEM.LOCAL.CONT.HOOK.XARG #66,
    SYNSEM.NON-LOCAL #7,
    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN #40,
    SYNSEM.LOCAL.COMPS-BEGUN #comps,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    EXTRACTED-FROM #10,
    HEAD-DTR.EXTRACTED-FROM #10,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #6,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #66,
    HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT #31 & -,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.NON-LOCAL #7,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN #40,
    HEAD-DTR.SYNSEM.LOCAL.COMPS-BEGUN #comps,
    NON-HEAD-DTR qualadv-word,
    NON-HEAD-DTR.SYNSEM.LKEYS.KEYREL.ARG1 #4,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #4,
    C-CONT [RELS <! !>,
            HCONS <! !>] ].
    
qualifadv-quant-phrase := qualifadv-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD quantor,
    NON-HEAD-DTR qualifadv-quant-word ].
qualifadv-allquant-phrase := qualifadv-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD allquant,
    NON-HEAD-DTR qualifadv-allquant-word ].
qualifadv-card-phrase := qualifadv-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD card,
    NON-HEAD-DTR qualifadv-card-word ].
focqualifadv-n-phrase := qualifadv-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    NON-HEAD-DTR focqualifadv-n-word ].
focqualifadv-padv-phrase := qualifadv-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adv,
    NON-HEAD-DTR focqualifadv-padv-word ].
;;;;;;;;;;;;;;

s-adv-spec-v-phrase-sup := main-cl-first-verb-spec-phrase & head-initial &
  [ SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    SYNSEM.LOCAL.CAT.HEAD [ MAIN-CL #main ],
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem >,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV -,
				     MAIN-CL #main & + ] ].	

; for position after first verb
s-adv-spec-v-phrase := s-adv-spec-v-phrase-sup &
  [  SYNSEM.LOCAL.ADJ-SITE-OPEN #open,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem >,
     HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN #open ].

; for position after first verb, in subj-verb inverted structure
s-adv-spec-invert-v-phrase := main-cl-first-verb-spec-phrase & head-initial &
  [ SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV +] ].

; for position after VP
;s-adv-final-spec-v-phrase := s-adv-spec-v-phrase-sup &
s-adv-final-spec-v-phrase :=  main-cl-first-verb-spec-phrase & head-initial &
  [  SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem >,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV -],
     NON-HEAD-DTR.CAN-OCCUR-FINAL + ].

s-adv-final-spec-invert-v-phrase :=  main-cl-first-verb-spec-phrase & head-initial &
  [  SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV +],
     NON-HEAD-DTR.CAN-OCCUR-FINAL bool ].

; for clause-initial position ...
s-adv-front-spec-v-phrase-sup := main-cl-first-verb-spec-phrase & head-final &
  [ SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <anti-synsem>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    FRONT-TO-FILL -,
    HEAD-DTR.FRONT-TO-FILL +,
    NON-HEAD-DTR.CAN-OCCUR-INITIAL +  ].

; ... initial with inversion (normal)
s-adv-front-spec-v-phrase := s-adv-front-spec-v-phrase-sup &
  [ SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
     HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV +] ].

; ... initial without inversion (only with "kanskje")
s-adv-front-noninver-spec-v-phrase := s-adv-front-spec-v-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY kanskje-k ].


s-adv-fragmfinal-spec-phrase-sup :=  head-initial &
  [ SYNSEM.LOCAL.ADV-MODIFIED +,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #6,
    SYNSEM.LOCAL.CONT.HOOK.XARG #66,
    SYNSEM.LOCAL.BND-RESP #resp,
    SYNSEM.NON-LOCAL #7,
;    SYNSEM.LOCAL.IS-A-COMPLEMENT #31,
;    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN #40,
    SYNSEM.LOCAL.COMPS-BEGUN #comps,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
;    EXTRACTED-FROM #10,
;    HEAD-DTR.EXTRACTED-FROM #10,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #6,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #66,
;    HEAD-DTR.SYNSEM.LOCAL.IS-A-COMPLEMENT #31 & -,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.NON-LOCAL #7,
;    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN #40,
    HEAD-DTR.SYNSEM.LOCAL.COMPS-BEGUN #comps,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL #7,
    NON-HEAD-DTR.SYNSEM.LOCAL.BND-RESP #resp,
    C-CONT [RELS <! !>,
            HCONS <! !>],
    SYNSEM.LOCAL.CLIT-SITE-OPEN -,
    SYNSEM.LOCAL.BND-RESP #1,
    SYNSEM.LOCAL.CONT.HOOK #hook,
;    FRONT-TO-FILL #12,
;    HEAD-DTR.FRONT-TO-FILL #12,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ MAIN-CL +],
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD s-adv,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [COMPS <>,
                                       ICOMPS <>,
                                       SUBJ <>],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
	HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
	HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
	SYNSEM.LOCAL.HAS-PUNCT -,
	SYNSEM.LOCAL.HAS-PERIOD -,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem >,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN -,
     HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ INV -],
     NON-HEAD-DTR.CAN-OCCUR-FINAL + ].

s-adv-fragmfinal-spec-phrase := s-adv-fragmfinal-spec-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-or-adj-or-adv ].
s-adv-fragmfinal-n-spec-phrase := s-adv-fragmfinal-spec-phrase-sup &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nominal ].

;;  ALTERED for malgram

; semarg <- #lbl
s-adv-spec-v-subord-phrase := first-verb-specification & basic-head-spec-tweak-phrase & head-final &
  [ SYNSEM.LOCAL.ADJ-SITE-SUBORD-OPEN +,
    SYNSEM.LOCAL.HAS-PUNCT #hpu,
    SYNSEM.LOCAL.ADJ-SITE-OPEN #open,; a feature induced by aux-bare-inf, which has a common form in main and subord clause
     SYNSEM.LOCAL.HAS-PERIOD #hp,
;    SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX #hook,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #5,
;    SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ MAIN-CL -],
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < synsem >,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-SUBORD-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN #open,
     HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT #hpu,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD #hp,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #hook,
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < [LOCAL.CONT.HOOK.LTOP #5] >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.RELS <! [LBL semarg,
					    ARG1 #5] !>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD s-adv  ].

s-adv-mod-v-phrase := s-adv-mod & maincl-stnd-first-verb-mod &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN + ].
s-adv-mod-invert-v-phrase := s-adv-mod & maincl-invert-first-verb-mod &
  [ SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN + ].

s-adv-mod-v-subord-phrase := s-adv-mod & subord-cl-first-verb-mod.

; HEAD-DTR.SYNSEM.LOCAL.HAS-A-V-COMPLEMENT +
adverbial-stnd-first-verb-mod-phrase := adv-p-first-verb-mod & maincl-stnd-first-verb-mod & index-sit-mod &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [],... > ].
;  & index-sit-mod
adverbial-invert-first-verb-mod-phrase := adv-p-first-verb-mod & maincl-invert-first-verb-mod &
  [ HEAD-DTR.SYNSEM.LOCAL.CAN-CMB-INDEX-SIT +,
    HEAD-DTR.SYNSEM.LOCAL.ADJ-SITE-OPEN +,
    HEAD-DTR.SYNSEM.LOCAL.CLIT-PRON-CONFIRMED +,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
	HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,				; has-punct and -period required for NorMal, but
	HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -  ].			; probably useful also for NorSource. EAA.

adverbial-subordcl-first-verb-mod-phrase := adv-p-first-verb-mod & subord-cl-first-verb-mod & index-sit-mod.
;;;;;;;;;;;;;;;;;;;;;;


telic-pp-mod-vp-phrase := pp-mod-vp-phrase & telic-mod-vp-phrase & fixpt-mod & 
  [ NON-HEAD-DTR [SYNSEM.LOCAL.HAS-PUNCT - ]].
telic-pp-mod-vp-comma-phrase := pp-mod-vp-phrase & telic-mod-vp-phrase & 
  [ NON-HEAD-DTR connector-mod-phrase & [SYNSEM.LOCAL.CAT.HEAD.TEL-FIXING - ]].
telic-pp-mod-vp-2-phrase := pp-mod-vp-2-phrase & telic-mod-vp-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.TEL-FIXING - ].

;telic-pp-mod-vp-phrase2 := pp-mod-vp-phrase2 & telic-mod-vp-phrase.

telic-adv-mod-vp-phrase := adv-mod-vp-phrase & telic-mod-vp-phrase & fixpt-mod & 
  [ NON-HEAD-DTR [SYNSEM.LOCAL.HAS-PUNCT - ]].
telic-adv-mod-vp-comma-phrase := adv-mod-vp-phrase & telic-mod-vp-phrase & 
  [ NON-HEAD-DTR connector-mod-phrase ].

;telic-adv-mod-vp-phrase2 := adv-mod-vp-phrase2 & telic-mod-vp-phrase.

atelic-pp-mod-vp-phrase := pp-mod-vp-phrase & atelic-mod-vp-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.TEL-FIXING - ].
atelic-pp-mod-vp-nonfixptdir-phrase := atelic-pp-mod-vp-phrase & nonfixpt-dir-mod & 
  [ NON-HEAD-DTR [SYNSEM.LOCAL.HAS-PUNCT - ]].
atelic-pp-mod-vp-comma-phrase := atelic-pp-mod-vp-phrase & 
  [ NON-HEAD-DTR connector-mod-phrase & [SYNSEM.LOCAL.CAT.HEAD.TEL-FIXING - ]].

atelic-pp-mod-vp-index-sit-phrase := atelic-pp-mod-vp-phrase & index-sit-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1,
    NON-HEAD-DTR [SYNSEM.LOCAL.HAS-PUNCT - ] ].

atelic-pp-mod-vp-2-phrase := pp-mod-vp-2-phrase & atelic-mod-vp-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.TEL-FIXING - ].

;atelic-pp-mod-vp-phrase2 := pp-mod-vp-phrase2 & atelic-mod-vp-phrase.

atelic-adv-mod-vp-phrase := adv-mod-vp-phrase & atelic-mod-vp-phrase.
atelic-adv-mod-vp-nonfixptdir-phrase := atelic-adv-mod-vp-phrase & nonfixpt-dir-mod & 
  [ NON-HEAD-DTR [SYNSEM.LOCAL.HAS-PUNCT - ]].
atelic-adv-mod-vp-comma-phrase := atelic-adv-mod-vp-phrase & nonfixpt-dir-mod & 
  [ NON-HEAD-DTR connector-mod-phrase ].
atelic-adv-mod-vp-index-sit-phrase := atelic-adv-mod-vp-phrase & index-sit-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1 ].


atelic-front-adv-mod-vp-phrase := adv-mod-front-vp-phrase & atelic-front-mod-vp-phrase.
atelic-front-adv-mod-vp-nonfixptdir-phrase := atelic-front-adv-mod-vp-phrase & nonfixpt-dir-mod.
; removed '& index-sit-mod ', since adverbial clauses in front are index-sit
atelic-front-adv-mod-vp-index-sit-phrase := atelic-front-adv-mod-vp-phrase & index-sit-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1 ].
telic-front-adv-mod-vp-phrase := adv-mod-front-vp-phrase & telic-front-mod-vp-phrase.

; for "kanskje kongen kommer" (?/.)
front-adv-mod-vp-noninvert-phrase := adv-mod-front-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -],
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    FRONT-TO-FILL -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY kanskje-k,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD verb-all & [INV -],
                                             LOCAL.CAT.VAL [SUBJ list,
                                                            COMPS list]]> ].

atelic-interr-front-adv-mod-vp-phrase := adv-interr-mod-front-vp-phrase & atelic-front-mod-vp-phrase.
atelic-interr-front-adv-mod-vp-nonfixptdir-phrase := atelic-interr-front-adv-mod-vp-phrase & nonfixpt-dir-mod.
; removed '& index-sit-mod ', since adverbial clauses in front are index-sit
atelic-interr-front-adv-mod-vp-index-sit-phrase := atelic-interr-front-adv-mod-vp-phrase & index-sit-mod &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY index-sit1 ].
telic-interr-front-adv-mod-vp-phrase := adv-interr-mod-front-vp-phrase & telic-front-mod-vp-phrase.

;atelic-adv-mod-vp-phrase2 := adv-mod-vp-phrase2 & atelic-mod-vp-phrase.

nonaspect-pp-mod-vp-phrase := pp-mod-vp-phrase & non-aspect-mod-vp-phrase.

nonaspect-adv-mod-vp-phrase := adv-mod-vp-phrase & non-aspect-mod-vp-phrase.

;TODO: to get "hvor flink er han?", both extraction and topic-filler have to apply to adjective phrases.
extracted-comp-phrase := basic-extracted-comp-phrase &
  [ EXTRACTED-FROM +,
    SYNSEM.BIND #8,
    SYNSEM.LOCAL.CAT.VAL [ICOMPS #1,
			  COMPS #comps],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [SUBJ list,
                                   ICOMPS #1,
				   COMPS < gap &
                                           [ NON-LOCAL.SLASH #slash ]
                                           . #comps > ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.EXTRACTED-FROM -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    HEAD-DTR.SYNSEM.BIND #8,
    HEAD-DTR.SYNSEM.LOCAL.ADV-MODIFIED -,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash  ].

; LH160412  - reduce from 8 to 2 parses for "sang mann synger smiler"
extracted-icomp-phrase := basic-extracted-icomp-phrase &
  [ EXTRACTED-FROM +,
    SYNSEM.BIND #8,
    SYNSEM.LOCAL.CAT.VAL [COMPS #1],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [SUBJ list,
                                   ICOMPS < [LOCAL.CAT.HEAD prep-ultra,
					     LOCAL.CONT.HOOK.INDEX event],... >,
                                   COMPS #1],
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.EXTRACTED-FROM -,
    HEAD-DTR.SYNSEM.BIND #8,
    HEAD-DTR.SYNSEM.LOCAL.ADV-MODIFIED - ].

extracted-verbcomp-phrase-sup := extracted-comp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all ].


;;; 16.12.10 MHS Added COMPS-BEGUN - in an attempt to reduce spurious ambiguity. Might be a problem, though I don't know specifically how or why. 
; It was - one could extract only the first object in a ditransitive clause
; COMPS-BEGUN -
;INV +
mcl-extracted-verbcomp-phrase := extracted-verbcomp-phrase-sup &
 [ HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ MAIN-CL +,
					INV bool ]],
;				 VAL.SUBJ < anti-synsem >], 
;				 QVAL.SUBJECT.SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE -],  ; this cannot be activated, then one gets a clash between lex-synsem and phr-synsem for QVAL.SUBJECT, very strange.
			   COMPS-BEGUN bool]].

non-mcl-extracted-verbcomp-phrase := extracted-verbcomp-phrase-sup &
[ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD [ MAIN-CL - ]]].

extracted-verbicomp-phrase-sup := extracted-icomp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all ].


;;; 16.12.10 MHS Added COMPS-BEGUN - in an attempt to reduce spurious ambiguity. Might be a problem, though I don't know specifically how or why.
; LH011012 works fine, it seems 

mcl-extracted-verbicomp-phrase := extracted-verbicomp-phrase-sup &
 [ HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ MAIN-CL +,
					INV + ],
				 VAL.SUBJ < anti-synsem >,
				 QVAL.SUBJECT.SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE -],
			   COMPS-BEGUN -]].

non-mcl-extracted-verbicomp-phrase := extracted-verbicomp-phrase-sup &
[ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD [ MAIN-CL - ]]].





extracted-prepcomp-phrase := extracted-comp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD np-head ]> ].
extracted-verbcomp-phrase := extracted-comp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all ].

; COMPS < [LOCAL.CAT.HEAD fin-comp ] >
extracted-event-comp-phrase := basic-extracted-comp-phrase &
  [ EXTRACTED-FROM +,
    SYNSEM.BIND #8,
    SYNSEM.LOCAL.CAT.VAL [ICOMPS #1],
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [SUBJ list,
                                   COMPS < [LOCAL.CONT.HOOK.INDEX event-verb ] >,
                                   ICOMPS #1],
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.EXTRACTED-FROM -,
    HEAD-DTR.SYNSEM.BIND #8,
    HEAD-DTR.SYNSEM.LEX +,
    HEAD-DTR.SYNSEM.LOCAL.ADV-MODIFIED - ].

extracted-event-prepcomp-phrase := extracted-event-comp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep-ultra,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD fin-comp ] > ].
extracted-event-verbcomp-phrase := extracted-event-comp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all ].



;,
;    HEAD-DTR.EXTRACTED-FROM -
extracted-prep-comp-phrase := basic-extracted-comp-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD prep & [ MOD < [ LOCAL.CAT.VAL.COMPS <>,
					   LOCAL.DERIVED-HEAD #bool] >],
    EXTRACTED-FROM +,
    FRONT-TO-FILL +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep & [ MOD < [ LOCAL.CAT.VAL.COMPS <>,
						    LOCAL.DERIVED-HEAD #bool] >],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [COMPS < [LOCAL.CAT.HEAD nom ] >] ].

extracted-subj-phrase := basic-extracted-subj-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [SUBJ list ],
    HEAD-DTR.SYNSEM.LOCAL.ADV-MODIFIED -,
    C-CONT [ RELS <! !>,
	     HCONS <! !> ],
    HEAD-DTR.EXTRACTED-FROM - ].


;; ALTERED for MAL rules

#|
head-filler-topic-phrase-sup := basic-head-filler-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                      DECL +],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    SYNSEM.LOCAL.CAT.VAL.SUBJ #1,
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT #cat,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.BIND #8,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <anti-synsem>,
    HEAD-DTR.SYNSEM.LOCAL.CAT #cat,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.EXTRACTED-FROM +,
    HEAD-DTR.FRONT-TO-FILL +,
    HEAD-DTR.SYNSEM.BIND #8,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].




head-filler-topic-phrase := head-filler-topic-phrase-sup &
[ SYNSEM.LOCAL.CAT.HEAD.INV + ].

var-non_inv-head-filler-topic-phrase := head-filler-topic-phrase-sup &
[ SYNSEM.LOCAL.CAT.HEAD.INV - ].
|#

;; 14.12.10 MHS
;; Changed RIGHT-ADJ-SITE-OPEN + to -.

head-filler-topic-phrase := basic-head-filler-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                      DECL +],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    SYNSEM.LOCAL.CAT.VAL.SUBJ #1,
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT #cat,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.BIND #8,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
;    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <anti-synsem>,
    HEAD-DTR.SYNSEM.LOCAL.CAT #cat,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.EXTRACTED-FROM +,
;    HEAD-DTR.FRONT-TO-FILL +,
    HEAD-DTR.SYNSEM.BIND #8,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.EXPLETIVE -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK [ INDEX #ind, LTOP #lbl ], ;; MHS 180511 Add re-entrancy of LTOP and LBL to fix leaf/hole mismatch.
    C-CONT [ RELS <!fpos_prom_rel & [ ARG1 #ind, LBL #lbl ] !>,
	     HCONS <! !> ] ].

head-filler-n-topic-phrase := head-filler-topic-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ACCUSATIVE +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [WH -]].
head-filler-adj-topic-phrase := head-filler-topic-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj-reg,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -].
head-filler-adv-topic-phrase := head-filler-topic-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adv-reg,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -].
head-filler-p-topic-phrase := head-filler-topic-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD prep,
    NON-HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -].
head-filler-event-topic-phrase := head-filler-topic-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX event-verb ].

; TODO: should really omit ref-ind in NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [WH +], to get "hvor bor han?", "hvor er han?" etc, without a fake ref-ind-hvor
head-filler-wh-phrase := basic-head-filler-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                      DECL -],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -, ; to ensure the wh c-commands everything
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    HEAD-DTR.EXTRACTED-FROM +,
;    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +, ; LH wonder why this was
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX [WH +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD np-head & [ACCUSATIVE +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    C-CONT [ RELS <! !>,
	     HCONS <! !> ]  ].


#|
head-filler-topic-phrase := basic-head-filler-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV +,
                                      DECL +],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    SYNSEM.LOCAL.CAT.VAL.SUBJ #1,
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.CAT #cat,
    SYNSEM.LOCAL.CAT.QVAL #qval,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.BIND #8,
    SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bndresp,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #varg,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #1,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <anti-synsem>,
    HEAD-DTR.SYNSEM.LOCAL.CAT #cat,
    HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL #qval,
    HEAD-DTR.EXTRACTED-FROM +,
    HEAD-DTR.FRONT-TO-FILL +,
    HEAD-DTR.SYNSEM.BIND #8,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    HEAD-DTR.SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
    NON-HEAD-DTR.RULE card-ok,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.COORD-RELEASED +,
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].
|#



; this rule induces a question taking scope over the proposition created 
; by the head-subject rule of the embedded clause. Better than
; depriving the latter of its usual force, it seems.

head-filler-subord-wh-phrase := basic-head-filler-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
                                      DECL -,
                                      MAIN-CL - ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #6,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #10,
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.IMPERATIVE -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
                                               DECL -,
                                               MAIN-CL - ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #6,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #10,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT #init,
    HEAD-DTR.EXTRACTED-FROM +,
    HEAD-DTR head-subject-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [ WH + ],
; nominal rather than np-head, to avoid that connect-n is used as head
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nominal,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    C-CONT [ RELS <! !>,
             HCONS <! !> ]   ].


;;; MHS 2002 020411 Removed SYNSEM.LOCAL.CAT.VAL.SUBJ <>, from head-subjfiller-subord-wh-phrase

head-subjfiller-subord-wh-phrase := basic-head-filler-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
                                      DECL -,
                                      MAIN-CL - ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E #6,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.WH -,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.SF ques,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #index,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #10,
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    SYNSEM.LOCAL.CAN-RELATIVE-ADJOIN -,
    HEAD-DTR head-resumptsubject-interr-phrase,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E #6,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #15,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #10,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #10,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    HEAD-DTR.EXTRACTED-FROM -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [WH +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ACCUSATIVE - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #15,
    C-CONT [ RELS <! !>,
             HCONS <! !> ]   ].



#|
nom-of-head-subjfiller-subord-wh-phrase := unary-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD poss-subj-head,
    SYNSEM.LOCAL.CAT.VAL #val,
    SYNSEM.LOCAL.CONT #cont,
    ARGS < head-subjfiller-subord-wh-phrase &
           [ SYNSEM.LOCAL.CAT.VAL #val,
             SYNSEM.LOCAL.CONT #cont ] >,
    C-CONT [ RELS <! !>,
             HCONS <! !> ]].
|#

#| a non-message version of the indirect quest filler rule. abandoned.
head-filler-subord-wh-phrase := basic-head-filler-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all & [INV -,
                                      DECL -,
                                      MAIN-CL - ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    SYNSEM.LOCAL.ADJ-SITE-OPEN -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD #6,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #3,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <anti-synsem>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind & [WH +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.ACCUSATIVE +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>   ].
|#


;;; DPF

; LH 'DECL +' to avoid indirquests as non-head-dtr
relative-extract-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT.HOOK.XARG #xrg,
    SYNSEM.LOCAL.HAS-REL-CL +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.POSSPRON-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xrg,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD nom,
                                             LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [WH-MOVED +,
						   INV -,
						   DECL +],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT +,
    C-CONT.HCONS <! !>].

#|
relative-extract-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.HAS-REL-CL +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[ LOCAL.CAT.HEAD nom,
                                              LOCAL.CONT.HOOK.INDEX #1 ]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [WH-MOVED +,
						   INV -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT +,
    C-CONT.HCONS <! !>].
|#


comma-rightmod-relcomp-som-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD noun,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR comma-rightmod-relcomp-som-phrase ,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD nom,
                                             LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    C-CONT.HCONS <! !>].

#|
bare-relative-extract-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.HAS-REL-CL +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [SORT referential-thing],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD noun,
    HEAD-DTR.SYNSEM.LOCAL.BINDING.BOUND -,
    HEAD-DTR.SYNSEM.LOCAL.SPEC-TO-BARE-N -,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR unary-rel-head-filler-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD nom,
                                             LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    C-CONT.HCONS <! !>]. 
|#

bare-relative-extract-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.HAS-REL-CL +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [SORT referential-thing,
				       WH -],
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom & [RELATIVPRON -],
    HEAD-DTR.SYNSEM.LOCAL.BINDING.BOUND -,
;    HEAD-DTR.SYNSEM.LOCAL.SPEC-TO-BARE-N -,
;    HEAD-DTR.SYNSEM.LOCAL.DERIVED-HEAD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ -,
    HEAD-DTR.SYNSEM.LOCAL.HAS-PUNCT -,
    NON-HEAD-DTR unary-rel-head-filler-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD poss-subj-head,
                                             LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    C-CONT.HCONS <! !>]. 

comma-rightmod-relsubj-√∏-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD noun,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR comma-rightmod-relsubj-√∏-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[LOCAL.CAT.HEAD nom,
                                             LOCAL.CONT.HOOK.INDEX #1]>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    C-CONT.HCONS <! !>]. 




relative-subj-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [WH -], ; to avoid 'hvem som ...' as rel constr
    SYNSEM.LOCAL.HAS-REL-CL +,
    SYNSEM.LOCAL.BND-RESP #bnd,
    SYNSEM.NON-LOCAL.SLASH #slash,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bnd,
    NON-HEAD-DTR head-relative-subject-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [WH-COMPLETE +,
						   WH-MOVED -,
						   INV -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.RELATIVPRON +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #lbl,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAN-RELATIVE-ADJOIN +,
    C-CONT.HCONS <! !>]. 


#|
relative-subj-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.HAS-REL-CL +,
    SYNSEM.NON-LOCAL.SLASH #slash,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [WH-COMPLETE +,
						   WH-MOVED -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.RELATIVPRON +,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT +,
    C-CONT.HCONS <! !>]. 
|#


comma-rightmod-relsubj-som-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR comma-rightmod-relsubj-som-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ list,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    C-CONT.HCONS <! !>]. 

comma-rightmod-nonrestr-relsubj-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR comma-leftmod-nonrestr-relsubj-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ list,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    C-CONT.HCONS <! !>]. 

comma-rightmod-nonrestr-relcomp-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR comma-leftmod-nonrestr-relcomp-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ list,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <>,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD nom,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR <>,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    C-CONT.HCONS <! !>]. 



relative-comma-relsubj-som-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD nom,
    SYNSEM #1,
    HEAD-DTR.SYNSEM #1,
    NON-HEAD-DTR comma-rightmod-relsubj-som-phrase ].



; 'MUST-APP' only to avoid coordination bare
rel-comp := word &
  [SYNSEM [LOCAL.CAT.HEAD [ RELATIVPRON + ],
           LOCAL.CAT.VAL.SUBJ <>,
           LOCAL.CAT.VAL.SPR <>,
           LOCAL.CAT.VAL.SPEC <>,
           LOCAL.CAT.VAL.COMPS <>,
           LOCAL.MUST-APP +,
           LOCAL.CONT.HOOK.LTOP #1,
           LOCAL.CONT.HOOK.INDEX #2,
           LOCAL.CONT.HOOK.INDEX.WH -,
           LOCAL.CONT.RELS <! arg0bare-relation & [ PRED "_relpartcl_rel",
						    ARG0 #2,
						    LBL #1 ] !>,
           LOCAL.CONT.HCONS <! !>]].
som_filler-relpron := rel-comp & 
  [ SYNSEM.LOCAL.CAT.HEAD rel-filler,
    SYNSEM.LOCAL.CONT.HOOK.INDEX ref-ind ].
hvilket_filler-relpron := rel-comp & 
  [ SYNSEM.LOCAL.CAT.HEAD comp,
    SYNSEM.LOCAL.CONT.HOOK.INDEX event-verb ].

#|
extracted-subj-phrase := basic-extracted-subj-phrase & head-compositional &
  [C-CONT [ RELS <! !>,
	   HCONS <! !> ]].

extracted-comp-phrase := basic-extracted-comp-phrase &
  [C-CONT [ RELS <! !>,
	   HCONS <! !> ]].
|#
; the rule that combines "som" with S:


; without message
rel-head-filler-phrase := basic-head-filler-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all & [MOD < [ LOCAL.CONT.HOOK.INDEX #1 & ref-ind,
					       LOCAL.CONT.HOOK.LTOP #2,
					       LOCAL.CAT.HEAD noun ] >,
				       WH-COMPLETE +,
				       WH-MOVED +,
				       MAIN-CL #main],
     SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
     SYNSEM.LOCAL.CAT.VAL.SPEC < >,
     SYNSEM.LOCAL.CONT.HOOK.XARG #1,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop-or-ques,
     SYNSEM.LOCAL.CAN-CMB-V -,
     ARGS <  rel-comp & [SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
			 SYNSEM.LOCAL.CONT.HOOK.INDEX #1 ],
            head-subject-phrase &
	     [ SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
              SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV -,
                                                 IMPERATIVE -,
						 MAIN-CL #main & -],
              SYNSEM.LOCAL.CAT.VAL.COMPS < >,
              SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
              SYNSEM.LOCAL.CAT.VAL.SPR < >,
              SYNSEM.LOCAL.CAT.VAL.SPEC < >,
              SYNSEM.LOCAL.CAT.HEAD.MOD < >,
              EXTRACTED-FROM +] >,
    C-CONT [ RELS <! !>,
             HCONS <! !> ]].

unary-rel-head-filler-phrase := basic-unary-head-filler-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all & [MOD < [ LOCAL.CONT.HOOK.INDEX #1,
                                               LOCAL.CONT.HOOK.LTOP #2,
                                               LOCAL.CAT.HEAD nom & [EXPLETIVE #head & -] ] >,
				       WH-COMPLETE +,
				       WH-MOVED -],
     SYNSEM.LOCAL.CAT.VAL.SUBJ <>,
     SYNSEM.LOCAL.CAT.VAL.SPEC <>,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
     SYNSEM.LOCAL.CONT.HOOK.XARG #1,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop-or-ques,
     SYNSEM.LOCAL.IS-A-COMPLEMENT -,
     SYNSEM.LOCAL.REL-CL-SOM-INIT +,
     SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN -,
 ;    SYNSEM.LOCAL.REL-CL-SOM-INIT #5,
     ARGS <  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
               SYNSEM.LOCAL.CONT.HOOK.XARG ref-ind,
               SYNSEM.LOCAL.CONT.HOOK.INDEX.E [ MOOD indicative],
               SYNSEM.LOCAL.CAT.HEAD [ INV -,
                                       IMPERATIVE - ],
               SYNSEM.LOCAL.CAT.VAL.COMPS < >,
               SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
               SYNSEM.LOCAL.CAT.VAL.SUBJ list,
               SYNSEM.LOCAL.CAT.VAL.SPR < >,
               SYNSEM.LOCAL.CAT.VAL.SPEC < >,
               SYNSEM.LOCAL.CAT.HEAD.MOD < >,
               SYNSEM.NON-LOCAL.SLASH.LIST.FIRST.CONT.HOOK.INDEX #1 & ref-ind,
               SYNSEM.NON-LOCAL.SLASH.LIST.FIRST.CAT.HEAD nom & [EXPLETIVE #head],
               EXTRACTED-FROM +,
;               SYNSEM.LOCAL.REL-CL-SOM-INIT #5,
               SYNSEM.LOCAL.REL-CL-SOM-INIT bool ] >,
    C-CONT [ RELS <! !>,
             HCONS <! !> ]].

;;;;;;;;;;;

unary-fin-rel-head-filler-phrase := unary-rel-head-filler-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all & [MOD < [ LOCAL.CAT.HEAD nom ] >,
				       MAIN-CL #main & - ],
     SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.RELATIVPRON #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.E [ TENSE #fin & finite ],
     ARGS <  head-subject-phrase & 
             [ SYNSEM.LOCAL.CAT.HEAD verb-all & [MAIN-CL #main ],
	       SYNSEM.LOCAL.CONT.HOOK.INDEX.E [ TENSE #fin ],
	       SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.RELATIVPRON #2]> ].

unary-infin-rel-head-filler-phrase := unary-rel-head-filler-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD [MOD < [ LOCAL.CAT.HEAD.DEF - ] >],
     SYNSEM.LOCAL.HAS-WH-MOVED +,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.E [ TENSE #infin & infin ],
     ARGS <  head-complementizer-comp-absinf-phrase & 
             [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E [ TENSE #infin ],
               SYNSEM.LOCAL.CAT.HEAD glob-comp & [TRANSPAR -] ] >].

;without message
;; "hvilket || jeg vet"
rel-vp-head-filler-phrase := basic-head-filler-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all & [MOD < [ LOCAL.CONT.HOOK.INDEX #1,
					       LOCAL.CONT.HOOK.LTOP #2,
					       LOCAL.CAT.HEAD verb-all ] >,
				       WH-COMPLETE +,
				       WH-MOVED +],
     SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
     SYNSEM.LOCAL.CAT.VAL.SPEC <>,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop-or-ques,
     SYNSEM.LOCAL.CAN-CMB-V -,
     ARGS <  rel-comp & [SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
			 SYNSEM.LOCAL.CONT.HOOK.INDEX #1 ],
            head-subject-phrase &
	     [ SYNSEM.LOCAL.CONT.HOOK.LTOP #2,
              SYNSEM.LOCAL.CAT.HEAD verb-all & [ INV -,
                                                 IMPERATIVE - ],
              SYNSEM.LOCAL.CAT.VAL.COMPS <>,
              SYNSEM.LOCAL.CAT.VAL.SUBJ olist,
              SYNSEM.LOCAL.CAT.VAL.SPR <>,
              SYNSEM.LOCAL.CAT.VAL.SPEC <>,
              SYNSEM.LOCAL.CAT.HEAD.MOD <>,
              EXTRACTED-FROM +] >,
    C-CONT [ RELS <! !>,
             HCONS <! !> ]].

;;;;;;;;;

; "han kommer || hvilket skremmer meg"
; the requirement NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.RELPRON + had to be dropped, to let through the event-subject - - otherwise the 'rel-pron' which goes with normal rel clause has this requirement, cf. relative-subj-mod-phrase 
vp-relative-subj-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.HAS-REL-CL +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < >,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR head-relative-subject-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [WH-COMPLETE +,
						   WH-MOVED -],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD comp,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.HAS-PERIOD -,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT +,
    C-CONT.HCONS <! !>]. 

; "han kommer || hvilket jeg har sett"
vp-relative-extract-mod-phrase := head-adj-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.VAL #2,
    SYNSEM.LOCAL.HAS-REL-CL +,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL #2,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < >,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD <[ LOCAL.CAT.HEAD verb-all,
                                              LOCAL.CONT.HOOK.INDEX #1 ]>,
    NON-HEAD-DTR rel-vp-head-filler-phrase,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb-all & [ WH-MOVED +,
						    INV - ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.REL-CL-SOM-INIT +,
    C-CONT.HCONS <! !>].


;; Coordination
;; EAA070212: Have changed coordination to remove unwanted EP, and fixed left handle. Watch out for consequences!

coordinating-phrase := binary-phrase &
 [ SYNSEM.LOCAL.COORD-POL #1,
   SYNSEM.LOCAL.CAN-COORD-COMP -,
    ARGS < [SYNSEM.LOCAL.CORRCOORD-CLOSED -], [ SYNSEM.LOCAL.COORD-POL #1 ] >].

; for coord of nps...
; EAA020811: Removed sort-constraint. Seemed to block normal coordinations.
; EAA170811: Added unified constraints for ACCUSATIVE, to avoid "han og henne spiser."
; EAA070212: Added two constraints to connect left handle
coordination-numsensitive-phrase := coordinating-phrase & non-headed-phrase & rule &
  [  SYNSEM.LOCAL.CAT.HEAD #32 & np-head & [COORDINABLE + ],
     SYNSEM.LOCAL.CONT.HOOK.INDEX #1, ; & [SORT #7],
     SYNSEM.LOCAL.CAT.VAL #4,
     SYNSEM.LOCAL.BINDING #12,
     SYNSEM.NON-LOCAL #5,
     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.LOCAL.BND-RESP #3,
     RULE #6,
     ARGS < [ SYNSEM.LOCAL.CAT.HEAD #32 & [ACCUSATIVE #acc],
              SYNSEM.LOCAL.CAT.VAL #4,
              SYNSEM.LOCAL.CONT.HOOK.INDEX #2, ;& [SORT #7],
			  SYNSEM.LOCAL.CONT.HOOK.LTOP #lhandle,
              SYNSEM.LOCAL.MUST-APP -,
              SYNSEM.NON-LOCAL #5,
              SYNSEM.LOCAL.DERIVED-HEAD #11,
              SYNSEM.LOCAL.BINDING #12,
              SYNSEM.LOCAL.BND-RESP #3,
              RULE #6], 
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
             SYNSEM.LOCAL.CAT.HEAD coord,
			 SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #lhandle ] >,
             SYNSEM.LOCAL.XCAT.HEAD nominal & [COORDINABLE +, ACCUSATIVE #acc],
;             SYNSEM.LOCAL.XSORT #7,
             SYNSEM.LOCAL.CAT.VAL.COMPS <>,
             SYNSEM.LOCAL.CONT.HOOK.XARG #2,
             SYNSEM.LOCAL.DERIVED-HEAD #11,
             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.LOCAL.HAS-PUNCT bool,
             SYNSEM.LOCAL.BND-RESP #3,
             SYNSEM.NON-LOCAL #5 ] >,
     C-CONT.RELS <!!>,
     C-CONT.HCONS <!!>].

; is intended to help through "Ola, Kari, og Per kommer" (second comma)
; but that didn't work anyway. So back to basic: allow "Per, Kari.."
; and disallow "Per, fra skogen..."
; removed ,
;             SYNSEM.LOCAL.XCAT.HEAD.COORDINABLE bool
coordination-np-comma-np-phrase := coordinating-phrase & non-headed-phrase & rule &
  [  SYNSEM.LOCAL.CAT [ HEAD #32 & [COORDINABLE + ] ],
     SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [SORT #7],
     SYNSEM.LOCAL.BND-RESP #3,
     SYNSEM.LOCAL.CAT.VAL #4,
     SYNSEM.LOCAL.BINDING #12,
     SYNSEM.NON-LOCAL #5,
     RULE #6,
     ARGS < [ SYNSEM.LOCAL.CAT.HEAD #32,
              SYNSEM.LOCAL.CAT.VAL #4,
              SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & [SORT #7],
              SYNSEM.LOCAL.MUST-APP -,
              SYNSEM.NON-LOCAL #5,
              SYNSEM.LOCAL.DERIVED-HEAD #11,
              SYNSEM.LOCAL.BINDING #12,
              SYNSEM.LOCAL.BND-RESP #3,
              RULE #6], 
           [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
             SYNSEM.LOCAL.CAT.HEAD comma-coord,
             SYNSEM.LOCAL.XCAT.HEAD np-head,
             SYNSEM.LOCAL.XSORT #7,
             SYNSEM.LOCAL.CAT.VAL.COMPS <>,
             SYNSEM.LOCAL.CONT.HOOK.XARG #2,
             SYNSEM.LOCAL.DERIVED-HEAD #11,
             SYNSEM.LOCAL.BND-RESP #3,
             SYNSEM.NON-LOCAL #5 ] >,
     C-CONT.RELS <!!>,
     C-CONT.HCONS <!!>].

; for coord of pps, advps,...
coordination-adjct-phrase := head-adj-phrase & rule & coordinating-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD prep-or-adv & [KEYS.KEY #3 & prim-mod,
                                          MOD < [LOCAL.CAT.HEAD #1] >],
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #4,
     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.NON-LOCAL #5,
     ARGS < [ SYNSEM.LOCAL.CONT.HOOK.XARG #2,
              SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #4,
              SYNSEM.LOCAL.HAS-PUNCT -,
              SYNSEM.NON-LOCAL #5 ], 
           [ SYNSEM.LOCAL.CAT.HEAD coord,
             SYNSEM.LOCAL.XCAT.HEAD prep-or-adv & [KEYS.KEY #3,
                                                   MOD < [LOCAL.CAT.HEAD #1] >],
             SYNSEM.LOCAL.CAT.VAL.COMPS <>,
             SYNSEM.LOCAL.CONT.HOOK.XARG #2,
             SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #4,
             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.NON-LOCAL #5  ] >,
     C-CONT.RELS <!!>,
     C-CONT.HCONS <!!>].

#|
; for coord of selected prep's,...
coordination-adjct-phrase := head-adj-phrase & rule & coordinating-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD prep & [KEYS.KEY #3 & prim-mod,
                                   MOD < [LOCAL.CAT.HEAD #1] >],
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #4,
     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.NON-LOCAL #5,
     ARGS < [ SYNSEM.LOCAL.CONT.HOOK.XARG #2,
              SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #4,
              SYNSEM.LOCAL.HAS-PUNCT -,
              SYNSEM.NON-LOCAL #5 ], 
           [ SYNSEM.LOCAL.CAT.HEAD coord,
             SYNSEM.LOCAL.XCAT.HEAD prep & [KEYS.KEY #3,
                                            MOD < [LOCAL.CAT.HEAD #1] >],
             SYNSEM.LOCAL.CAT.VAL.COMPS <>,
             SYNSEM.LOCAL.CONT.HOOK.XARG #2,
             SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #4,
             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.NON-LOCAL #5  ] >,
     C-CONT.RELS <!!>,
     C-CONT.HCONS <!!>].
|#
; for coord of vps...
#|
coordination-v-phrase := head-adj-phrase & rule & coordinating-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all & [KEYS.KEY #3,
                                       MOD < [LOCAL.CAT.HEAD #1] >],
     SYNSEM.LOCAL.CONT.HOOK.XARG #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
     SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                            ICOMPS #7 ],
     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.NON-LOCAL #5,
     ARGS < [ SYNSEM.LOCAL.CONT.HOOK.XARG #2,
              SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
              SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
              SYNSEM.LOCAL.CAT.VAL.SUBJ < [] >,
              SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                                     ICOMPS #7 ],
              SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
              SYNSEM.NON-LOCAL #5,
              FRONT-TO-FILL #8 ], 
           [ SYNSEM.LOCAL.CAT.HEAD coord,
             SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
             SYNSEM.LOCAL.XCAT.HEAD verb-all & [KEYS.KEY #3,
                                                MOD < [LOCAL.CAT.HEAD #1] >],
             SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                                    ICOMPS #7 ],
             SYNSEM.LOCAL.CONT.HOOK.XARG #2,
             SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.NON-LOCAL #5,
             FRONT-TO-FILL #8   ] >,
     C-CONT.RELS <!!>,
     C-CONT.HCONS <!!>].
|#

; TODO: applies also to "Ola l√∏per og l√∏per" allowing distinct subjects - should be avoided. Has to do with 'antilist' vs 'null' as SUBJ-value...
; EAA: Added constraint that the HEAD|INV be identical for both daughters
; LH020711: "jeg har bil, og ig√•r fikk jeg hus". So that requirement shouldn't be, unless we want extra rules. Thus taken away:  & [INV #inv]
;SYNSEM.LOCAL.CAT.VAL [ SUBJ #subj & antilist,
; outcommented in ARGS 1: SYNSEM.LOCAL.CAT.VAL.SUBJ #subj & 1-list,
;so as to manage "Seinere brant den mange ganger, men de bygde den opp igjen." (NoW)
; TODO LOOKOUT: there was an outcomment for non-head-dtr '             SYNSEM.LOCAL.XCAT.HEAD verb-all,', meaning that the second clause would not be required to be verbal. Strange.
; Reason found: in 'Da l√¶rte han meg norsk, og jeg l√¶rte ham tysk.', the comma is head, and XCAT.HEAD is 'og'. So, outcommented the line goes, again.


coordination-finite-clause := basic-head-mod-phrase-simple & head-initial & phrasal & rule & coordinating-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all,
     SYNSEM.LOCAL.CONT.HOOK.XARG #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
     SYNSEM.LOCAL.CAT.VAL.SUBJ #subj,			; Re-added EAA010811
     SYNSEM.LOCAL.CAT.VAL.COMPS #6,
     SYNSEM.LOCAL.CAT.VAL.ICOMPS #7,
;     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.NON-LOCAL #5,
	 FRONT-TO-FILL -,												; Added in, EAA010811
     ARGS < [ SYNSEM.LOCAL.XCAT.HEAD verb-all,
	      SYNSEM.LOCAL.CAT.HEAD.WH-COMPLETE #compl,
	      SYNSEM.LOCAL.CONT.HOOK.XARG #2,
              SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
              SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX.SF #sf,
;              SYNSEM.LOCAL.CAT.VAL.SUBJ #subj & 1-list,
		  SYNSEM.LOCAL.CAT.VAL.SUBJ #subj & < anti-synsem >,		; Added in, EAA010811
	      SYNSEM.LOCAL.CAT.VAL.COMPS #6,
              SYNSEM.LOCAL.CAT.VAL.ICOMPS #7,
;              FRONT-TO-FILL #8,
			  FRONT-TO-FILL -,										; Added in, EAA010811
              SYNSEM.NON-LOCAL #5 ], 
           [ SYNSEM.LOCAL.CAT.HEAD coord,
             SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
             SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE finite,
	     SYNSEM.LOCAL.CONT.HOOK.INDEX.SF #sf,
;             SYNSEM.LOCAL.XCAT.HEAD verb-all,
             SYNSEM.LOCAL.XCAT.HEAD.COORDINABLE +,
             SYNSEM.LOCAL.XCAT.HEAD.WH-COMPLETE #compl,
			 SYNSEM.LOCAL.XCAT.VAL [ SUBJ antilist ],				; Added in, EAA020811
             SYNSEM.LOCAL.CAT.VAL [ SUBJ <>,
				    COMPS #6,
                                    ICOMPS #7 ],
             SYNSEM.LOCAL.XCAT.VAL [ SUBJ olist ,
				    COMPS #6,
                                    ICOMPS #7 ],
             SYNSEM.LOCAL.CONT.HOOK.INDEX #4 & [SORT verb-act-specification],
;             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.LOCAL.HEAD-SUBJ-APPLIED +,
;             FRONT-TO-FILL #8 & +,
			 FRONT-TO-FILL -,										; Added in, EAA010811
	     SYNSEM.NON-LOCAL #5  ] >,
     C-CONT.RELS <! !>,
     C-CONT.HCONS <!!>].

coordination-finite-1stsubjinv-clause := coordination-finite-clause &
  [ ARGS < [ SYNSEM.LOCAL.CAT.VAL.SUBJ ocons ], [] > ].

coordination-finite-1stsubjnoninv-clause := coordination-finite-clause &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ #subj,
    ARGS < [ SYNSEM.LOCAL.CAT.VAL.SUBJ #subj & 1-list ], [] > ].

; We need to distinguish between VP-coord and S-coord. In VP-coord, the subjects are identical, in S-coord they need not be. Either type may cooccur with inversion in first clause, and with comma after first clause.
; Specifics:
; to get "g√•r fra... og blir leder": combine verb and cop
; "idag sover jeg og jeg hviler" reguire that INV bool value not be necessarly identical, hence removed: 'INV #14' from 'HEAD verb-all & [INV #14]' and
; SYNSEM.LOCAL.XCAT [HEAD [INV #14] ],
; from second daughter ('XCAT' copies from lower node).
#|
coordination-v-phrase-sup := basic-head-mod-phrase-simple & head-initial & phrasal & rule & coordinating-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all,
     SYNSEM.LOCAL.CONT.HOOK.XARG #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
     SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                            ICOMPS #7 ],
     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.NON-LOCAL #5,
     ARGS < [ SYNSEM.LOCAL.XCAT.HEAD verb-all,
	      SYNSEM.LOCAL.CAT.VAL [ SUBJ cons],
	      SYNSEM.LOCAL.CONT.HOOK.XARG #2,
              SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
              SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
              SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                                     ICOMPS #7 ],
              SYNSEM.NON-LOCAL #5,
              FRONT-TO-FILL #8 ], 
           [ SYNSEM.LOCAL.CAT.HEAD coord,
             SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
             SYNSEM.LOCAL.XCAT.HEAD verb-all,
             SYNSEM.LOCAL.XCAT.HEAD.COORDINABLE +,
             SYNSEM.LOCAL.CAT.VAL [ SUBJ #subj & 1-list,
				    COMPS #6,
                                    ICOMPS #7 ],
             SYNSEM.LOCAL.XCAT.VAL [ SUBJ #subj,
				    COMPS #6,
                                    ICOMPS #7 ],
             SYNSEM.LOCAL.CONT.HOOK.XARG #22,
             SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.LOCAL.HEAD-SUBJ-APPLIED -,
             SYNSEM.NON-LOCAL #5,
             FRONT-TO-FILL #8   ] >,
     C-CONT.RELS.LIST.FIRST arg12-relation & [LBL #lbl,
					      PRED "coreferential_rel",
					      ARG1 #2 & [PNG #p],
					      ARG2 #22 & [PNG #p]],
     C-CONT.RELS.LIST.REST.FIRST indef-q-rel & [PRED "_udef_q_rel",
						ARG0 #22,
						RSTR #rstr],
     C-CONT.HCONS <! [HARG #rstr,
		      LARG #lbl] !>].
|#

coordination-v-phrase-sup := basic-head-mod-phrase-simple & head-initial & phrasal & rule & coordinating-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all,
     SYNSEM.LOCAL.CONT.HOOK.XARG #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
     SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                            ICOMPS #7 ],
     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.NON-LOCAL #5,
     ARGS < [ SYNSEM.LOCAL.CAT.HEAD verb-all,					; Changed from XCAT to CAT.
	      	  SYNSEM.LOCAL.CAT.VAL [ SUBJ cons,
									 COMPS #6,
									 ICOMPS #7 ],
	      	  SYNSEM.LOCAL.CONT.HOOK.XARG #2,
              SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
              SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
			  SYNSEM.LOCAL.CONT.HOOK.INDEX.SF #sf,
              SYNSEM.NON-LOCAL #5,
              FRONT-TO-FILL #8 ], 
           [ SYNSEM.LOCAL.CAT.HEAD coord,
             SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
             SYNSEM.LOCAL.XCAT.HEAD verb-all,
             SYNSEM.LOCAL.XCAT.HEAD.COORDINABLE +,
             SYNSEM.LOCAL.CAT.VAL [ SUBJ #subj & 1-list,
				    				COMPS #6,
                                    ICOMPS #7 ],
             SYNSEM.LOCAL.XCAT.VAL [ SUBJ #subj,
				    				COMPS #6,
                                    ICOMPS #7 ],
             SYNSEM.LOCAL.CONT.HOOK.XARG #22,
             SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
	     	 SYNSEM.LOCAL.CONT.HOOK.INDEX.SF #sf,
             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.LOCAL.HEAD-SUBJ-APPLIED -,
             SYNSEM.NON-LOCAL #5,
             FRONT-TO-FILL #8   ] >,
     C-CONT.RELS <! arg12-relation & [LBL #lbl,
				      PRED "coreferential_rel",
				      ARG1 #2 & [PNG #p],
				      ARG2 #22 & [PNG #p]],
		       indef-q-rel & [PRED "_udef_q_rel",
						ARG0 #22,
						RSTR #rstr] !>,
     C-CONT.HCONS <! [HARG #rstr,
		      LARG #lbl] !>].

;C-CONT.RELS <! arg12-relation & [PRED "coreferential_rel",
;				      ARG1 #2 & [PNG #p],
;				      ARG2 #22 & [PNG #p]],... !>,
     
; removed this - gave clash when first verb had been inverted:
; [ SYNSEM.LOCAL.CAT.VAL.SUBJ <[]>], 
coordination-v-phrase := coordination-v-phrase-sup &
  [  SYNSEM.LOCAL.CAT.VAL [ SUBJ < synsem > ],						; EAA020811 changed from cons
     ARGS < [SYNSEM.LOCAL.CAT.VAL [ SUBJ < synsem > ]],				; EAA020811 changed from cons
	    [ SYNSEM.LOCAL.XCAT.HEAD verb-all & [WH-COMPLETE -]] >,
     C-CONT.RELS <! [], [] !> ].

; Added this rule to accommodate inverted first verb, EAA.
coordination-v_inv-phrase := coordination-v-phrase-sup &
  [  SYNSEM.LOCAL.CAT.VAL.SUBJ cons,						
     ARGS < [SYNSEM.LOCAL.CAT.VAL.SUBJ cons,
			 SYNSEM.LOCAL.CAT.HEAD.INV + ],	
	    [ SYNSEM.LOCAL.XCAT.HEAD verb-all & [WH-COMPLETE -]] >,
     C-CONT.RELS <! [], [] !> ].

coordination-with-corefobj-v-phrase := coordination-v-phrase-sup &
  [  ARGS < [ SYNSEM.LOCAL.CAT.VAL.SUBJ <[]>,
	      SYNSEM.LOCAL.CONT.HOOK.VARG #3 & ref-ind], 
           [ SYNSEM.LOCAL.XCAT.HEAD verb-all & [WH-COMPLETE -],
	     SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD pers-pron,
						  CTXT pron-discbnd ],
	      SYNSEM.LOCAL.CONT.HOOK.VARG #4 & ref-ind] >,
     C-CONT.RELS <! arg12-relation & [PRED "coreferential_rel",
					  ARG1 #3 & [PNG #p],
					  ARG2 #4 & [PNG #p]], [] !> ].

coordination-relclause-phrase := coordination-v-phrase-sup &
  [  SYNSEM.LOCAL.CAT.HEAD [DECL +,
			    IMPERATIVE -],
     SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative,
     ARGS < [  SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
	       SYNSEM.LOCAL.CAT.HEAD verb-all & [WH-COMPLETE +],
	       SYNSEM.LOCAL.REL-CL-SOM-INIT +], 
           [ SYNSEM.LOCAL.XCAT.HEAD verb-all & [WH-COMPLETE +]] >,
     C-CONT.RELS <! [],[] !> ].

coordination-modal-dir-phrase := head-adj-phrase & rule & coordinating-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD #adv & adv-reg & [KEYS.KEY dir],
     SYNSEM.LOCAL.CONT.HOOK.XARG #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
     SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                            ICOMPS #7 ],
     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.NON-LOCAL #5,
     ARGS < [ SYNSEM.LOCAL.CAT.HEAD #adv & adv-reg & [KEYS.KEY dir],
              SYNSEM.LOCAL.CONT.HOOK.XARG #2,
              SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
              SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
              SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                                     ICOMPS #7 ],
              SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
              SYNSEM.NON-LOCAL #5,
              FRONT-TO-FILL #8 ], 
            head-wordcoord-nonequal-comp-phrase &
           [ SYNSEM.LOCAL.CAT.HEAD coord,
             SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
             SYNSEM.LOCAL.XCAT.HEAD verb-all,
             SYNSEM.LOCAL.CONT.HOOK.XARG #2,
             SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.NON-LOCAL #5,
             FRONT-TO-FILL #8   ] >,
     C-CONT.RELS <!!>,
     C-CONT.HCONS <!!>].


coordination-adjective-phrase := head-adj-phrase & rule & coordinating-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD adj-reg & [KEYS.KEY #3,
                                  MOD < [LOCAL.CAT.HEAD #1] >],
     SYNSEM.LOCAL.CONT.HOOK.XARG #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
     SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                            ICOMPS #7 ],
     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.NON-LOCAL #5,
     ARGS < [ SYNSEM.LOCAL.CONT.HOOK.XARG #2,
              SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
              SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
              SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                                     ICOMPS #7 ],
              SYNSEM.NON-LOCAL #5,
              FRONT-TO-FILL #8 ], 
           [ SYNSEM.LOCAL.CAT.HEAD coord,
             SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
             SYNSEM.LOCAL.XCAT.HEAD adj-reg & [KEYS.KEY #3,
                                                MOD < [LOCAL.CAT.HEAD #1] >],
             SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                                    ICOMPS #7 ],
             SYNSEM.LOCAL.CONT.HOOK.XARG #2,
             SYNSEM.LOCAL.CONT.HOOK.INDEX #4,
             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.NON-LOCAL #5,
             FRONT-TO-FILL #8   ] >,
     C-CONT.RELS <!!>,
     C-CONT.HCONS <!!>].

; not so clear what this should do - rule commented out
coordination-to-v-by-coord-phrase := head-adj-phrase & rule & coordinating-phrase &
  [  SYNSEM.LOCAL.CAT.HEAD verb-all,
     SYNSEM.LOCAL.CONT.HOOK.XARG #2,
     SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #4,
     SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
     SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                            ICOMPS #7 ],
     SYNSEM.LOCAL.COORD-RELEASED #10,
     SYNSEM.NON-LOCAL #5,
     ARGS < [ SYNSEM.LOCAL.CONT.HOOK.XARG #2,
              SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
              SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #4,
              SYNSEM.LOCAL.CAT.VAL.SUBJ antilist,
              SYNSEM.LOCAL.CAT.VAL [ COMPS #6,
                                     ICOMPS #7 ],
              SYNSEM.LOCAL.RIGHT-ADJ-SITE-OPEN +,
              SYNSEM.NON-LOCAL #5,
              FRONT-TO-FILL #8 ], 
           [ SYNSEM.LOCAL.CAT.HEAD coord,
             SYNSEM.LOCAL.CONT.HOOK.LTOP #13,
             SYNSEM.LOCAL.CONT.HOOK.XARG #2,
             SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT #4,
             SYNSEM.LOCAL.COORD-RELEASED #10,
             SYNSEM.NON-LOCAL #5,
             FRONT-TO-FILL #8   ] >,
     C-CONT.RELS <!!>,
     C-CONT.HCONS <!!>].

coordination-number-coord-phrase :=  rule & coordinating-phrase &
  [ SYNSEM [LOCAL.CAT.HEAD cardnum,
            LOCAL.CONT.HOOK.INDEX.SORT card-unit],
    ARGS < [SYNSEM [LOCAL.CAT.HEAD comm-noun,
                     LOCAL.CONT.HOOK.INDEX.SORT number-unit,
                     LOCAL.CAT.HEAD.KEYS.KEY measnoun]],
           head-numbercoord-comp-phrase >].





; SYNSEM types

arg1-subj-synsem := lex-synsem &
 [ LOCAL.CONT mrs,
   LOCAL [CAT.VAL.SUBJ <[LOCAL.CONT.HOOK.INDEX #1 & ref-ind]>],
   LKEYS.KEYREL.ARG1 #1 ].

eventarg1-subj-synsem := lex-synsem &
 [ LOCAL.CONT mrs,
   LOCAL.CAT.HEAD.INV -,
   LOCAL.CAT.VAL.SUBJ < [LOCAL.CAT.HEAD.EXPLETIVE -] >,
   LOCAL [CAT.VAL.SUBJ <[LOCAL.CONT.HOOK.INDEX super-event,
                         LOCAL.CONT.HOOK.LTOP #1]>],
   LKEYS.KEYREL.ARG1 #1 ].

intrans-synsem := lex-synsem &
 [ LOCAL.CONT mrs,
   LOCAL.CAT intrans-cat,
   LOCAL.CAT.VAL.SUBJ < [LOCAL.CAT.HEAD.EXPLETIVE -] >,
   LOCAL.DELIMTELACTV -,
   LOCAL.HAS-A-V-COMPLEMENT - ].

; removed ,
;   NON-LOCAL.SLASH <! !>
; in order to enable "jeg vet hvem som kommer"
intrans-arg1-synsem-super := intrans-synsem & arg1-subj-synsem &
 [ LOCAL.CAT [ VAL.ICOMPS <>,
	       QVAL intrans-qval ]].

intrans-eventarg1-synsem := intrans-synsem & eventarg1-subj-synsem &
 [ LOCAL.CAT [ VAL.ICOMPS <>]].

;intrans-eventarg1-obl-synsem := intrans-eventarg1-obl-synsem-sup & eventarg1-subj-synsem.


arg2-comps-synsem := lex-synsem &
  [ LOCAL [ CAT.VAL.COMPS.FIRST [LOCAL.CONT.HOOK.INDEX #1 & semarg ]],
    LOCAL [ CAT.QVAL.DOBJECT [LOCAL.CONT.HOOK.INDEX #1 & semarg ]],
    LKEYS.KEYREL.ARG2 #1 ].


arg2-qvalcomps-synsem := lex-synsem &
  [ LOCAL [ CAT.QVAL.DOBJECT [LOCAL.CONT.HOOK.INDEX #1 & semarg ]],
    LKEYS.KEYREL.ARG2 #1 ].
  
arg1-comps-synsem := lex-synsem &
  [ LOCAL [ CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #1 & semarg ] >],
    LKEYS.KEYREL.ARG1 #1 ].

; only for NP NP - for clauses, see ditrans-subord
arg23-comps-synsem := lex-synsem &
  [ LOCAL [ CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #1 & ref-ind ],
                            [LOCAL.CONT.HOOK.INDEX #2 & ref-ind ]>],
    LKEYS.KEYREL.ARG3 #1,
    LKEYS.KEYREL.ARG2 #2 ]. 

trans-synsem := lex-synsem &
  [ LOCAL.CAT trans-1ncomps-empty-icomps-cat & [ QVAL trans-qval ]].
 

ditrans-synsem := lex-synsem &
  [ LOCAL.CAT ditrans-cat & [ VAL.COMPS <  [LOCAL.CAT.HEAD np-head],[LOCAL.CAT.HEAD np-head] >,
                              VAL.ICOMPS <> ]].

arg1-predicative-synsem := lex-synsem &
  [ LOCAL.CAT.QVAL.PREDIC.LOCAL.CONT.HOOK.LTOP #1,
    LKEYS.KEYREL.ARG1 #1 ].

arg2-predicative-synsem := arg1-subj-synsem &
  [ LOCAL.CAT.QVAL.PREDIC.LOCAL.CONT.HOOK.LTOP #1,
    LKEYS.KEYREL.ARG2 #1 ].

argx-predicative-synsem := lex-synsem &
  [ LOCAL.CAT.QVAL.PREDIC.LOCAL.CONT.HOOK.LTOP #2,
    LKEYS.KEYREL.ARGX #2 ].

argcsx-predicative-synsem := lex-synsem &
  [ LOCAL.CAT.QVAL.PREDIC.LOCAL.CONT.HOOK.LTOP #2,
    LKEYS.KEYREL.LBL #1,
    LOCAL.CONT.RELS <! [], arg12-relation & [ PRED "cause-rel",
					      ARG1 #1,
					      ARG2 #2 ] !> ].


;;; SYNSEMs DIRECTLY SUPPORTING VERB-LEXEMEs

intrans-arg1-synsem := intrans-arg1-synsem-super &
  [ LOCAL.CONT.HOOK hook ].

; synsems for verbs with subjects undergoing path-movement
intrans-arg1dir-synsem := intrans-arg1-synsem-super &
    [ LOCAL.CONT.HOOK dir-hook & [DIRARG #1],
      LKEYS.KEYREL.ARG1 #1,
      LOCAL.CAT.VAL.ICOMPS <>].

; for "drive" in "driver og g√•r": it enforces atelicity for the whole constr.
intrans-arg1-atelic-synsem := intrans-arg1-synsem-super &
    [ LOCAL.CONT.HOOK.INDEX.SIT-TYPE atelic,
      LOCAL.CAT.VAL.ICOMPS <>].

#|
intrans-locobl-synsem := arg1-subj-synsem & lbl-ltop-lex-item &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-or-adv & [ SELECTED -,
                                                          KEYS.KEY #1],
                           LOCAL.CONT.HOOK.INDEX[SORT non-fix-point,
                                                 ROLE xdim-to-xdim-spatial]]>,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #2 & handle,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #2 ]].
|#

;almost same def as intrans-obl-synsem-sup
;    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +]]>,
; because otherwise all locative preps would need a special 'seleced' variant
intrans-locobl-synsem :=  arg1-subj-synsem &
  [ LOCAL.CONT.HOOK hook & [ VARG #2 ],
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.COMPS onull,
    LOCAL.CAT.VAL.ICOMPS < #4, ...>,
    LOCAL.CAT.QVAL with-obl-pp-qval & [ OBL1 #4 & [ LOCAL.CAT [ HEAD prep-or-adv,
								VAL.COMPS null ] ] ],
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY #1 & index-sit ]]>,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #2 & handle,
;    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +]]>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #2 ] ].


intrans-eventarg1-decl-synsem := intrans-eventarg1-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD fin-comp & [ DECL + ]] > ].

intrans-eventarg1-interr-synsem := intrans-eventarg1-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL - ] > ].

intrans-eventarg1-absinf-synsem := intrans-eventarg1-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD infin-comp & [TRANSPAR -] ] > ].
#|
; defined elsewhere
intrans-eventarg1-obl-n-synsem := intrans-eventarg1-obl-synsem & intrans-eventarg1-obl-n-synsem.
|#

intrans-eventarg1-decl-obl-synsem := intrans-eventarg1-obl-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD fin-comp & [ DECL + ] ] > ].
intrans-eventarg1-interr-obl-synsem := intrans-eventarg1-obl-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL - ] > ].
intrans-eventarg1-absinf-obl-synsem := intrans-eventarg1-obl-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD infin-comp & [ TRANSPAR -,
							 DECL + ]] > ].


intrans-eventarg1-decl-obl-n-synsem := intrans-eventarg1-obl-n-synsem & intrans-eventarg1-decl-obl-synsem.
intrans-eventarg1-interr-obl-n-synsem := intrans-eventarg1-obl-n-synsem & intrans-eventarg1-interr-obl-synsem.
intrans-eventarg1-absinf-obl-n-synsem := intrans-eventarg1-obl-n-synsem & intrans-eventarg1-absinf-obl-synsem.
 

intrans-eventarg1-eventobl-synsem := intrans-eventarg1-obl-synsem &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CONT.HOOK.INDEX.E.TENSE finite],
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]> ].

#|
intrans-eventarg1-eventobl-decl-synsem := intrans-eventarg1-eventobl-synsem &
[ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL + ]].
intrans-eventarg1-eventobl-interr-synsem := intrans-eventarg1-eventobl-synsem &
[ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL - ]].
|#

intrans-eventarg1decl-eventobldecl-synsem := intrans-eventarg1-decl-obl-synsem & intrans-eventarg1-eventobl-decl-synsem.
intrans-eventarg1decl-eventoblinterr-synsem := intrans-eventarg1-decl-obl-synsem & intrans-eventarg1-eventobl-interr-synsem.
intrans-eventarg1interr-eventobldecl-synsem := intrans-eventarg1-interr-obl-synsem & intrans-eventarg1-eventobl-decl-synsem.
intrans-eventarg1interr-eventoblinterr-synsem := intrans-eventarg1-interr-obl-synsem & intrans-eventarg1-eventobl-interr-synsem.




; "fungere godt", "dufte godt"
intrans-obladv-synsem := arg1-subj-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CONT.HOOK.INDEX #2,
    LOCAL.CAT.VAL.ICOMPS <>,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD adv & [ SELECTED +,
                                                 KEYS.KEY #1],
			  LOCAL.CONT.HOOK.XARG #2 ]>].

; "se alvorlig p√•"
intrans-adv-obl-synsem := arg1-subj-synsem &
  [ LOCAL.CAT.HEAD.KEYS.KEY advoblvb,
    LOCAL.CONT.HOOK hook & [INDEX #1],
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD adv & [KEYS.KEY adv-m],
                            LOCAL.CONT.HOOK.XARG #1 ]>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED + ]]>,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -]].

#|
zero-obl-synsem-sup := lex-synsem &
  [ LOCAL.CONT.HOOK hook & [ LTOP #3,
			     VARG #2 ],
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CONT.HOOK.LTOP #3,
			   LOCAL.CAT.HEAD [KEYS.KEY #1 ]]>,
    LKEYS.KEYREL.ARGOBLQ #2 ].
|#


zero-obl-synsem-sup := lex-synsem &
  [ LOCAL.CONT.HOOK hook & [ VARG #2 ],
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY #1 ]]>,
    LKEYS.KEYREL.ARGOBLQ #2,
    LOCAL.CAT.VAL.ICOMPS < #7 >,
    LOCAL.CAT.QVAL.OBL1 #7 ].

;LH100513: cut the identity betweeb ARGOBL's handle and top VARG, to get tough-mov for 'Jon er hyggelig √• snakke med'; not sure if that affects any for introbl
intrans-obl-synsem-sup := lex-synsem &
  [ LOCAL.CONT.HOOK hook & [ VARG #3],
    LOCAL.KEY-SPEC #1,
;    LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT.VAL.ICOMPS <#obl & [LOCAL.CAT.HEAD [KEYS.KEY #1,
						  SELECTED +] ]>,
    LOCAL.CAT.QVAL.OBL1 #obl & [LOCAL.CONT.HOOK.LTOP #2 & handle,
				LOCAL.CONT.HOOK.VARG #3],
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #2 ] ].

intrans-eventarg1-obl-synsem-sup := eventarg1-subj-synsem & intrans-obl-synsem-sup &
[LOCAL.CAT.VAL.COMPS <>].

; "stole p√• Ola", "snakke om meg"
#|
intrans-obl-synsem := intrans-obl-synsem-sup &
  [ LOCAL.CONT.HOOK hook & [ LTOP #3 ],
    LOCAL.CAT.VAL.COMPS < >,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CONT.HOOK.LTOP #3]>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY fct-spec ]]> ].
|#

intrans-eventarg1-obl-synsem := intrans-eventarg1-obl-synsem-sup &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    LOCAL.CAT.VAL.COMPS < >,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY fct-spec ]]> ].

; BINDING nontamed & [REFL-I -],

#|
intrans-obl-n-synsem := intrans-obl-synsem-sup &
  [ LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT [QVAL.DOBJECT.LOCAL [CONT.HOOK.INDEX #1 & ref-ind],
                                   HEAD [SELECTED +,
                                         KEYS.KEY fct-spec ]],
    LOCAL.CAT.VAL.COMPS <>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #1 ]].
|#

intrans-obl-n-synsem := arg1-subj-synsem & intrans-obl-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.HEAD.KEYS.KEY fct-spec,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD np-head,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CONT.HOOK.INDEX ref-ind,
						      BINDING nontamed]].

; at.. beror p√• Ola 
intrans-eventarg1-obl-n-synsem := intrans-eventarg1-obl-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CONT.HOOK.INDEX ref-ind,
						      BINDING nontamed & [REFL-I -]]].

#|
; at.. beror p√• Ola 
intrans-eventarg1-obl-n-synsem := intrans-eventarg1-obl-synsem-sup &
  [ LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT [QVAL.DOBJECT.LOCAL [CONT.HOOK.INDEX #1 & ref-ind],
                                   HEAD [SELECTED +,
                                         KEYS.KEY fct-spec ]],
    LOCAL.CAT.VAL.COMPS <>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #1 ]].
|#
 
; "stole p√• at...", "snakke om at..."
#|
intrans-obl-decl-synsem := intrans-obl-synsem-sup &
  [ LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CAT.HEAD.DECL +,
                                                      CONT.HOOK.INDEX.E.TENSE finite,
						       CONT.HOOK.LTOP #1 & handle],
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LOCAL.CAT.VAL.COMPS <>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #1 ] ].
|#

intrans-obl-decl-synsem := arg1-subj-synsem & intrans-obl-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CAT.HEAD fin-comp & [DECL +],
                                                      CONT.HOOK.INDEX.E.TENSE finite],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LOCAL.CAT.VAL.COMPS <>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #1 ] ].

; "bero p√• at...", "avhenge av at..."
intrans-eventarg1-eventobl-decl-synsem := intrans-eventarg1-obl-synsem-sup &
  [ LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CAT.HEAD fin-comp & [DECL +],
                                                      CONT.HOOK.INDEX.E.TENSE finite],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LOCAL.CAT.VAL.COMPS <>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #1 ] ].

; "snakke om hvorvidt/hvem..."
intrans-obl-interr-synsem := arg1-subj-synsem & intrans-obl-synsem-sup &
  [ LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CAT.HEAD verb-or-comp & [ DECL - ]],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
   LOCAL.CAT.VAL.COMPS <>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #1 ]  ].

; "at.. beror p√• hvorvidt/hvem..."
intrans-eventarg1-eventobl-interr-synsem := intrans-eventarg1-obl-synsem-sup &
  [ LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CAT.HEAD verb-or-comp & [ DECL - ]],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
;    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED + ]]>,
    LOCAL.CAT.VAL.COMPS <>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #1 ]  ].

intrans-obl-arbinf-synsem := arg1-subj-synsem & intrans-obl-synsem-sup &
  [ LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CAT.HEAD infin-comp & [ TRANSPAR -,
									      DECL +,
									      KEYS.KEY infinit-comp ],
                                                      CONT.HOOK.INDEX.E.TENSE infin],
    LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LOCAL.CAT.VAL.COMPS <>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #1 ] ].

intrans-eventarg1-eventobl-arbinf-synsem := intrans-eventarg1-obl-synsem-sup &
  [ LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CAT.HEAD infin-comp & [ TRANSPAR -,
									      DECL +,
									      KEYS.KEY infinit-comp ],
                                                      CONT.HOOK.INDEX.E.TENSE infin],
    LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LOCAL.CAT.VAL.COMPS <>,
    LKEYS.KEYREL arg1obl-rel & [ ARGOBLQ #1 ] ].

;LH 300411: changed to TRANSPAR bool because "jeg ber om √• komme" otherwise parsed not. have forgotten what TRANSPAR really is for...  NOW remember - + when equi
intrans-obl-equinf-synsem := arg1-subj-synsem & intrans-obl-synsem-sup &
  [ LOCAL.CAT intrans-with-1icomps-pp-cat,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CAT.HEAD infin-comp & [ TRANSPAR +,
									      DECL +,
									      KEYS.KEY infinit-comp ],
                                                      CONT.HOOK.INDEX.E.TENSE infin],
    LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS < [LOCAL.CAT.HEAD prep-comp & [SELECTED +,
							KEYS.KEY #3 & rais],
			    LOCAL.CONT.HOOK.XARG #4 ] >,
    LOCAL.CAT.VAL.COMPS <>,
    LOCAL.KEY-SPEC #3,
    LKEYS.KEYREL arg1obl-rel & [ ARG1 #4,
				ARGOBLQ #1 ] ].

intrans-obl-adv-equinf-synsem := arg1-subj-synsem & intrans-obl-synsem-sup &
  [ LOCAL.CONT.HOOK.LTOP #5,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CAT.HEAD infin-comp & [ TRANSPAR +,
									      DECL +,
									      KEYS.KEY infinit-comp ],
                                                      CONT.HOOK.INDEX.E.TENSE infin],
    LOCAL.CAT.VAL.COMPS < lex-synsem &
                           [LOCAL.CONT.HOOK.LTOP #5,
			    LOCAL.CAT.HEAD adv-reg & [KEYS.KEY #6 & pcl,
                                                       SELECTED +] ]>,
    LOCAL.CAT.VAL.ICOMPS < [LOCAL.CAT.HEAD prep-comp & [SELECTED +,
							KEYS.KEY #3 & rais],
			    LOCAL.CONT.HOOK.LTOP #1 & handle,
			    LOCAL.CONT.HOOK.XARG #4 ] >,
    LOCAL.KEY-SPEC #3,
    LOCAL.ALT-SPEC #6,
    LKEYS.KEYREL arg1obl-rel & [ ARG1 #4,
				 ARGOBLQ #1 ] ].



;;; DPF 020411

intrans-atel-obl-synsem := arg1-subj-synsem & intrans-obl-synsem-sup &
  [ LOCAL.CONT.HOOK.INDEX.SIT-TYPE atelic,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY atelic-operation ]]> ].



#|
intrans-atel-obl-synsem := intrans-obl-synsem-sup &
  [ LOCAL.CONT.HOOK.INDEX.SIT-TYPE atelic,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY atelic-operation ]]> ].
|#


;;; DPF 020411


intrans-obl-refl-synsem := arg1-subj-synsem & intrans-obl-synsem-sup &
  [ LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #xarg,
    LOCAL.CONT.HOOK.INDEX.SIT-TYPE semelfactive,
    LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT.VAL.ICOMPS < [LOCAL [CAT.QVAL.DOBJECT.LOCAL #loc & [CONT.HOOK.INDEX #index,
								  BINDING[ BOUND +,
									   REFL-I +,
									   REFL-II -,
									   LEX-TAME + ]]]]>,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.HEAD.KEYS.KEY atelic-operation,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #ltop,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL #loc,
    LKEYS.KEYREL.ARGOBLQ #ltop,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.RELS <! [], [], [ARG1 #index,
									   ARG2 #xarg] !>].



; "lee p√• seg"
#|
intrans-obl-refl-synsem := intrans-obl-synsem-sup &
  [ LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #xarg,
    LOCAL.CONT.HOOK.INDEX.SIT-TYPE semelfactive,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.HEAD.KEYS.KEY atelic-operation,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #index,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING[ BOUND +,
                                                              REFL-I +,
                                                              REFL-II -,
                                                              LEX-TAME + ],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.RELS <! [], [], [ARG1 #index,
									   ARG2 #xarg] !>].
|#


intrans-2obl-synsem-sup := arg1-subj-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT intrans-with-2icomps-pp-cat,
    LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY index-sita]],
                          [LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY index-sita]]>].
;,
;    NON-LOCAL.SLASH <! !>].

; "snakke med Ola om meg"
intrans-2obl-synsem := intrans-2obl-synsem-sup &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING nontamed & [REFL-I -],
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY fct-spec ]],
                          [LOCAL.CAT.HEAD [KEYS.KEY fct-spec ]]> ].


; for "han later/kommer til √• sove"
; the lexical entries will identify what follows them, down to KEYS.KEY value
intrans-rais-from-pp-arg1-synsem := zero-obl-synsem-sup & 
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.CONT.HOOK.VARG #42,
    LOCAL.KEY-SPEC #4,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   ICOMPS < #obl1 & [ LOCAL.CONT.HOOK.LTOP #42,
				      LOCAL.CONT.HOOK.XARG #5,
				      LOCAL.CAT.HEAD prep-comp & [KEYS.KEY #4 & rais],
				      LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD infin-comp] >,
                   COMPS <> ],
    LOCAL.CAT icomps-cat,
    LOCAL.CAT.QVAL.OBL1 #obl1,
    LKEYS.KEYREL.ARGOBLQ #42].

; for "han ser ut til √• sove"
intrans-adv-rais-from-pp-arg1-synsem := zero-obl-synsem-sup & lex-item-1rel &
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.KEY-SPEC #4,
    LOCAL.ALT-SPEC #6,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5,
			   LOCAL.CAT.HEAD.EXPLETIVE #expl]>, 
                   ICOMPS < [ LOCAL.CONT.HOOK.LTOP #42,
			      LOCAL.CONT.HOOK.XARG #5,
			      LOCAL.CAT.HEAD prep-or-adj-or-adv & [KEYS.KEY #4 ],
			      LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl] >,
                   COMPS <lex-synsem &
                           [ LOCAL.CONT.HOOK.LTOP #3,
			     LOCAL.CAT.HEAD adv-reg & [KEYS.KEY #6 & pcl,
                                                       SELECTED +] ]> ],
    LOCAL.CAT.QVAL.OBL1 [ LOCAL.CONT.HOOK.LTOP #42,
			  LOCAL.CONT.HOOK.XARG #5,
			  LOCAL.CAT.HEAD prep-or-adj-or-adv & [KEYS.KEY #4 ],
			  LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl],
    LKEYS.KEYREL.ARGX #3,
    LKEYS.KEYREL.ARGOBLQ #42].


; for "det later til at han sover"
; the lexical entries will identify what follows them, down to KEYS.KEY value
intrans-epon-with-pp-arg1-synsem := zero-obl-synsem-sup & 
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.KEY-SPEC #4,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   ICOMPS < [ LOCAL.CONT.HOOK.XARG #5,
			      LOCAL.CONT.HOOK.LTOP #lbl,
			      LOCAL.CAT.HEAD prep-or-adj-or-adv & [KEYS.KEY #4 ]] >,
                   COMPS <> ],
    LKEYS.KEYREL.ARGOBLQ #lbl ].

; for "det ser ut til at han sover"
intrans-adv-epon-with-pp-arg1-synsem := zero-obl-synsem-sup & 
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.KEY-SPEC #4,
    LOCAL.ALT-SPEC #6,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   ICOMPS < [ LOCAL.CONT.HOOK.XARG #5,
			      LOCAL.CONT.HOOK.LTOP #lbl,
			      LOCAL.CAT.HEAD prep-or-adj-or-adv & [KEYS.KEY #4 ]] >,
                   COMPS <lex-synsem &
                           [ LOCAL.CAT.HEAD adv-reg & [KEYS.KEY #6 & pcl,
                                                       SELECTED +] ]> ],
    LKEYS.KEYREL.ARGOBLQ #lbl ].


; for "han virker frisk", "han later/kommer til √• sove"
; the lexical entries will identify what follows them, down to KEYS.KEY value

intrans-secpred-rais-from-nonverbal-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.KEY-SPEC #4,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CAT.HEAD [KEYS.KEY #4 ],
                             LOCAL.CONT.HOOK.LTOP #7] >,
                   ICOMPS <> ],
    LKEYS.KEYREL.ARG1 #7].

; for "han synes en venn"
intrans-secpred-rais-from-n-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #1] >,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #5,
                            LOCAL.CAT.HEAD np-head] >,
    LOCAL.CAT.VAL.ICOMPS <>,  
    LOCAL.CONT.RELS <! [ARG1 #3], [ LBL #3,
				    PRED "_instantiate_c_rel",
				    ARG1 #1,
				    ARG2 #5 ] !> ].




epon-intrans-secpred-rais-from-nonverbal-arg1-synsem := arg1-predicative-synsem & presentational-synsem-2 &
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.KEY-SPEC #4,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CONT.HOOK.LTOP #2,
			     LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CAT.HEAD [KEYS.KEY #4 & absadj0-epon ]] >,
                   ICOMPS <> ],
    LOCAL.CONT.RELS <! [ARG1 #2], [] !>].

presentational-synsem-3 := lex-synsem &
  [ LOCAL.CAT lex-cat & [QVAL.SUBJECT [ LOCAL [ CAT.HEAD expl-pron,
                                                CONT [ HOOK.INDEX #1 & ref-ind ] ] ]],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.CONT.HOOK.XARG #1,
    LOCAL.CONT.HOOK.LTOP #3,
    LOCAL.CONT.RELS <! [LBL #2], [LBL #3,
				  PRED "intro-sit-rel",
				  ARG1 #1,
				  ARG2 #2], [] !>,
    LOCAL.CONT.HCONS <! !> ].


; TODO - LH300712 not yet working
epon-predprtcl-intrans-secpred-rais-from-nonverbal-arg1-synsem := lex-synsem &
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CONT.HOOK.LTOP #3,
    LOCAL.CAT.HEAD verb-all,
    LOCAL.KEY-SPEC #4,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CAT.HEAD expl-pron,
			   LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CAT.HEAD.KEYS.KEY #4],
			   []>,
                   ICOMPS <> ],
    LOCAL.CONT.RELS <! [LBL #2], [LBL #3,
				   PRED "intro-sit-rel",
				   ARG1 #5,
				   ARG2 #2], [] !>,
    LOCAL.CONT.HCONS <! !> ].


;    LOCAL.CONT.RELS <! [ARG1 #6], [], [LBL #6,
;				       ARG1 #8] !>].


#|
presentational-synsem-3 := lex-synsem &
  [ LOCAL.CAT lex-cat & [QVAL.SUBJECT [ LOCAL [ CAT.HEAD expl-pron,
                                                CONT [ HOOK.INDEX #1 & ref-ind ] ] ]],
    LOCAL.CONT.HOOK.XARG #1,
    LOCAL.CONT.HOOK.LTOP #3,
    LOCAL.CONT.RELS <! [LBL #2], [LBL #3,
				  PRED "intro-sit-rel",
				  ARG1 #1,
				  ARG2 #2], [] !>,
    LOCAL.CONT.HCONS <! !> ].


epon-predprtcl-intrans-secpred-rais-from-nonverbal-arg1-synsem := presentational-synsem-3 &
  [ LOCAL.CONT.HOOK hook & [ XARG #5 ],
    LOCAL.CAT.HEAD verb-all,
    LOCAL.KEY-SPEC #4,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CAT.HEAD.KEYS.KEY #4,
			     LOCAL.CONT.HOOK.LTOP #6],
;			     LOCAL.CONT.HOOK.INDEX #3],
			   [LOCAL.CONT.HOOK.INDEX #8]>,
                   ICOMPS <> ],
    LOCAL.CONT.RELS <! [ARG1 #6], [], [LBL #6,
				       ARG1 #8] !>].
|#

;     LOCAL.CONT.RELS <! [ARG1 #2 ], [], [LBL #2,
;					 ARG1 #1] !>].

; & argx-predicative-synsem
; for "han stiller som reserve"
intrans-secpred-som-arg1-x-synsem := arg1-subj-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb-all,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CONT.HOOK.LTOP #ltop,
			     LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CAT.HEAD [KEYS.KEY #1]] >],
    LKEYS.KEYREL.ARGX #ltop ].

intrans-eventarg1-secpred-som-arg1-x-synsem := eventarg1-subj-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb-all,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CAT.HEAD [KEYS.KEY #1]] >]].


;  "han ser syk ut". 
; dir inst of adv-selct
intrans-secpred-prtcl1-rais-from-nonverbal-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CONT.HOOK.LTOP #ltop,
    LOCAL.CAT.HEAD verb,
    LOCAL.KEY-SPEC #6,
    LOCAL.CONT.HOOK.INDEX #2,
    LOCAL.CAT intrans-ncomps-doublesecpred1-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #5],
                           [ LOCAL.CONT.HOOK.LTOP #ltop,
			     LOCAL.CONT.HOOK.XARG #2,
                             LOCAL.CAT.HEAD adv-reg,
                             LOCAL.CAT.HEAD [KEYS.KEY #6 & pcl ]] >]].

; han ser ut som en venn
intrans-secpred-prtcl1a-rais-from-nonverbal-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.KEY-SPEC #6,
    LOCAL.CONT.HOOK.INDEX #5,
    LOCAL.CAT intrans-ncomps-doublesecpred1-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #2]>, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CAT.HEAD adv-reg],
                           [ LOCAL.CONT.HOOK.XARG #2,
                             LOCAL.CAT.HEAD [KEYS.KEY #6 & som-pred-n ],
                             LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD nom] >]].


; ; "se ut til √• komme"; 
; "han ser ut til √• komme", "det ser ut til √• komme en gutt"
; now KEYS.KEY pcl rather than adv-selct
intrans-secpred-prtcl2-rais-from-nonverbal-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.INDEX #2,
    LOCAL.CAT intrans-ncomps-doublesecpred2-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #2,
                             LOCAL.CAT.HEAD adv-reg,
                             LOCAL.CAT.HEAD [KEYS.KEY pcl ]],
                           [ LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CAT.HEAD prep-comp,
                             LOCAL.CAT.HEAD [KEYS.KEY rais ] ] >]].

; ,
;                             LOCAL.CAT.HEAD [KEYS.KEY predcomp-om ]
intrans-secpred-prtcl3-rais-from-nonverbal-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK.LTOP #1,
    LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.INDEX #2,
    LOCAL.CAT intrans-ncomps-doublesecpred2-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CONT.HOOK.LTOP #1,
			     LOCAL.CONT.HOOK.XARG #2,
                             LOCAL.CAT.HEAD adv-reg,
                             LOCAL.CAT.HEAD [KEYS.KEY pcl ]],
                           [ LOCAL.CONT.HOOK.LTOP #3,
			     LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CAT.HEAD som-or-for ] >],
    LKEYS.KEYREL.ARG1 #3 ].


; for "kjelen koker tom"
intrans-secpred-argx-synsem := argx-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [SUBJ < #subj & [LOCAL.CONT.HOOK.INDEX #5 & [SORT referential-thing]]>, 
                   COMPS < #pred & [ LOCAL.CONT.HOOK.XARG #5,
			     LOCAL.CAT.HEAD prep-or-adj-or-adv] >,
                   ICOMPS <>],
    LOCAL.CAT.QVAL.SUBJECT #subj,
    LOCAL.CAT.QVAL.PREDIC #pred ].

; for "kjelen koker tom"
intrans-secpred-argcsx-synsem := argcsx-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #5,
			     LOCAL.CAT.HEAD prep-or-adj-or-adv] >,
                   ICOMPS <>]].

; for "skinken henger m√∏r"
intrans-secpred-arg1-csx-synsem := argcsx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #5,
			     LOCAL.CAT.HEAD prep-or-adj-or-adv] >,
                   ICOMPS <>]].

intrans-secpred-adj-argcsx-synsem := intrans-secpred-argcsx-synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD adj-reg] > ].
intrans-secpred-pp-argcsx-synsem := intrans-secpred-argcsx-synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD prep] > ].

; doubtful whether this is the right one: we might want the subject
; to have a role, as in "varme opp" ('he is warming up before the race');
; here we only get the counterpart of "vannet koker opp";
; but the semantics of the ca. 250 cases is quite heterogeneous. So
; the type mainly serves to identify a group of cases
intrans-telicity-particle-arg1-synsem := argx-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5]>, 
                   COMPS < lex-synsem &
                           [ LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CAT.HEAD adv-reg & [KEYS.KEY #1 & pcl,
                                                       SELECTED +] ] >, 
                   ICOMPS <>],
    LKEYS.KEYREL.ARG1 #5,
    NON-LOCAL.SLASH <! !>].

intrans-telicparticle-arg1-synsem := intrans-telicity-particle-arg1-synsem & 
  [ LOCAL.CONT.HOOK.INDEX.SIT-TYPE telic,
    LOCAL.CAT.VAL [COMPS < [ LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion ] >]].

; for "drive/holde" in "driver/holder p√• og g√•r": it enforces atelicity for the whole constr.
intrans-atelicparticle-arg1-synsem := intrans-telicity-particle-arg1-synsem & 
  [ LOCAL.CONT.HOOK.INDEX.SIT-TYPE activity,
    LOCAL.CAT.VAL [COMPS < [ LOCAL.CONT.HOOK.INDEX.SORT non-fix-point ] >]].

; for "han synes komme"
intrans-secpred-rais-from-verbal-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & semarg]>, 
                   COMPS < [ LOCAL.CAT.HEAD verb-all & [IMPERATIVE -],
                             LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #5] >,    
                            LOCAL.CONT.HOOK.INDEX.E.TENSE infin ]>]].


; "han synes √• komme"
intrans-secpred-rais-from-infinmarked-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & semarg,
			   LOCAL.CAT.HEAD.EXPLETIVE #expl]>, 
                   COMPS < [ LOCAL.CAT.HEAD infin-comp & [TRANSPAR +,
							  KEYS.KEY infinit-comp-eq],
                             LOCAL.CONT.HOOK.XARG #5,
			     LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
                             LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #5] > ]>]].

;han viser seg √• komme
trans-secpred-rais-refl-tosubj-from-infinmarked-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5,
                           LOCAL.AGR.PNG #2 ]>, 
                   COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #5 ] >,
                            LOCAL.CONT.HOOK.VARG #5,
                             LOCAL.AGR.PNG #2  ],
                           [ LOCAL.CAT.HEAD infin-comp & [TRANSPAR +],
                             LOCAL.CONT.HOOK.LTOP #7,
                             LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CAT.VAL.SUBJ < synsem & [LOCAL.CONT.HOOK.INDEX #5] > ]>],
    LKEYS.KEYREL.ARG1 #7].

la-seg-se-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5,
                           LOCAL.AGR.PNG #2 ]>, 
                   COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #5 ] >,
                            LOCAL.CONT.HOOK.VARG #5,
                             LOCAL.AGR.PNG #2  ],
                           [ LOCAL.CAT.HEAD verb-all,
                             LOCAL.CONT.HOOK.LTOP #7,
 ;                            LKEYS.KEYREL.ARG1 #8,
                             LKEYS.KEYREL.ARG2 #5 ] >],
    LKEYS.KEYREL.ARG1 #7].

#|
,
    LOCAL.CONT.RELS <! indef-q-rel & [ PRED "_udef_q_rel",
				 ARG0 #8,
				 RSTR #15 ], pron_rel & [ PRED "_understood-agent_rel",
							 LBL #16,
							 ARG0 #8 ] !>,
    LOCAL.CONT.HCONS <! [ HARG #15,
			     LARG #16] !>].
|#


la-sangen-synge-synsem := arg2-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL [SUBJ < [ ]>, 
                   COMPS < [ LOCAL.CONT.HOOK.INDEX #9 ],
                           [ LOCAL.CAT.HEAD verb-all,
                             LOCAL.CONT.HOOK.LTOP #7,
 ;                            LKEYS.KEYREL.ARG1 #8,
                             LKEYS.KEYREL.ARG2 #9 ] >],
    LKEYS.KEYREL.ARG2 #7].

trans-secpred-refl-argx-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5,
                           LOCAL.AGR.PNG #2 ]>, 
                   COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #5 ] >,
                            LOCAL.CONT.HOOK.VARG #5,
                            LOCAL.AGR.PNG #2  ],
                           [ LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CONT.HOOK.LTOP #7 ]>],
    LKEYS.KEYREL.ARG1 #7].



; for "han har kommet/blir skutt"
intrans-secpred-rais-from-perfect-verbal-arg1-synsem := arg1-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & semarg]>, 
                   COMPS < [ LOCAL.CAT.HEAD verb-all,
                             LOCAL.CAT.VAL.SUBJ < synsem & [LOCAL.CONT.HOOK.INDEX #5] >,    
                            LOCAL.CONT.HOOK.INDEX.E.TENSE perf ]>]].


; for "jeg lader opp"




; "pr√∏ve √• komme"
subj-equi-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #1,
			 LOCAL.CAT.HEAD.EXPLETIVE #expl ] >,
   LOCAL.CAT.VAL.COMPS < phr-synsem &
                         [LOCAL.CAT.HEAD infin-comp & [TRANSPAR +],
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2,
			  LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl ] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2 ].

; "ville komme"
subj-equi-bare-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >,
   LOCAL.CAT.VAL.COMPS < synsem &
                         [LOCAL.CAT.HEAD verb-all,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2 ] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2 ].

subj-equi-pp-synsem-sup := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.ICOMPS < [LOCAL.CAT.HEAD prep-comp & [SELECTED +,
                                                      KEYS.KEY #3 & rais],
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2 ] >,
   LOCAL.CAT.VAL.COMPS <>,
   LOCAL.KEY-SPEC #3,
   LKEYS.KEYREL.ARGOBLQ #2,
   LKEYS.KEYREL.ARG1 #1].

; "be om √• komme"; "snakke om √• komme"
subj-equi-pp-synsem := subj-equi-pp-synsem-sup.

; "drive med √• komme"
subj-equi-pp-atelic-synsem := subj-equi-pp-synsem-sup &
    [ LOCAL.CONT.HOOK.INDEX.SIT-TYPE atelic].


subj-prtcl-equi-pp-atelic-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK.LTOP #5,
   LOCAL.CONT.HOOK hook,
   LOCAL.CONT.HOOK.INDEX.SIT-TYPE atelic,
   LOCAL.KEY-SPEC #3,
   LOCAL.ALT-SPEC #4,
   LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #1]>],
   LOCAL.CAT.VAL.COMPS < lex-synsem &
                           [ LOCAL.CONT.HOOK.LTOP #5,
			     LOCAL.CAT.HEAD adv-reg & [KEYS.KEY #4 & pcl,
                                                       SELECTED +] ] >,
   LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-comp & [SELECTED +,
                                                      KEYS.KEY #3 & med-rais],
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2,
                          LOCAL.CONT.HOOK.INDEX.SORT non-fix-point]>,
   LKEYS.KEYREL.ARGOBLQ #2,
   LKEYS.KEYREL.ARG1 #1].

subj-equi-particle-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.ALT-SPEC #4,
   LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #1,
			 LOCAL.CAT.HEAD.EXPLETIVE #expl ] >,
   LOCAL.CAT.VAL.COMPS < lex-synsem &
                           [ LOCAL.CAT.HEAD adv-reg & [KEYS.KEY #4 & pcl,
                                                       SELECTED +] ],
			 phr-synsem &
                         [LOCAL.CAT.HEAD infin-comp & [TRANSPAR +],
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2,
			  LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl ] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2 ].



; having suspended prep-indirwhquest-word, this type is non-operative
; "lure p√• hva som skjer"
intrans-indirwhquest-pp-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD prep-comp & [SELECTED +,
                                                      KEYS.KEY clse],
                          LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.DECL -,
                          LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX event,
                          LOCAL.CONT.HOOK.LTOP #2 ] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2].


; for "vaske seg" + "vaske koppen"  <...
trans-arg1-2-synsem-sup := trans-synsem & arg1-subj-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX ref-ind,
			   LOCAL.CAT.HEAD.PRESENTED -] >,
    LOCAL.CAT.VAL.ICOMPS <>,
    LOCAL.CAT trans-nosecpred-empty-icomps-cat,
    LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #3,
    LOCAL.HAS-A-V-COMPLEMENT -,
    LOCAL.CONT.HOOK.VARG #3,
    LKEYS.KEYREL.ARG2 #3 ].

;;;REFL in long run, but not now
;trans-arg1-2-synsem := trans-arg1-2-synsem-sup &
;  [ LOCAL.CONT.HOOK hook,
;    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ] >].
; removed LOCAL.CONT.HOOK.INDEX.ROLE non-initiator, not because that is false, but because it needs cross-classification with all other sorts of NP specifcations coming from the object
; also removed LOCAL.CAT.HEAD.KEYS.KEY non-measurnoun as COMPS specification, as it excludes too much, like "det er fredag"                            
trans-arg1-2-synsem := trans-arg1-2-synsem-sup &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING.LEX-TAME -] >].
#|
trans-arg1-2refl-synsem := trans-arg1-2-synsem-sup &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #1,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING [ BOUND +,
                                           REFL-I +,
                                           REFL-II -,
                                           LEX-TAME + ],
                           LOCAL.CONT.HOOK.INDEX #1,
                           LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #1 ] >,
                           LOCAL.AGR.PNG #2,
                           LOCAL.CAT.HEAD.KEYS.KEY non-measurnoun ] >,
    NON-LOCAL.SLASH <! !>].
|#

trans-arg1-2refl-synsem := trans-arg1-2-synsem-sup &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CONT.HOOK.XARG #xarg,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING [ BOUND +,
                                           REFL-I +,
                                           REFL-II -,
                                           LEX-TAME + ],
			   LOCAL.CONT.RELS <! [], [], [ARG1 #index,
						       ARG2 #xarg] !>,
                           LOCAL.CONT.HOOK.INDEX #index,
			   LOCAL.AGR.PNG #2,
                           LOCAL.CAT.HEAD.KEYS.KEY non-measurnoun ] >,
    NON-LOCAL.SLASH <! !>].
;; ...>



; synsems for verbs with objects undergoing path-movement

;,
;                              LOCAL.CAT.HEAD.KEYS.KEY non-measurnoun

trans-arg1-2dir-synsem := trans-arg1-2-synsem-sup &
    [ LOCAL.CAT.HEAD non-copula,
      LOCAL.CONT.HOOK dir-hook,
      LOCAL.CONT.HOOK.DIRARG #1,
      LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX.ROLE non-initiator,
                              LOCAL.BINDING.LEX-TAME - ] >,
      LKEYS.KEYREL.ARG2 #1 ].

; synsems for trans verbs with subjects undergoing path-movement, like
; in "ta tog til...". "ta stien mot..."

; "se" is classified as this, and it obviously doesn't go with 'dirnoun' subjects, hence the outcomment.
trans-arg1dir-2-synsem := trans-arg1-2-synsem-sup &
    [ LOCAL.CAT.HEAD non-copula,
      LOCAL.CONT.HOOK dir-hook,
      LOCAL.CONT.HOOK.DIRARG #1,
      LKEYS.KEYREL.ARG1 #1,
 ;     LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX.SORT one-dim-thing,
 ;                           LOCAL.CAT.HEAD.KEYS.KEY dirnoun] >,
      LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.ROLE non-initiator,
			     LOCAL.BINDING [ BOUND - ]] >].

    
trans-arg1dir-2refl-synsem := trans-arg1-2-synsem-sup &
    [ LOCAL.CAT.HEAD non-copula,
      LOCAL.CONT.HOOK dir-hook,
      LOCAL.CONT.HOOK.DIRARG #1,
      LOCAL.CONT.HOOK.XARG #xarg,
      LKEYS.KEYREL.ARG1 #1,
      LOCAL.CAT.VAL.SUBJ < [ LOCAL.AGR.PNG #2 ]>,
      LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.ROLE non-initiator,
			     LOCAL.BINDING [ BOUND +,
                                           REFL-I +,
                                           REFL-II -,
                                           LEX-TAME + ],
			   LOCAL.CONT.RELS <! [], [], [ARG1 #index,
						       ARG2 #xarg] !>,
                           LOCAL.CONT.HOOK.INDEX #index,
			   LOCAL.AGR.PNG #2,
                           LOCAL.CAT.HEAD.KEYS.KEY non-measurnoun] >].

; "basere rapporten p√• Ola", "fortelle tull om meg"
trans-obl-synsem-sup := arg1-subj-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook & [ VARG #vrg],
    LOCAL.CAT trans-with-1icomps-pp-cat,
    LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD nominal ]>,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-ultra & [SELECTED +,
                                                        KEYS.KEY #1 & index-sita]]>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [KEYS.KEY #1 ]]>,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #4 & handle,
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.VARG #vrg,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +]]>,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #4 ]].
; ,
;    NON-LOCAL.SLASH <! !>].

; to exclude 'non-tamed' reflexive in 'alliere seg med'
trans-nonrefl-obl-synsem := trans-obl-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ] >].

trans-obl-n-synsem := trans-nonrefl-obl-synsem &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD nom,
                                                      CONT.HOOK.INDEX ref-ind & [ROLE non-initiator]] ].

trans-obl-decl-synsem := trans-nonrefl-obl-synsem &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                      CONT.HOOK.INDEX.E.TENSE finite],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #1 ]   ].

trans-obl-interr-synsem := trans-nonrefl-obl-synsem &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL -,
                                                      CONT.HOOK.INDEX.E.TENSE finite],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #1 ]  ].


trans-obl-absinf-synsem := trans-nonrefl-obl-synsem &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                      CAT.HEAD infin-comp & [ TRANSPAR -,
									      DECL + ]],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #1 ]   ].


trans-refl-obl-synsem-sup := trans-obl-synsem-sup &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #1,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING [ BOUND +,
                                           REFL-I +,
                                           REFL-II -,
                                           LEX-TAME + ],
                           LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #1 ] >,
                           LOCAL.AGR.PNG #2] >].
;                           NON-LOCAL.SLASH <! !> ] >].

trans-refl-obl-synsem := trans-refl-obl-synsem-sup &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD nom,
                                                      CONT.HOOK.INDEX ref-ind] ].

trans-refl-obl-decl-synsem := trans-refl-obl-synsem-sup &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                      CONT.HOOK.INDEX.E.TENSE finite],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #1 ]  ].

trans-refl-obl-interr-synsem := trans-refl-obl-synsem-sup &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL -,
                                                      CONT.HOOK.INDEX.E.TENSE finite],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #1 ]  ].

trans-refl-obl-absinf-synsem := trans-refl-obl-synsem-sup &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL +,
                                                      CAT.HEAD infin-comp & [ TRANSPAR -,
									      DECL + ]],
    LOCAL.CAT.QVAL.OBL1.LOCAL.CONT.HOOK.LTOP #1 & handle,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]>,
    LKEYS.KEYREL arg12obl-rel & [ ARGOBLQ #1 ]   ].




trans-obladv-synsem-sup := arg1-subj-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL.CONT.HOOK.INDEX #1,
    LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #2,
    LOCAL.CAT.VAL.ICOMPS <>,
    LOCAL.CAT.VAL.COMPS <[LOCAL.CONT.HOOK.INDEX #2], [LOCAL.CAT.HEAD a,
                                                      LOCAL.CONT.HOOK.XARG #1]>].

trans-obladv-synsem := trans-obladv-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], [] >].

trans-refl-obladv-synsem := trans-obladv-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #1,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING [ BOUND +,
                                           REFL-I +,
                                           REFL-II -,
                                           LEX-TAME + ],
                           LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #1 ] >,
                           LOCAL.AGR.PNG #2 ], [] >]. 
 
trans-2obl-synsem-sup := arg1-subj-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL.CAT trans-with-2icomps-pp-cat,
    LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD nominal ]>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY #1 & index-sita]],
                          [LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY #2 & index-sita]]>,
;    NON-LOCAL.SLASH <! !>,
    LOCAL.KEY-SPEC #1,
    LOCAL.ALT-SPEC #2 ].

trans-2obl-synsem := trans-2obl-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ] >].

trans-locobl-synsem := arg1-subj-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.COMPS <[]>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-or-adv & [ SELECTED -,
                                                          KEYS.KEY #1],
                           LOCAL.CONT.HOOK.INDEX[SORT non-fix-point,
                                                 ROLE xdim-to-xdim-spatial]]>].

trans-refl-locobl-synsem := arg1-subj-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #3,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING [ BOUND +,
                                           REFL-I +,
                                           REFL-II -,
                                           LEX-TAME + ],
                           LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #3 ] >,
                           LOCAL.AGR.PNG #2,
                           NON-LOCAL.SLASH <! !> ] >,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-or-adv & [ SELECTED -,
                                                          KEYS.KEY #1],
                           LOCAL.CONT.HOOK.INDEX[SORT non-fix-point,
                                                 ROLE xdim-to-xdim-spatial]]>].

; this type needs a way of selecting directional adv and prep: they
; have a SORT specification in common
; these verbs have hook, not dir-hook...
trans-dir-synsem-sup := arg1-subj-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4 ] >,
    LOCAL.CAT.VAL.COMPS <[],
			 [LOCAL.CONT.HOOK.LTOP #ltop,
			  LOCAL.CONT.HOOK.XARG #4,
			  LOCAL.CAT.HEAD prep-or-adv,
			  LOCAL.CAT.HEAD.KEYS.KEY dir,
                          LOCAL.CONT.HOOK.INDEX.SORT path-related-motion] >,
    LKEYS.KEYREL.ARGX #ltop].

trans-dir-synsem := trans-dir-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], 
			  [] >].

trans-refl-dir-synsem := trans-dir-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.AGR.PNG #2,
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >  ], 
			  [] >].




; "love meg √• komme"
subj-equi-doublobj-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #1 ] >,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #3,
                          LOCAL.BINDING.LEX-TAME -],
                         phr-synsem &
                         [LOCAL.CAT.HEAD infin-comp,
                          LOCAL.CAT.HEAD.TRANSPAR +,
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2 ] >,
   LKEYS.KEYREL.ARG2 #2,
   LKEYS.KEYREL.ARG3 #3].


obj-equi-synsem-sup := arg1-subj-synsem &
  [LOCAL.CAT.HEAD non-copula,
   LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #1 ],
                         [LOCAL.CAT.HEAD.TRANSPAR +,
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2 ] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2,
   LKEYS.KEYREL.ARG3 #1].

; "unne ham √• komme", "nekte ham √• komme"
obj-equi-synsem := obj-equi-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], [LOCAL.CAT.HEAD infin-comp] >].

obj-equi-refl-synsem := obj-equi-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #xarg,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.AGR.PNG #2,
                            LOCAL.CONT.HOOK.INDEX #index,
			    LOCAL.CONT.RELS <! [], [], [ARG1 #index,
							ARG2 #xarg] !> ], [LOCAL.CAT.HEAD infin-comp] >].


; "be ham komme"
obj-equi-bare-synsem := arg1-subj-synsem &
  [LOCAL.CAT.HEAD non-copula,
   LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #1,
                          LOCAL.BINDING nontamed,
			  LOCAL.CAT.HEAD.EXPLETIVE #expl ],
                         [LOCAL.CAT.HEAD verb-all,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE infin,
                          LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2,
   LKEYS.KEYREL.ARG3 #1].

#|
; "be ham om √• komme"
obj-equi-pp-synsem-sup := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD np-head,
                          LOCAL.CONT.HOOK.INDEX #1 ],
                         [LOCAL.CAT.HEAD prep-comp & [KEYS.KEY rais],
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2 ] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2,
   LKEYS.KEYREL.ARG3 #1].
|#
; "be ham om √• komme"
; 
;			  LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE bool

obj-equi-pp-synsem-sup := arg1-subj-synsem & arg2-comps-synsem &
  [LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD np-head & [EXPLETIVE bool],
                          LOCAL.CONT.HOOK.INDEX #1 ] >,
   LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-comp & [KEYS.KEY rais],
                          LOCAL.CONT.HOOK.XARG #1,
                          LOCAL.CONT.HOOK.LTOP #2]>,
   LKEYS.KEYREL.ARGOBLQ #2,
   LKEYS.KEYREL.ARG2 #1].

obj-equi-pp-synsem := obj-equi-pp-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ] >].

obj-equi-pp-refl-synsem := obj-equi-pp-synsem-sup &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2  ] >].


; "overlate til ham √• komme"
obl-equi-synsem := arg1-subj-synsem &
  [LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.ICOMPS < [LOCAL.CAT.HEAD prep,
                          LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1,
                          LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
                          LOCAL.CONT.HOOK.XARG #3 ] >,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD infin-comp & [TRANSPAR +],
                          LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
			  LOCAL.CONT.HOOK [XARG #1,
                                           LTOP #2,
                                           INDEX #3]] >,
   LKEYS.KEYREL.ARG2 #2].



; for "jeg ser ham komme", "jeg ser det sitte en gutt"
trans-secpred-rais-from-verbal-arg2-synsem-sup := arg2-predicative-synsem & 
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL [ CAT trans-ncomps-secpred-cat],
    LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #5,
			   LOCAL.CAT.HEAD.EXPLETIVE #expl,
			   LOCAL.MUST-APP +], 
                          [ LOCAL.CAT.HEAD verb-all & [IMPERATIVE -],
                            LOCAL.CAT.VAL.SUBJ < synsem & [LOCAL.CONT.HOOK.INDEX #5,
							   LOCAL.CAT.HEAD.EXPLETIVE #expl] >,    
                            LOCAL.CONT.HOOK.INDEX.E.TENSE infin ]>,
   LOCAL.CAT.VAL.ICOMPS <>].



trans-secpred-rais-from-verbal-arg2-synsem := trans-secpred-rais-from-verbal-arg2-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING non-bound ], [] >].


trans-secpred-rais-refl-from-verbal-arg2-synsem := trans-secpred-rais-from-verbal-arg2-synsem-sup &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2  ], [] >].


; for "jeg forutsetter ham √• komme", with pass: "han forutsettes √• komme"
trans-secpred-rais-from-infinmarked-arg2-synsem := arg2-predicative-synsem & 
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL [ CAT trans-ncomps-secpred-cat],
    LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #6 & semarg]>, 
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING nontamed,
                           LOCAL.CONT.HOOK.INDEX #5,
			   LOCAL.CAT.HEAD.EXPLETIVE #expl], 
                          [ LOCAL.CAT.HEAD infin-comp & [TRANSPAR +],
			    LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
                            LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CONT.HOOK.LTOP #3,
                            LOCAL.CAT.VAL.SUBJ < synsem & [LOCAL.CONT.HOOK.INDEX #5] >]>,
    LKEYS.KEYREL [ARG1 #6,
                  ARG2 #3 ],
   LOCAL.CAT.VAL.ICOMPS <>].

; for "jeg forutsetter ham skutt", with pass: "han forutsettes skutt" -- Complex Passive
trans-secpred-rais-from-perfmarked-arg2-synsem := arg2-predicative-synsem & 
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL [ CAT trans-ncomps-secpred-cat],
    LOCAL.CAT.VAL.SUBJ < [LOCAL.CONT.HOOK.INDEX #6 & semarg]>, 
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING nontamed,
                           LOCAL.CONT.HOOK.INDEX #5 & [ROLE non-initiator]], 
                          [ LOCAL.CAT.HEAD verb & [KEYS.KEY mainvb,
						   IMPERATIVE -],
                            LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CONT.HOOK.LTOP #3,
                            LOCAL.CONT.HOOK.INDEX.E.TENSE perf,
                            LOCAL.CAT.VAL.SUBJ < synsem & [LOCAL.CONT.HOOK.INDEX #5] >]>,
    LKEYS.KEYREL [ARG1 #6,
                  ARG2 #3 ],
   LOCAL.CAT.VAL.ICOMPS <>].



;LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,

; "han synes meg √• komme", "han forekommer meg √• komme"
trans-secpred-rais-from-infinmarked-arg1-synsem := arg1-predicative-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & semarg,
			    LOCAL.CAT.HEAD.EXPLETIVE #expl]>, 
                   COMPS < [LOCAL.CAT.HEAD nominal,
			    LOCAL.CONT.HOOK.INDEX #6 ],
                           [ LOCAL.CAT.HEAD.TRANSPAR +,
                             LOCAL.CONT.HOOK.XARG #5,
			     LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl,
                             LOCAL.CONT.HOOK.LTOP #3,
                             LOCAL.CAT.VAL.SUBJ < synsem & [LOCAL.CONT.HOOK.INDEX #5] > ]>],
    LKEYS.KEYREL [ARG1 #3,
                  ARG2 #6 ],
   LOCAL.CAT.VAL.ICOMPS <>].

;LOCAL.CAT.HEAD prep-or-adj,
                             ; "han synes meg syk", "han synes meg som gal"
trans-secpred-rais-from-adj-or-som-arg1-synsem := arg1-predicative-synsem & arg2-comps-synsem &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL.CAT trans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & semarg]>, 
                   COMPS < [LOCAL.CONT.HOOK.INDEX #6,
                            LOCAL.BINDING.LEX-TAME -,
                            LOCAL.BINDING.REFL-I -],
                           [ LOCAL.CAT.HEAD prep-or-adj,
			     LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CONT.HOOK.LTOP #3 ]>],
    LKEYS.KEYREL [ARG1 #3,
                  ARG2 #6 ],
   LOCAL.CAT.VAL.ICOMPS <>].

; han synes meg en idiot
trans-secpred-rais-from-n-arg1-synsem := arg1-predicative-synsem & arg2-comps-synsem & lex-item-2rel &
  [ LOCAL.CAT.HEAD non-copula,
    LOCAL.CONT.HOOK hook,
    LOCAL.CAT trans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & semarg]>, 
                   COMPS < [LOCAL.CONT.HOOK.INDEX #6,
                            LOCAL.BINDING.LEX-TAME -,
                            LOCAL.BINDING.REFL-I -],
                           [ LOCAL.CONT.HOOK.INDEX #7,
                             LOCAL.CONT.HOOK.LTOP #3 ]>],
     LOCAL.CONT.RELS <! [ARG1 #3,
			ARG2 #6 ], [LBL #3,
				    PRED "instantiate-rel",
				    ARG1 #5,
				    ARG2 #7 ] !>,
    LOCAL.CAT.VAL.ICOMPS <>].


trans-secpred-lexcause-pp-synsem-sup := arg2-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT trans-ncomps-secpred-cat,
    LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #5], 
                          [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CAT.HEAD prep & [KEYS.KEY index-sit1]] >,
    LOCAL.CAT.VAL.ICOMPS <> ].

trans-secpred-lexcause-pp-synsem := trans-secpred-lexcause-pp-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING non-bound ], [] >].
trans-secpred-refl-lexcause-pp-synsem := trans-secpred-lexcause-pp-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-RESP < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2  ], [] >].

; for "jeg anser ham frisk", "...som frisk"
trans-secpred-rais-from-nonverbal-arg2-synsem-super := arg2-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT trans-ncomps-secpred-cat,
    LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #5], 
                          [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CAT.HEAD prep-or-adj] >,
    LOCAL.CAT.VAL.ICOMPS <> ].

; '-sup': a version designed for prep governing an infinitive, as in 'anse np for √•...'
#|
trans-secpred-rais-from-nonverbal-arg2-synsem-sup := trans-secpred-rais-from-nonverbal-arg2-synsem-super & 
  [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.EXPLETIVE #expl], 
			  [LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.TRANSPAR +, 
			   LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl] >,
    LOCAL.CAT.QVAL.DOBJECT [LOCAL.CAT.HEAD.EXPLETIVE #expl], 
    LOCAL.CAT.QVAL.PREDIC [LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.TRANSPAR +, 
			   LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl] ].
|#
; trying to make the object be identical to the understood subject of the infi nitive, not just in index, but also in expletive +/- status
trans-secpred-rais-from-nonverbal-arg2-synsem-sup := trans-secpred-rais-from-nonverbal-arg2-synsem-super & 
  [ LOCAL.CAT.QVAL.DOBJECT [LOCAL.CAT.HEAD.EXPLETIVE #expl], 
    LOCAL.CAT.QVAL.PREDIC [LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.TRANSPAR +, 
			   LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.EXPLETIVE #expl] ].

; '-sap': a version designed for prep governing an np, as in 'anse np for/som np...', or som governing adj
trans-secpred-rais-from-nonverbal-arg2-synsem-sap := trans-secpred-rais-from-nonverbal-arg2-synsem-super.

; REFL
;trans-secpred-rais-from-nonverbal-arg2-synsem := trans-secpred-rais-from-nonverbal-arg2-synsem-sup &
;  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], [] >].

trans-secpred-rais-from-nonverbal-arg2-inf-synsem := trans-secpred-rais-from-nonverbal-arg2-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING non-bound ], [] >].

;; "f√∏le seg frisk", anse seg ferdig,... som ferdig
trans-secpred-rais-refl-from-nonverbal-arg2-inf-synsem := trans-secpred-rais-from-nonverbal-arg2-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-RESP < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2], [] >].

trans-secpred-rais-from-nonverbal-arg2-plain-synsem := trans-secpred-rais-from-nonverbal-arg2-synsem-sap &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING non-bound ], [] >].

;; "f√∏le seg frisk", anse seg ferdig,... som ferdig
trans-secpred-rais-refl-from-nonverbal-arg2-plain-synsem := trans-secpred-rais-from-nonverbal-arg2-synsem-sap &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-RESP < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2  ], [] >].



; for "jeg kaller ham en venn"
trans-secpred-rais-from-nominal-arg2-synsem-sup := arg2-predicative-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT trans-ncomps-secpred-cat,
    LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #1], 
                          [ LOCAL.CONT.HOOK.INDEX #5,
                            LOCAL.CAT.HEAD np-head] >,
    LOCAL.CAT.VAL.ICOMPS <>,  
    LOCAL.CONT.RELS <! [ARG2 #3], [ LBL #3,
				    PRED "_instantiate_c_rel",
				    ARG1 #1,
				    ARG2 #5 ] !> ].

trans-secpred-rais-from-nominal-arg2-synsem := trans-secpred-rais-from-nominal-arg2-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING.REFL-I - ], [] >].

;; "kalle seg en venn"
trans-secpred-rais-refl-from-nominal-arg2-synsem := trans-secpred-rais-from-nominal-arg2-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2  ], [] >].


; for "jeg synger ham frisk", "jeg synger det fint" (expl "det")
; the restriction 'DEF +' is to prevent this entry from being a licenser of
; "det l√∏per en gutt mot skogen" (yields multiple parses)
trans-secpred-arg1-x-synsem-sup := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT trans-ncomps-secpred-cat,
    LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #5 & [SORT referential-thing],
                           LOCAL.CAT.HEAD.DEF + ], 
                          [ LOCAL.CONT.HOOK.XARG #5 ] >,
    LOCAL.CAT.VAL.ICOMPS <> ].

;LH may7-11
trans-secpred-shift-arg1-x-synsem-sup := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT trans-ncomps-secpred-cat,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #5 ],
			  [LOCAL.CONT.HOOK.INDEX #5 ] >,
    LOCAL.CAT.VAL.ICOMPS <> ].

; REFL
;trans-secpred-arg1-x-synsem := trans-secpred-arg1-x-synsem-sup &
;  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], [] >].


trans-secpred-arg1-x-synsem := trans-secpred-arg1-x-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING.REFL-I - ], [] >].

;LH may7-11
trans-secpred-shift-arg1-x-synsem := trans-secpred-shift-arg1-x-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [], [ LOCAL.BINDING.REFL-I - ] >].

trans-secpred-arg1-x-refl-synsem := trans-secpred-arg1-x-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2  ], [] >,
    NON-LOCAL.SLASH <! !> ].

#|
trans-secpred-arg1-x-refl-synsem := trans-secpred-arg1-x-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.CONT.HOOK.INDEX #4,
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2  ], [] >,
    NON-LOCAL.SLASH <! !> ].
|#

; for "jeg sparker ballen flat", "jeg sparker det fint" (expl "det")
; to subtype, a very general one: LOCAL.CAT.HEAD prep-or-adj-or-adv & [SELECTED -],
;                            
trans-secpred-arg1-2-x-synsem-sup := argx-predicative-synsem & arg1-subj-synsem & arg2-comps-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CAT trans-ncomps-secpred-cat,
    LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #5,
                           LOCAL.CAT.HEAD np-head], 
                          [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CONT.HOOK.INDEX ad-event ] >,
    LOCAL.CAT.VAL.ICOMPS <> ].

;REFL
;trans-secpred-arg1-2-x-synsem := trans-secpred-arg1-2-x-synsem-sup &
;  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], [] >].
trans-secpred-arg1-2-x-synsem := trans-secpred-arg1-2-x-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING.REFL-I - ], [] >].

trans-secpred-arg1-2-x-refl-synsem := trans-secpred-arg1-2-x-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2  ], [] >].

; for the moment feeds into two rules: head-verb-adverb-comp-phrase and head-verb-particleshift-comp-phrase. The former is a bit too inclusive, but cannot be restricted, or we lose "f√• Ola tilbake" (Aug19-06)
; for "jeg sparker ut ballen"
trans-particleshift-synsem := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK dir-hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.VARG #5,
    LOCAL.CAT trans-invertsecpred-cat,
    LKEYS.KEYREL.ARG2 #5,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CAT.HEAD adv-reg & [KEYS.KEY dir]], 
                          [LOCAL.CONT.HOOK.INDEX #5] >,
    LOCAL.CAT.VAL.ICOMPS <> ].

; LH 280411
trans-particleshift-non-dir-synsem := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.VARG #5,
    LOCAL.CAT trans-invertsecpred-cat,
    LKEYS.KEYREL.ARG2 #5,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CAT.HEAD adv-reg & [KEYS.KEY pcl]], 
                          [LOCAL.CONT.HOOK.INDEX #5] >,
    LOCAL.CAT.VAL.ICOMPS <> ].


; LH 060511
; regne ut at/om/hvem
trans-particleshift-eventobj-synsem := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CAT.HEAD verb,
    LOCAL.CAT trans-invertsecpred-cat,
    LKEYS.KEYREL.ARG2 #5,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CAT.HEAD adv-reg & [KEYS.KEY pcl]], 
                          [ LOCAL.CONT.HOOK.LTOP #5,
                            LOCAL.CAT.HEAD heady,
			    LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,
    LOCAL.CAT.VAL.ICOMPS <> ].

; for "han tar p√• seg skoene"
trans-ppshift-synsem := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.VARG #5,
    LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1,
    LOCAL.CAT trans-invertsecpred-cat,
    LKEYS.KEYREL.ARG2 #5,
    LOCAL.KEY-SPEC #key,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CAT.HEAD prep,
                            LOCAL.CAT.HEAD [KEYS.KEY #key & index-sit],
                            LOCAL.CAT.QVAL.DOBJECT.LOCAL.BND-MOUNTABLE  < [ ANAPH-INDX #1,
                                                                            ANAPH-TYPE #20] >,
                            LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING #20 & [ BOUND +,
                                                                         REFL-I +,
                                                                         REFL-II -,
                                                                         LEX-TAME + ]], 
                          [ LOCAL.CAT.HEAD np-head,
                            LOCAL.CONT.HOOK.INDEX #5] >,
    LOCAL.CAT.VAL.ICOMPS <> ].

trans-ppshift-nonrefl-synsem := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.VARG #5,
    LOCAL.CAT trans-invertsecpred-cat,
    LKEYS.KEYREL.ARG2 #5,
    LOCAL.KEY-SPEC #key,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CAT.HEAD prep,
                            LOCAL.CAT.HEAD [KEYS.KEY #key & index-sit]],
                            [ LOCAL.CAT.HEAD np-head,
                            LOCAL.CONT.HOOK.INDEX #5] >,
    LOCAL.CAT.VAL.ICOMPS <> ].

; for "han kler p√• gutten"
trans-ppshift-implicit-synsem := argx-predicative-synsem & arg1-subj-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.VARG #5,
    LKEYS.KEYREL.ARG2 #5,
    LKEYS.KEYREL.ARGX #6,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CONT.HOOK.LTOP #6,
                            LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CAT.HEAD prep,
                            LOCAL.CAT.HEAD [KEYS.KEY index-sit] ]>,
    LOCAL.CAT.VAL.ICOMPS <> ].

; for "han kler p√• seg"
trans-ppshift-refl-implicit-synsem := argx-predicative-synsem & arg1-subj-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.VARG #5,
    LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1,
    LKEYS.KEYREL.ARG2 #5,
    LKEYS.KEYREL.ARGX #6,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CONT.HOOK.LTOP #6,
                            LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CAT.HEAD prep,
                            LOCAL.CAT.HEAD [KEYS.KEY index-sit,
                                            SELECTED +],
                            LOCAL.CAT.QVAL.DOBJECT.LOCAL.BND-RESP < [ ANAPH-INDX #1 ] >,
                            LOCAL.CAT.QVAL.DOBJECT.LOCAL.BINDING[ BOUND +,
                                                                  REFL-I +,
                                                                  REFL-II -,
                                                                  LEX-TAME + ]] >,
    LOCAL.CAT.VAL.ICOMPS <> ].


trans-adjshift-synsem := argx-predicative-synsem & arg1-subj-synsem &
  [ LOCAL.CONT.HOOK dir-hook,
    LOCAL.CAT.HEAD verb,
    LOCAL.CONT.HOOK.VARG #5,
    LOCAL.CAT trans-invertsecpred-cat,
    LKEYS.KEYREL.ARG2 #5,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                            LOCAL.CONT.HOOK.INDEX ad-event,
                            LOCAL.CAT.HEAD adj & [KEYS.KEY propt]], 
                          [LOCAL.CONT.HOOK.INDEX #5] >,
    LOCAL.CAT.VAL.ICOMPS <> ].


; "se/tro at han kommer"
; 'intrans-qval' to prevent these verbs from licensing free-objpred
trans-subord-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX ref-ind,
			    LOCAL.CAT.HEAD.EXPLETIVE -] >],
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.DECL +,
                          LOCAL.CAT.HEAD.INV -,
                          LOCAL.CAT.HEAD fin-comp,
                          LOCAL.CAT.HEAD.IMPERATIVE -,
                          LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LOCAL.CAT.QVAL trans-qval,
   LKEYS.KEYREL.ARG2 #2 ].

trans-absinfsubord-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX ref-ind,
			    LOCAL.CAT.HEAD.EXPLETIVE -] >],
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD infin-comp & [TRANSPAR -],
			  LOCAL.CAT.HEAD.DECL +,
                          LOCAL.CAT.HEAD.IMPERATIVE -,
;			  LKEYS.KEYREL.ARG2 #8,
                          LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE infin] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LOCAL.CAT.QVAL trans-qval,
   LKEYS.KEYREL.ARG2 #2].

trans-arg1absinf-absinfsubord-synsem := eventarg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.HEAD.INV -,
   LOCAL.CAT.VAL.SUBJ < [LOCAL.CAT.HEAD.DECL +,
;			  LKEYS.KEYREL.ARG2 #8,
                          LOCAL.CONT.HOOK.LTOP #1 & semarg,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE infin] >,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.DECL +,
                          LOCAL.CAT.HEAD.IMPERATIVE -,
;			  LKEYS.KEYREL.ARG2 #8,
                          LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE infin] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LOCAL.CAT.QVAL trans-qval,
   LKEYS.KEYREL.ARG2 #1,
   LKEYS.KEYREL.ARG2 #2].



#|
,
    LOCAL.CONT.RELS <! indef-q-rel & [ PRED "_udef_q_rel",
				 ARG0 #8,
				 RSTR #15 ], pron_rel & [ PRED "_understood-agent_rel",
							 LBL #16,
							 ARG0 #8 ] !>,
    LOCAL.CONT.HCONS <! [ HARG #15,
			     LARG #16] !>].
|#

;LH may8-11
;				 CONT.HOOK.INDEX expl-ind ]],
trans-subord-expn-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL[ CAT.HEAD expl-pron,
				 CONT.HOOK.INDEX ref-ind ]],
			 [LOCAL.CAT.HEAD glob-comp & [TRANSPAR -],
                          LOCAL.CAT.HEAD.IMPERATIVE -,
			  LOCAL.CONT.HOOK.LTOP #2 & semarg] >,
   LOCAL.CAT.VAL.ICOMPS <>,
  LKEYS.KEYREL.ARG2 #2 ].

;if subclassification needed, the these, pls the conditional
#|
trans-subord-expn-decl-synsem := trans-subord-expn-synsem &
 [LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.DECL +,
			     LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >].
trans-subord-expn-inf-synsem := trans-subord-expn-synsem &
 [LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD infin-comp] >].
|#

;muliggjorde (for ham) √• komme

; these combine not only with comp-headed clauses, but also with
; V-headed, as in "vite hva han spiser" - therefore not subtype
; of trans-subord-synsem
; "vite/se hva/hvorvidt han spiser"

trans-indirwhquest-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD verb-all & [DECL -,
						     IMPERATIVE -,
						     INV -],
			  LOCAL.CONT.HOOK.LTOP #2,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2 ].


trans-indir-y-n-quest-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD fin-comp & [DECL -,
						     IMPERATIVE -,
						     INV -],
                          LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX event-verb & [E.TENSE finite]] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2 ].

; a neutral version of the above, since lots of verbs are defined for a neutral version:
trans-indir-interr-synsem := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD [DECL -,
					  IMPERATIVE -,
					  INV -],
                          LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX [E.TENSE finite]] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LKEYS.KEYREL.ARG2 #2 ].



trans-eventarg1-synsem := trans-synsem & eventarg1-subj-synsem & arg2-comps-synsem &
 [ LOCAL.CAT [ VAL.ICOMPS <>]].

trans-eventarg1-decl-synsem := trans-eventarg1-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD fin-comp & [DECL +,
						     IMPERATIVE - ]] > ].

trans-eventarg1-interr-synsem := trans-eventarg1-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL - ] > ].

trans-eventarg1-absinf-synsem := trans-eventarg1-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD infin-comp & [ TRANSPAR -,
							 DECL + ]] > ].

trans-eventarg1-obl-synsem := eventarg1-subj-synsem & arg2-comps-synsem &
 [ LOCAL.CAT [ VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY fct-spec ]]>]].
trans-eventarg1-decl-obl-synsem := trans-eventarg1-obl-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL + ] > ].
trans-eventarg1-interr-obl-synsem := trans-eventarg1-obl-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL - ] > ].

trans-eventarg1-eventobl-synsem := trans-eventarg1-obl-synsem &
  [ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [BINDING nontamed & [REFL-I -],
                                                      CONT.HOOK.INDEX.E.TENSE finite],
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY clse ]]> ].

trans-eventarg1-eventobl-decl-synsem := trans-eventarg1-eventobl-synsem &
[ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL + ]].
trans-eventarg1-eventobl-interr-synsem := trans-eventarg1-eventobl-synsem &
[ LOCAL.CAT.QVAL.OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CAT.HEAD.DECL - ]].

trans-eventarg1decl-eventobldecl-synsem := trans-eventarg1-decl-obl-synsem & trans-eventarg1-eventobl-decl-synsem.
trans-eventarg1decl-eventoblinterr-synsem := trans-eventarg1-decl-obl-synsem & trans-eventarg1-eventobl-interr-synsem.
trans-eventarg1interr-eventobldecl-synsem := trans-eventarg1-interr-obl-synsem & trans-eventarg1-eventobl-decl-synsem.
trans-eventarg1interr-eventoblinterr-synsem := trans-eventarg1-interr-obl-synsem & trans-eventarg1-eventobl-interr-synsem.




trans-eventarg1-eventarg2-synsem := trans-synsem & eventarg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LOCAL.CAT.QVAL trans-qval,
   LKEYS.KEYREL.ARG2 #2 ].
 
trans-eventarg1decl-eventarg2-synsem := trans-eventarg1-eventarg2-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL + ] > ].
trans-eventarg1interr-eventarg2-synsem := trans-eventarg1-eventarg2-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL - ] > ].
trans-eventarg1decl-eventarg2decl-synsem := trans-eventarg1decl-eventarg2-synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.DECL + ] > ].
trans-eventarg1decl-eventarg2interr-synsem := trans-eventarg1decl-eventarg2-synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.DECL - ] > ].
trans-eventarg1interr-eventarg2decl-synsem := trans-eventarg1interr-eventarg2-synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.DECL + ] > ].
trans-eventarg1interr-eventarg2interr-synsem := trans-eventarg1interr-eventarg2-synsem &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD.DECL - ] > ].

ditrans-eventarg1-synsem := ditrans-synsem & eventarg1-subj-synsem & arg23-comps-synsem &
 [ LOCAL.CAT [ VAL.ICOMPS <>]].

ditrans-eventarg1-declar-synsem := ditrans-eventarg1-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD [DECL +]] > ].

;ditrans-eventarg1-declar-synsem := ditrans-eventarg1-synsem &
;  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL + ] > ].

ditrans-eventarg1-decl-synsem := ditrans-eventarg1-declar-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD fin-comp ] > ].

ditrans-eventarg1-absinf-synsem := ditrans-eventarg1-declar-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD infin-comp & [TRANSPAR -]] > ].

ditrans-eventarg1-interr-synsem := ditrans-eventarg1-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL - ] > ].

;ditrans-eventarg1-absinf-synsem := ditrans-eventarg1-synsem &
;  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD infin-comp ] > ].

ditrans-eventarg1-eventarg2-synsem := eventarg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL [ CONT.HOOK.VARG #2],
   LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #1,
			  LOCAL.CONT.HOOK.INDEX.SORT anim-thing ],
			  [LOCAL.CONT.HOOK.LTOP #2 & semarg,
                          LOCAL.CONT.HOOK.INDEX.E.TENSE finite] >,
   LOCAL.CAT.VAL.ICOMPS <>,
   LOCAL.CAT.QVAL ditrans-qval,
   LKEYS.KEYREL.ARG2 #2,
   LKEYS.KEYREL.ARG3 #1 ].

ditrans-eventarg1decl-eventarg2-synsem := ditrans-eventarg1-eventarg2-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL + ] > ].
ditrans-eventarg1interr-eventarg2-synsem := ditrans-eventarg1-eventarg2-synsem &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.DECL - ] > ].
ditrans-eventarg1decl-eventarg2decl-synsem := ditrans-eventarg1decl-eventarg2-synsem &
  [ LOCAL.CAT.VAL.COMPS < [], [ LOCAL.CAT.HEAD.DECL + ] > ].
ditrans-eventarg1decl-eventarg2interr-synsem := ditrans-eventarg1decl-eventarg2-synsem &
  [ LOCAL.CAT.VAL.COMPS < [], [ LOCAL.CAT.HEAD.DECL - ] > ].
ditrans-eventarg1interr-eventarg2decl-synsem := ditrans-eventarg1interr-eventarg2-synsem &
  [ LOCAL.CAT.VAL.COMPS < [], [ LOCAL.CAT.HEAD.DECL + ] > ].
ditrans-eventarg1interr-eventarg2interr-synsem := ditrans-eventarg1interr-eventarg2-synsem &
  [ LOCAL.CAT.VAL.COMPS < [], [ LOCAL.CAT.HEAD.DECL - ] > ].



ditrans-arg1-2-3-synsem-sup := ditrans-synsem & arg1-subj-synsem & arg23-comps-synsem &
  [ LOCAL [ CONT.HOOK.VARG #2],
    LKEYS.KEYREL.ARG2 #2,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.SPEC-TO-BARE-N -,
			   LOCAL.CARD-TO-BARE-N - ]>,
    LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX.SORT anim-thing,
			   LOCAL.SPEC-TO-BARE-N -,
			   LOCAL.CARD-TO-BARE-N -,
			   LOCAL.MUST-APP + ], 
			  [LOCAL.MUST-APP +] >  ].

ditrans-arg1-2-3-synsem := ditrans-arg1-2-3-synsem-sup & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING nontamed ], [] > ].

ditrans-arg1-2-3refl-synsem := ditrans-arg1-2-3-synsem-sup &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #1,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [LOCAL.BINDING [ BOUND +,
                                           REFL-I +,
                                           REFL-II -,
                                           LEX-TAME + ],
                           LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #1 ] >,
                           LOCAL.AGR.PNG #2 ], [] >].


; "vise meg at han kommer"
;,
;                          LOCAL.CONT.HOOK.INDEX.E.TENSE finite
; removed in order to also allow infinitives. TODO: it misses the equi-effect, which is probably there, so this is a temporary hack
ditrans-subord-synsem-sup := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD nom,
                           LOCAL.CONT.HOOK.INDEX #1],
                         phr-synsem &
                         [LOCAL.CAT.HEAD glob-comp,
			  LOCAL.CAT.HEAD.DECL +,
                          LOCAL.CONT.HOOK.LTOP #2 & semarg] >,
   LKEYS.KEYREL.ARG2 #2,
   LKEYS.KEYREL.ARG3 #1 ].

ditrans-nonrefl-subord-synsem := ditrans-subord-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], [] >].

; forestille seg at
ditrans-refl-subord-synsem := ditrans-subord-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2  ], [] >].

ditrans-decl-subord-synsem := ditrans-subord-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD fin-comp] >].

ditrans-equiinf-subord-synsem := ditrans-subord-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4 ] >,
    LOCAL.CAT.VAL.COMPS < [], [LOCAL.CONT.HOOK.XARG #4,
			       LOCAL.CAT.HEAD infin-comp & [TRANSPAR +]] >].

ditrans-decl-synsem := ditrans-nonrefl-subord-synsem & ditrans-decl-subord-synsem.

ditrans-equiinf-synsem := ditrans-nonrefl-subord-synsem & ditrans-equiinf-subord-synsem.

ditrans-refl-decl-synsem := ditrans-refl-subord-synsem & ditrans-decl-subord-synsem.

ditrans-refl-equiinf-synsem := ditrans-refl-subord-synsem & ditrans-equiinf-subord-synsem.

; these combine not only with comp-headed clauses, but also with
; V-headed, as in "vite hva han spiser" - therefore not subtype
; of trans-subord-synsem
; "sp√∏rre meg hva/hvorvidt han spiser"
ditrans-indirwhquest-synsem-sup := arg1-subj-synsem &
  [LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD nom,
                           LOCAL.CONT.HOOK.INDEX #1],
                         [LOCAL.CAT.HEAD.DECL -,
                          LOCAL.CONT.HOOK.LTOP #2 & semarg,
			  LOCAL.CONT.HOOK.INDEX.SF ques] >,
   LKEYS.KEYREL.ARG2 #2,
   LKEYS.KEYREL.ARG3 #1 ].

ditrans-y-n-indirwhquest-synsem := ditrans-indirwhquest-synsem-sup &
  [LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD fin-comp] >].

ditrans-wh-indirwhquest-synsem := ditrans-indirwhquest-synsem-sup &
  [LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD verb-all] >].

ditrans-nonrefl-indirwhquest-synsem := ditrans-indirwhquest-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], [] >].

;LH may8-11
; undre seg hvorvidt
ditrans-refl-indirwhquest-synsem := ditrans-indirwhquest-synsem-sup &
  [ LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2 ]>,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
                            LOCAL.AGR.PNG #2  ], [] >].

ditrans-y-n-refl-indirwhquest-synsem := ditrans-y-n-indirwhquest-synsem & ditrans-refl-indirwhquest-synsem.
ditrans-y-n-nonrefl-indirwhquest-synsem := ditrans-y-n-indirwhquest-synsem & ditrans-nonrefl-indirwhquest-synsem.
ditrans-wh-refl-indirwhquest-synsem := ditrans-wh-indirwhquest-synsem & ditrans-refl-indirwhquest-synsem.
ditrans-wh-nonrefl-indirwhquest-synsem := ditrans-wh-indirwhquest-synsem & ditrans-nonrefl-indirwhquest-synsem.

;;;;;;;;;; PRESENTATIONAL CONSTRUCTIONS
; for inheritance
; the NON-LOCAL restr is a bit too sharp - ,
;    NON-LOCAL.SLASH <! !>
; working area
#|
presentational-synsem-2 := lex-synsem &
  [ LOCAL.CAT lex-cat & [QVAL.SUBJECT [ LOCAL [ CAT.HEAD expl-pron,
                                                CONT [ HOOK.INDEX #1 & ref-ind ] ] ]],
    LOCAL.CONT.HOOK.XARG #1,
    LOCAL.CONT.HOOK.LTOP #3,
    LOCAL.CONT.RELS <! [LBL #2], [LBL #3,
				  PRED "intro-sit-rel",
				  ARG1 #1,
				  ARG2 #2] !>,
    LOCAL.CONT.HCONS <! !>].
|#
#|
presentational-synsem-2 := lex-synsem &
  [ LOCAL.CAT lex-cat & [QVAL.SUBJECT [ LOCAL [ CAT.HEAD expl-pron,
                                                CONT [ HOOK.INDEX #1 & ref-ind ] ] ]],
    LOCAL.CONT.HOOK.XARG #1,
    LOCAL.CONT.HOOK.LTOP #3,
    LOCAL.CONT.RELS <! [LBL #3], [PRED "intro-sit-rel",
				  ARG1 #1,
				  ARG2 #4 ] !>,
    LOCAL.CONT.HCONS <![HARG #4,
			LARG #3]!> ].

|#

presentational-synsem-2 := lex-synsem &
  [ LOCAL.CAT lex-cat & [VAL.SUBJ 1-list & [FIRST #subj ],
			 QVAL.SUBJECT #subj & [ LOCAL [ CAT.HEAD expl-pron,
                                                CONT [ HOOK.INDEX #1 & ref-ind ] ] ]],
    LOCAL.CONT.HOOK.XARG #1,
    LOCAL.CONT.HOOK.LTOP #3,
    LOCAL.CONT.RELS <! [LBL #3], [PRED "intro-sit-rel",
				  ARG1 #1,
				  ARG2 #3 ] !>,
    LOCAL.CONT.HCONS <! !> ].

;LH271111: being replaced by presentational-synsem-2
presentational-synsem := lex-synsem &
  [ LOCAL.CAT lex-cat & [QVAL.SUBJECT [ LOCAL [ CAT.HEAD expl-pron,
                                                CONT [ HOOK.INDEX #1 & expl-ind ] ] ]],
    LOCAL.CONT.HOOK.XARG #1 ].

#|
presentational-synsem := lex-synsem &
  [ LOCAL.CAT lex-cat & [QVAL.SUBJECT [ LOCAL [ CAT.HEAD expl-pron,
                                                CONT [ HOOK.INDEX #1 & expl-ind,
						       HOOK.LTOP #2 ] ] ]],
    LOCAL.CONT.HOOK.XARG #1,
    LOCAL.CONT.HOOK.LTOP #2 ].
|#
; suse, klarne; "klarne opp"
#|
impersonal-presentational-synsem := presentational-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CONT.HOOK [ INDEX #1,
                      VARG #1 ],
    LOCAL.CAT.VAL.COMPS <> ].
|#

;presentational-synsem-2
impersonal-presentational-synsem := presentational-synsem-2 &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL.COMPS <> ].

#|
; kvekke, ise, kile, kime
impersonal-presentational-obl-synsem := presentational-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CONT.HOOK [ INDEX #1,
                      VARG #1 ],
    LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CONT.HOOK.LTOP #2,
                           LOCAL.CAT.HEAD [SELECTED +,
                                           KEYS.KEY index-sit1]]>,
    LKEYS.KEYREL.ARGOBLQ #2 ].
|#

impersonal-presentational-obl-synsem := presentational-synsem-2 &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CONT.HOOK [ INDEX #1,
                      VARG #1 ],
    LOCAL.CAT.HEAD non-copula,
    LOCAL.CAT.VAL.COMPS <>,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CONT.HOOK.LTOP #2,
                           LOCAL.CAT.HEAD [SELECTED bool,
                                           KEYS.KEY index-sit1]]>,
    LKEYS.KEYREL.ARGOBLQ #2 ].


;  "klarne opp", tykne til
;presentational-synsem-2
;                          LKEYS.KEYREL.ARG1 #1
;
 ;                          LOCAL.CONT.HOOK.XARG #1,
					  
impersonal-presentational-telicparticle-synsem := presentational-synsem-2 &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CONT.HOOK [ INDEX #1,
                      VARG #1],
    LOCAL.CAT.HEAD non-copula,
    LOCAL.CAT.VAL.COMPS <[ LOCAL.CAT.HEAD adv-reg,
                           LOCAL.CONT.HOOK.LTOP #2,
                           LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion]>,
    LKEYS.KEYREL.ARGX #2 ].


; sitte, v√¶re - "det sitter en gutt her"
;  LOCAL.CONT.HOOK.XARG #1  is a bit tentative - - for the TROLL presentationals
subject-presentational-synsem-sup := presentational-synsem-2 &
   [ LOCAL.CAT trans-cat & [QVAL.DOBJECT.LOCAL [CAT.HEAD.DEF -,
                                                CONT.HOOK.INDEX #1,
                                                CAT.HEAD.PRESENTED +,
                                                DERIVED-HEAD -],
                            VAL.COMPS < [] >],
     LKEYS.KEYREL.ARG1 #1,
     LOCAL.CONT.HOOK.VARG #1 ].

subject-presentational-synsem := subject-presentational-synsem-sup &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT trans-cat & [QVAL.DOBJECT.LOCAL [CAT.HEAD.DEF -,
                                                CONT.HOOK.INDEX #1 ],
                            VAL.COMPS < [] >,
                            VAL.ICOMPS < >],
     LKEYS.KEYREL.ARG1 #1 ].

;;; experiment 021012
;; to enable scoping of expletive sentences, this is one roundabout way, exemplified for "det rusler en gutt". It will require a 3-rel verb lexeme type, and the following as the new presentational-synsem-2:
#|
; this is where the outcomment should start! down to line 16718
presentational-synsem-2 := lex-synsem &
[ LOCAL.CAT lex-cat & [QVAL.SUBJECT.LOCAL [ CAT.HEAD expl-pron,
                                              CONT.HOOK.INDEX #1 & ref-ind ]],
    LOCAL.CONT.HOOK.XARG #1,
    LOCAL.CONT.HOOK.LTOP #4,
    LOCAL.CONT.RELS <! [LBL #4], [PRED "intro-sit-rel",
				  ARG1 #1,
				  ARG2 #3 ], [PRED "coreferential-rel",
					      ARG1 #3,
					      ARG2 #4 ] !>,
    LOCAL.CONT.HCONS <! !> ].
|#
#|
;Using the defined type verb-3rel-lexeme.
;illustrated with, in one lump:
subject-dir-presentational-verb-lexeme := lbl-ltop-lex-item-3rel &
[ SYNSEM lex-synsem &
  [ LOCAL.CAT lex-cat & [QVAL.SUBJECT.LOCAL [ CAT.HEAD expl-pron,
                                              CONT.HOOK.INDEX #1 & ref-ind ]],
    LOCAL.CONT.HOOK.XARG #1,
    LOCAL.CONT.HOOK.LTOP #4,
    LOCAL.CONT.RELS <! [LBL #4], [PRED "intro-sit-rel",
				  ARG1 #1,
				  ARG2 #3 ], [PRED "coreferential-rel",
					      ARG1 #3,
					      ARG2 #4 ] !>,
    LOCAL.CONT.HCONS <! !> ]].
|#
#|
; and for the general pattern, such:
subject-dir-presentational-verb-lexeme := verb-3rel-lexeme &
  [ SYNSEM subject-dir-presentational-synsem ].

; where subject-dir-presentational-synsem inherits down from presentational-synsem-2 in the way generally defined. The new action is to adjust in verb-3rel-lexeme in all the lexeme types. 
|#

; rusle_4 "det rusler en gutt ut"
subject-dir-presentational-synsem := subject-presentational-synsem-sup &
  [ LOCAL.CONT.HOOK dir-hook,
    LOCAL.CONT.HOOK.DIRARG #1,
    LKEYS.KEYREL.ARG1 #1,
    LOCAL.CAT.VAL.ICOMPS < > ]. 

;det sitter en mann i stolen
subject-locobl-presentational-synsem := subject-presentational-synsem-sup &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.ICOMPS <[LOCAL.CAT.HEAD prep-or-adv & [ SELECTED -,
                                                          KEYS.KEY #1& index-sit],
                           LOCAL.CONT.HOOK.INDEX[SORT non-fix-point,
                                                 ROLE xdim-to-xdim-spatial]]>].

; "det hopper opp en katt"
;presentational-synsem-2
subject-presentational-telicparticle-synsem := presentational-synsem-2 &
  [  LOCAL.CAT.VAL.COMPS <[ LOCAL.CAT.HEAD adv-reg & [ KEYS.KEY dir ],
			    LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
			    LOCAL.CONT.HOOK.XARG #1,
			    LKEYS.KEYREL.ARG1 #1],
			  [ LOCAL [CAT.HEAD.DEF -,
                                  CONT.HOOK.INDEX #1,
                                  CAT.HEAD.PRESENTED +,
                                  DERIVED-HEAD -]]>, 
    LOCAL.CAT.VAL.ICOMPS <>,
    LKEYS.KEYREL.ARG1 #1 ].

;presentational-synsem-2
subject-presentational-telicparticle-prtcllast-synsem := presentational-synsem-2 &
  [  LOCAL.CAT.VAL.COMPS <[ LOCAL [CAT.HEAD.DEF -,
                                  CONT.HOOK.INDEX #1,
                                  CAT.HEAD.PRESENTED +,
                                  DERIVED-HEAD -]],
			    [ LOCAL.CAT.HEAD adv-reg & [ KEYS.KEY dir ],
			   LOCAL.CONT.HOOK.INDEX.SORT fix-point-motion,
			    LOCAL.CONT.HOOK.XARG #1,
			    LKEYS.KEYREL.ARG1 #1] >, 
    LOCAL.CAT.VAL.ICOMPS <>,
    LKEYS.KEYREL.ARG1 #1 ].


;presentational-synsem-2
double-np-presentational-synsem-sup := presentational-synsem-2 &
   [  LOCAL.CAT.HEAD non-copula,
    LOCAL.CAT [VAL.COMPS [FIRST [ LOCAL.CONT.HOOK.INDEX #2 ], 
			   REST.FIRST [LOCAL [CAT.HEAD.DEF -,
					      CAT.HEAD.PRESENTED +,
					      CONT.HOOK.INDEX #1 ]]]],
     LKEYS.KEYREL [ARG1 #1,
                   ARG2 #2 ]].

; in this case, the reflexive and the non-reflexive version
; reflect very different patterns:
; "det tilkommer meg penger"
io-presentational-synsem := double-np-presentational-synsem-sup &
  [ LOCAL.CAT ditrans-cat,
    LOCAL.CONT.HOOK hook,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], [] >].



subject-presentational-refl-synsem-sup := double-np-presentational-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS [FIRST [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
				 LOCAL.BND-RESP < [ ANAPH-INDX #4 ] >,
				 LOCAL.AGR.PNG #2  ], 
                         REST.FIRST [LOCAL.CONT.HOOK.INDEX #4,
				     LOCAL.AGR.PNG #2]] ].

; "det setter seg en gutt"
subject-presentational-refl-synsem := subject-presentational-refl-synsem-sup &
  [LOCAL.CAT ditrans-cat,
   LOCAL.CONT.HOOK hook,
   LOCAL.CAT.VAL.ICOMPS <>,
   LOCAL.CAT.VAL.COMPS <[], []>].


; "det oppholder seg en gutt under trappen/her"
subject-locobl-presentational-refl-synsem := subject-presentational-refl-synsem-sup &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.KEY-SPEC #1,
    LOCAL.CAT.VAL.ICOMPS <>,
    LOCAL.CAT.VAL.COMPS <[], [LOCAL.CONT.HOOK.INDEX #3], 
			 [LOCAL.CONT.HOOK.LTOP #2,
                           LOCAL.CONT.HOOK.XARG #3,
                           LOCAL.CAT.HEAD prep-or-adv & [ SELECTED -,
                                                          KEYS.KEY #1],
                           LOCAL.CONT.HOOK.INDEX[SORT non-fix-point,
                                                 ROLE xdim-to-xdim-spatial]]>,
    LKEYS.KEYREL.ARGX #2 ].


; LH 260411 For 'det smyger seg en mann' (for 'det smyger seg en mann ut')
; TODO: define the directionality of the presented item: we cannot simply add 'subject-dir-presentational-synsem' (see above) as a further subtype.
subject-dir-presentational-refl-synsem := subject-presentational-refl-synsem-sup &
 [ LOCAL.CONT.HOOK dir-hook,
   LOCAL.CONT.HOOK.DIRARG #1,
   LKEYS.KEYREL.ARG1 #1,
   LOCAL.CAT.VAL.ICOMPS <>,
   LOCAL.CAT.VAL.COMPS <[], []> ].


;presentational-synsem-2
subject-presentational-secpred-refl-dir-synsem := presentational-synsem-2 &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CONT.HOOK.LTOP #ltop,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ],
                            LOCAL.BND-MOUNTABLE < [ ANAPH-INDX #4 ] >,
			    LOCAL.CONT.HOOK.INDEX #3,
                            LOCAL.AGR.PNG #2  ], 
                          [ LOCAL.CONT.HOOK.LTOP #ltop,
			    LOCAL.CONT.HOOK.XARG #4,
                           LOCAL.CAT.HEAD prep-or-adv & [ KEYS.KEY dir ]], 
                          [LOCAL [CAT.HEAD.DEF -,
                                  CAT.HEAD.PRESENTED +,
                                  DERIVED-HEAD -],
                           LOCAL.CONT.HOOK.INDEX #4,
                           LOCAL.AGR.PNG #2] >,
    LOCAL.CAT.VAL.ICOMPS <>,
    LKEYS.KEYREL.ARG1 #4,
    LKEYS.KEYREL.ARG2 #3,
    LOCAL.CONT.HOOK.VARG #4  ].



;;;; "EXTRAPOSITION"- but no displacement
; forekomme, foresveve - "det forekommer meg at han kommer"
;presentational-synsem-2
io-epon-synsem-sup := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT ditrans-cat & [VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #2,
					    LOCAL.DERIVED-HEAD - ], 
                                          [LOCAL.CAT.HEAD glob-comp,
                                           LOCAL.CONT.HOOK.LTOP #1] >,
                              VAL.ICOMPS <> ],
     LKEYS.KEYREL [ARG1 #1,
                   ARG2 #2 ]].

;presentational-synsem-2
io-epon-wh-synsem-sup := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT ditrans-cat & [VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #2,
					    LOCAL.DERIVED-HEAD - ], 
                                          [LOCAL.CAT.HEAD verb-all & [DECL -],
                                           LOCAL.CONT.HOOK.LTOP #1] >,
                              VAL.ICOMPS <> ],
     LKEYS.KEYREL [ARG1 #1,
                   ARG2 #2 ]].

io-epon-synsem := io-epon-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], [] >].

io-refl-epon-synsem := io-epon-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ]  ], [] >].

io-epon-wh-synsem := io-epon-wh-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING nontamed ], [] >].

io-refl-epon-wh-synsem := io-epon-wh-synsem-sup &
  [ LOCAL.CAT.VAL.COMPS < [ LOCAL.BINDING seg-bare & [ LEX-TAME + ]  ], [] >].

; det tar tre timer √• g√•
;presentational-synsem-2
meas-epon-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT ditrans-cat & [VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #2  & [ SORT measure-unit ]], 
                                          [LOCAL.CAT.HEAD infin-comp & [ TRANSPAR -,
                                                                         DECL +  ],
                                           LOCAL.CONT.HOOK.LTOP #1] >,
                              VAL.ICOMPS <>],
     LKEYS.KEYREL [ARG1 #1,
                   ARG2 #2 ]].

; det tar oss tre timer √• g√•
;presentational-synsem-2
meas-io-epon-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT [VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #3,
			      LOCAL.BINDING non-bound ], 
                            [ LOCAL.CONT.HOOK.INDEX #2  & [ SORT measure-unit ]], 
                            [LOCAL.CAT.HEAD infin-comp & [ TRANSPAR +,
                                                           DECL +  ],
                             LOCAL.CONT.HOOK.LTOP #1,
                             LOCAL.CONT.HOOK.XARG #3] >,
                VAL.ICOMPS <>],
     LKEYS.KEYREL [ARG1 #1,
                   ARG2 #2,
                   ARG3 #3]].


; forekomme, hende - "det hender at han kommer"
;presentational-synsem-2
epon-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT trans-cat & [VAL.COMPS < [LOCAL.CAT.HEAD fin-comp,
                                           LOCAL.CONT.HOOK.LTOP #1] > ],
;     LKEYS.KEYREL [ARG1 #1 ],
     LOCAL.CONT.RELS <! [ARG1 #1 ], [] !> ].

; LH 010511 for "det hjelper √• ..."
;presentational-synsem-2
epon-inf-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT trans-cat & [VAL.COMPS < [LOCAL.CAT.HEAD infin-comp & [TRANSPAR -],
                                           LOCAL.CONT.HOOK.LTOP #1] > ],
;     LKEYS.KEYREL [ARG1 #1 ],
     LOCAL.CONT.RELS <! [ARG1 #1 ], [] !> ].

;presentational-synsem-2
epon-particle-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CONT.HOOK.LTOP #ltop,
     LOCAL.CAT trans-cat & [VAL.COMPS < [LOCAL.CONT.HOOK.LTOP #ltop,
					 LOCAL.CAT[HEAD adv-reg &
						   [SELECTED +,
						   KEYS.KEY pcl ]]],
					 [LOCAL.CAT.HEAD glob-comp,
                                           LOCAL.CONT.HOOK.LTOP #1] > ],
 ;    LKEYS.KEYREL [ARG1 #1 ],
     LOCAL.CONT.RELS <! [ARG1 #1 ], [] !>].

epon-particle-DECL-synsem := epon-particle-synsem &
   [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD fin-comp] >].
epon-particle-inf-synsem := epon-particle-synsem &
   [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD infin-comp & [TRANSPAR -]] >].
epon-particle-interr-synsem := epon-particle-synsem &
   [ LOCAL.CAT.VAL.COMPS < [], [LOCAL.CAT.HEAD.DECL -] >].

;,
;			       LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #2

;presentational-synsem-2
epon-pp-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT  [VAL.COMPS < [LOCAL.CONT.HOOK.LTOP #1] >,
		 VAL.ICOMPS < [LOCAL.CONT.HOOK.LTOP #2,
			       LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD nominal,
;			       LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #2,
			       LOCAL.CAT.HEAD prep &  [SELECTED +,
						       KEYS.KEY fct-spec ]] >],
 ;    LKEYS.KEYREL [ARG1 #1,
;		   ARGOBLQ #2],
     LOCAL.CONT.RELS <! [ARG1 #1,
			 ARGOBLQ #2 ], [] !>].

#|
epon-pp-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT  [VAL.COMPS < [LOCAL.CONT.HOOK.LTOP #1] >,
		 VAL.ICOMPS < [LOCAL.CONT.HOOK.LTOP #2,
			       LOCAL.CAT.HEAD prep &  [SELECTED +,
						       KEYS.KEY fct-spec ]] >],
     LKEYS.KEYREL [ARG1 #1,
		   ARGOBLQ #2]].
|#

epon-decl-and-yn-pp-synsem := epon-pp-synsem &
   [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD glob-comp] > ].
epon-wh-pp-synsem := epon-pp-synsem &
   [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD verb-all & [DECL -]] > ].

;presentational-synsem-2
epon-pp-clause-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT  [VAL.ICOMPS < [LOCAL.CONT.HOOK.LTOP #2,
			       LOCAL.CAT.HEAD prep &  [SELECTED +,
						       KEYS.KEY fct-spec  ]] >,
	       	 VAL.COMPS < [LOCAL.CONT.HOOK.LTOP #1] >],
;     LKEYS.KEYREL [ARG1 #1,
;		   ARGOBLQ #2],
     LOCAL.CONT.RELS <! [ARG1 #1,
			 ARGOBLQ #2 ], [] !>].

epon-decl-and-yn-pp-clause-synsem := epon-pp-clause-synsem &
   [ LOCAL.CAT.VAL.ICOMPS < [LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD glob-comp] > ].
;for: v-intrOblExpn-oblYN_expnYN. ok
epon-decl-and-yn-decl-and-yn-pp-clause-synsem := epon-decl-and-yn-pp-clause-synsem &
   [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD glob-comp] > ].
;for: v-intrOblExpn-oblYN_expnWH. ok
epon-decl-and-yn-wh-pp-clause-synsem := epon-decl-and-yn-pp-clause-synsem &
   [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD verb-all & [DECL -]] > ].

epon-wh-pp-clause-synsem := epon-pp-clause-synsem &
   [ LOCAL.CAT.VAL.ICOMPS < [LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD verb-all & [DECL -]] > ].
;for: v-intrOblExpn-oblWH_expnYN. ok
epon-wh-decl-and-yn-pp-clause-synsem := epon-wh-pp-clause-synsem &
   [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD glob-comp] > ].
;for: v-intrOblExpn-oblWH_expnWH. ok
epon-wh-wh-pp-clause-synsem := epon-wh-pp-clause-synsem &
   [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD verb-all & [DECL -]] > ].

;presentational-synsem-2
epon-oblique-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT intrans-with-1icomps-pp-cat & [VAL.ICOMPS < [LOCAL.CAT[HEAD prep & [SELECTED +,
										   KEYS.KEY fct-spec  ],
								      QVAL.DOBJECT [LOCAL.CAT.HEAD glob-comp,
										    LOCAL.CONT.HOOK.LTOP #1]]]>],
     LKEYS.KEYREL [ARGoblq #1 ]].

; "det sp√∏rs om han kommer"
;presentational-synsem-2
epon-indirwhquest-synsem := presentational-synsem-2 &
   [ LOCAL.CONT.HOOK hook,
     LOCAL.CAT trans-cat & [VAL.COMPS < [LOCAL.CAT.HEAD.DECL -,
					 LOCAL.CONT.HOOK.LTOP #1] > ],
;     LKEYS.KEYREL [ARG1 #1 ],
     LOCAL.CONT.RELS <! [ARG1 #1 ], [] !>].


;;;; COPULA-LIKE SYNSEMS

; "at han kommer er fint", "√• komme er fint"
copula-adj-abs-with-nonepon-synsem := lex-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CAT.HEAD verb-or-comp,
                           LOCAL.CONT.HOOK.INDEX #5 & event-verb,
                           LOCAL.CONT.HOOK.LTOP #1,
                           LOCAL.AGR #7 ] >, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                             LOCAL.CONT.HOOK.LTOP #3,
                             LOCAL.CAT.HEAD prep-or-adj,
                             LOCAL.CONT.RELS.LIST.FIRST adj_rel,
                             LKEYS.KEYREL.ARG1 #1,
                             LOCAL.AGR #7 ] >],
    LKEYS.KEYREL.ARG1 #3 ].

; these subtypes reflect a selection really done by the adjective. But since
; adj does not syntactically select for a subject, it has to 'commission'
; that selection to the copula, of which the adj itself is a COMPS                    
copula-adj-abs-with-nonepon-decl-synsem := copula-adj-abs-with-nonepon-synsem & 
  [ LOCAL.CAT.VAL [ COMPS < [LOCAL.CAT.HEAD.KEYS.KEY adj-decl-selct,
                             LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.DECL +] >,
                    SUBJ < [LOCAL.CAT.HEAD.DECL + ]> ]].
                    
copula-adj-abs-with-nonepon-quest-synsem := copula-adj-abs-with-nonepon-synsem & 
  [ LOCAL.CAT.VAL [ COMPS < [LOCAL.CAT.HEAD.KEYS.KEY adj-quest-selct,
                             LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD.DECL - ] >,
                    SUBJ < [LOCAL.CAT.HEAD.DECL - ]> ] ].
 
; v√¶re, bli - "han er syk"
;removed  LOCAL.CAT.VAL.COMPS.NON-LOCAL.SLASH <! !> , to enable "hvor gammel er du?"
copula-standard-synsem := intrans-secpred-rais-from-nonverbal-arg1-synsem & 
  [ LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX ref-ind,
			    LOCAL.CAT.HEAD.EXPLETIVE -]>, 
                    COMPS < [ LOCAL.CONT.HOOK.INDEX super-event,
                              LOCAL.CAT.HEAD prep-or-adj & [KEYS.KEY propt,
							    WEAK -]] >]].

copula-predparticle-synsem := intrans-secpred-rais-from-nonverbal-arg1-synsem & 
  [ LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX ref-ind]>, 
                    COMPS < [ LOCAL.CAT.HEAD som-or-for & [KEYS.KEY predcomp-n ]] >]].
; ,
;                              NON-LOCAL.SLASH <! !> 

;,
;			    LOCAL.CAT.HEAD.EXPLETIVE -
copula-locpp-synsem :=  arg1-predicative-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & ref-ind]>, 
                    COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                              LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.KEYS.KEY plainnoun,
                              LOCAL.CAT.HEAD prep & [KEYS.KEY index-sit1]  ] >]].
;,
copula-dirpp-synsem :=  arg1-predicative-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & ref-ind,
			    LOCAL.CAT.HEAD.EXPLETIVE -]>, 
                    COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                              LOCAL.CAT.HEAD prep & [KEYS.KEY dir]  ] >]].
;,
;    NON-LOCAL.SLASH <!!>

copula-predprtcl-synsem :=  arg1-predicative-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & ref-ind,
			    LOCAL.CAT.HEAD.EXPLETIVE -]>, 
                    COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                              SYNSEM.LOCAL.CAT.HEAD som-or-for & [KEYS.KEY predcomp-n ]  ] >]].
; ,
;    NON-LOCAL.SLASH <!!>
;LOCAL.CONT.HOOK.XARG #5,

copula-locpp-with-nonepon-synsem :=  arg1-predicative-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.QVAL.SUBJECT [LOCAL.CAT.HEAD verb-or-comp,
			    LOCAL.CONT.HOOK.INDEX #5], 
    LOCAL.CAT.QVAL.PREDIC [LOCAL.CAT.HEAD prep & [KEYS.KEY index-sit1],
			   LOCAL.CONT.HOOK.XARG #5]].
; ,
;                   COMPS < [ LOCAL.CAT.HEAD prep & [KEYS.KEY index-sit1],
;			      LOCAL.CONT.HOOK.XARG #5] >],

;    NON-LOCAL.SLASH <!!>



copula-locadv-synsem :=  arg1-predicative-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT intrans-ncomps-secpred-cat,
    LOCAL.CAT.VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #5 & ref-ind,
			    LOCAL.CAT.HEAD.EXPLETIVE -]>, 
                    COMPS < [ LOCAL.CONT.HOOK.XARG #5,
                              LOCAL.CAT.HEAD adv-reg & [KEYS.KEY index-sit]  ] >]].




; v√¶re_abs  - "det er fint i Finnmark"
;                   COMPS < [ LOCAL.CONT.HOOK.XARG #5 & expl-ind,
copula-standard-abs-synsem := intrans-secpred-rais-from-nonverbal-arg1-synsem & 
  [ LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #5,
			    LOCAL.CAT.HEAD.EXPLETIVE +]>, 
                   COMPS < [ LOCAL.CONT.HOOK.XARG #5 & ref-ind,
                             LOCAL.CONT.HOOK.INDEX super-event,
                              LOCAL.CAT.HEAD prep-or-adv & [ KEYS.KEY index-sit1 ] ] >]].

copula-tough-abs-synsem := intrans-secpred-rais-from-nonverbal-arg1-synsem & 
  [ LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [ SUBJ < [LOCAL.CONT.HOOK.INDEX #5,
			    LOCAL.CAT.HEAD.EXPLETIVE -]>,                    
		    COMPS < [ LOCAL.CONT.HOOK.XARG #5 & ref-ind,
                             LOCAL.CONT.HOOK.INDEX super-event,
                              LOCAL.CAT.HEAD adj & [ KEYS.KEY absadj0-tough ] ] >]].

; v√¶re_5 - "han er en gutt", "han er gutten"
; the DERIVED-HEAD restr in order to avoid "er syk" handled by this rule
; (but it will take "er en syk", since teh specification is then embedded)
; lhsept2010: shifted the number identity req over to 'v-copIdN'
; 170811: and back here again

;,
;    NON-LOCAL.SLASH <!!>
#|
copula-nom-synsem := trans-arg1-2-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #1 & ref-ind] >,
		    COMPS < [ LOCAL.CAT.HEAD nominal,
                              LOCAL.CONT.HOOK.INDEX #1,
                              LOCAL.DERIVED-HEAD - ] >]].
|#

copula-nom-synsem := trans-arg1-2-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX ref-ind,
			    LOCAL.CAT.HEAD.EXPLETIVE -] >,
		    COMPS < [ LOCAL.CAT.HEAD nominal,
                              LOCAL.CONT.HOOK.INDEX ref-ind,
                              LOCAL.DERIVED-HEAD - ] >],
    NON-LOCAL.SLASH 0-dlist ].

copula-clause-synsem := trans-subord-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [ COMPS < [ LOCAL.CAT.HEAD comp,
                              LOCAL.CONT.HOOK.INDEX event,
                              LOCAL.DERIVED-HEAD - ] >],
    NON-LOCAL.SLASH <!!>].

; TODO: too strong with INV, rather be a ban against
copula-absinf-synsem := trans-absinfsubord-synsem & 
  [ LOCAL.CAT.HEAD copula  & [INV -] ].

copula-arg1absinf-absinf-synsem := trans-arg1absinf-absinfsubord-synsem & 
  [ LOCAL.CAT.HEAD copula  & [INV -]].

copula-indirwhquest-synsem := trans-indirwhquest-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula ].

copula-indir-y-n-quest-synsem := trans-indir-y-n-quest-synsem & 
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula ].
; ,
;    NON-LOCAL.SLASH <!!>

copula-noun-with-sudecl-nonepon-synsem := lex-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CAT.HEAD fin-comp & [DECL +],
                          LOCAL.CONT.HOOK.LTOP #1 ] >, 
                   COMPS < [ LOCAL.CAT.HEAD noun,
			     LOCAL.CONT.HOOK.INDEX #2] >],
    LKEYS.KEYREL.ARG1 #1,
    LKEYS.KEYREL.ARG2 #2].

copula-noun-with-suYN-nonepon-synsem := lex-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CAT.HEAD fin-comp & [DECL -],
                          LOCAL.CONT.HOOK.LTOP #1 ] >, 
                   COMPS < [ LOCAL.CAT.HEAD noun,
			     LOCAL.CONT.HOOK.INDEX #2] >],
    LKEYS.KEYREL.ARG1 #1,
    LKEYS.KEYREL.ARG2 #2].

copula-noun-with-suWH-nonepon-synsem := lex-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CAT.HEAD verb-all & [DECL -],
                          LOCAL.CONT.HOOK.LTOP #1 ] >, 
                   COMPS < [ LOCAL.CAT.HEAD noun,
			     LOCAL.CONT.HOOK.INDEX #2] >],
    LKEYS.KEYREL.ARG1 #1,
    LKEYS.KEYREL.ARG2 #2].

copula-noun-with-suabsinf-nonepon-synsem := lex-synsem &
  [ LOCAL.CONT.HOOK hook,
    LOCAL.CAT.HEAD copula,
    LOCAL.CAT.VAL [SUBJ < [LOCAL.CAT.HEAD infin-comp & [TRANSPAR -,
							DECL +,
							KEYS.KEY infinit-comp-arb],
                          LOCAL.CONT.HOOK.LTOP #1 ] >, 
                   COMPS < [ LOCAL.CAT.HEAD noun,
			     LOCAL.CONT.HOOK.INDEX #2] >],
    LKEYS.KEYREL.ARG1 #1,
    LKEYS.KEYREL.ARG2 #2].


;;;;;;;; POSSIBLE SEMANTICALLY ENRICHED SYNSEMS, 

;; A. NOT BASED on predsort.tdl

intrans-arg1-nonorient := intrans-arg1-synsem &
  [ LKEYS.KEYREL non-oriented-svh-rel ].

intrans-arg1-locomotion := intrans-arg1-synsem &
  [ LKEYS.KEYREL locomotion-rel ].

intrans-arg1-pure-orientation := intrans-arg1-synsem &
  [ LKEYS.KEYREL pure-orientation-rel ].

; is actively used, in masc-dir-noun-lxm
; now included in lxm-type
;nounsynsem-arg0dir := lex-synsem &
;    [ LOCAL.CONT.HOOK.DIRARG #1,
;      LKEYS.KEYREL.ARG0 #1,
;      LOCAL.CAT.HEAD.KEYS.KEY dirnoun ].

; "se ut". "peke hitover"; used, but in standard gr not clear why
intrans-arg1orient-synsem := intrans-arg1dir-synsem &
    [ LOCAL.CAT.VAL.ICOMPS <>,
      LKEYS.KEYREL i-pure-orientation-rel ].

; the class of transitive 'measuring-out-event' verbs
trans-arg1-2tel := trans-arg1-2-synsem.

trans-arg1dir-2length-synsem := trans-arg1-2-synsem-sup &
  [ LOCAL.CONT.HOOK.DIRARG #1,
    LKEYS.KEYREL.ARG1 #1,
    LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX.SORT length-unit,
                            LOCAL.CAT.HEAD.KEYS.KEY measnoun ]>].

trans-arg1-2ejection := trans-arg1-2-synsem &
  [ LKEYS.KEYREL ejection-rel ].




;; B.  BASED on predsort.tdl
; the 'i-SYNSEM' types

posture-synsem := intrans-arg1-synsem &
  [ LKEYS.KEYREL i-posture-svh-rel ].
arrow-pointing-synsem := intrans-arg1dir-synsem &
  [ LKEYS.KEYREL i-pure-orientation-rel ].
road-going-synsem := intrans-arg1dir-synsem &
  [ LKEYS.KEYREL i-path-constellation-rel ].
tour-going-synsem := intrans-arg1dir-synsem &
  [ LKEYS.KEYREL i-locomotion-development-rel ].
locomotion-synsem := intrans-arg1dir-synsem &
  [ LKEYS.KEYREL i-locomotion-rel ].

directing-arrow-synsem := trans-arg1-2dir-synsem &
  [ LKEYS.KEYREL i-arg12-pure-orientation-rel ].
directing-line-synsem := trans-arg1-2dir-synsem &
  [ LKEYS.KEYREL i-arg12-path-constellation-rel ].
directing-tour-synsem := trans-arg1-2dir-synsem &
  [ LKEYS.KEYREL i-arg12-locomo-conduction-rel ].
ejection-synsem := trans-arg1-2dir-synsem &
  [ LKEYS.KEYREL i-arg12-locomotion-rel ].

line-follow-line-synsem := trans-arg1-2dir-synsem &
  [ LKEYS.KEYREL i-arg12-parallel-double-path-constellation-rel ].
line-crossing-line-synsem := trans-arg1-2dir-synsem &
  [ LKEYS.KEYREL i-arg12-nonparallel-double-path-constellation-rel ].
begleiten-synsem := trans-arg1-2dir-synsem &
  [ LKEYS.KEYREL i-arg12-parallel-double-locomotion-rel ].
crossing-locomotors-synsem := trans-arg1-2dir-synsem &
  [ LKEYS.KEYREL i-arg12-nonparallel-double-locomotion-rel ].

init-synsem := intrans-arg1-synsem &
  [ LKEYS.KEYREL i-arg1-init-rel ].
init-und-synsem := trans-arg1-2-synsem &
  [ LKEYS.KEYREL i-arg12-init-und-rel ].
init-dat-synsem := trans-arg1-2-synsem &
  [ LKEYS.KEYREL i-arg12-init-dat-rel ].
init-und-dat-synsem := ditrans-arg1-2-3-synsem &
  [ LKEYS.KEYREL i-arg123-init-und-dat-rel ].
und-synsem := intrans-arg1-synsem &
  [ LKEYS.KEYREL i-arg1-und-rel ].
und-dat-synsem := trans-arg1-2-synsem &
  [ LKEYS.KEYREL i-arg12-und-dat-rel ].
dat-synsem := intrans-arg1-synsem &
  [ LKEYS.KEYREL i-arg1-dat-rel ].

init-locomotion-synsem := intrans-arg1dir-synsem &
  [ LKEYS.KEYREL i-arg1-init-locomotion-rel ].

;;; QVAL
qval-valence := avm &
  [ SUBJECT synsem ].

intrans-qval-sup := qval-valence.
intrans-qval := intrans-qval-sup.

trans-qval-sup := qval-valence &
  [ DOBJECT synsem & [ LOCAL.CAT.HEAD.ACCUSATIVE + ] ].

trans-qval := trans-qval-sup.

ditrans-qval := trans-qval &
  [ IOBJECT.LOCAL [ CAT.HEAD.ACCUSATIVE + ] ].

;; In secpred-constellations, if PREDIC is not vp/inf, then PIVOT will be
;; the ARG2 of the predicate serving as PREDIC. If PREDIC is vp/inf,
;; then the semantic role of the embedded V serving as PIVOT is whatever is
;; selected as SUBJECT of the vp/inf - can in principle be ARG1, ARG2 or ARG3
;; (if the VP is in passive form, for instance, it is not ARG1 even if the
;; verb is agentive).

secpred-qval := qval-valence &
  [ PREDIC.LOCAL.CAT.QVAL.SUBJECT.LOCAL [ CONT.HOOK.INDEX semarg ] ].

secpred2-qval := qval-valence &
  [ PREDIC2.LOCAL.CAT.QVAL.SUBJECT.LOCAL [ CONT.HOOK.INDEX semarg ] ].

intrans-secpred-qval := secpred-qval &
  [ SUBJECT #1,
    PREDIC.LOCAL.CAT.QVAL.SUBJECT #1 ].

intrans-doublesecpred-qval := intrans-secpred-qval & secpred2-qval &
  [ PREDIC2 synsem ].

trans-secpred-qval := secpred-qval & trans-qval-sup &
  [ DOBJECT.LOCAL.CONT.HOOK.INDEX #1,
    PREDIC.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1 ].

;trans2-secpred-qval := secpred-qval & trans-qval &
;  [ DOBJECT.LOCAL.CONT.HOOK.INDEX #1,
;    PREDIC.LKEYS.KEYREL.ARG1 #1 ].

trans2-secpred-qval := secpred-qval & trans-qval-sup &
  [ DOBJECT.LOCAL.CONT.HOOK.INDEX #1,
    PREDIC.LOCAL.CONT.HOOK.XARG #1 ].

with-obl-pp-qval := qval-valence &
  [ OBL1 [ LOCAL mod-local ] ].

with-2obl-pp-qval := with-obl-pp-qval &
  [ OBL2.LOCAL.CAT.HEAD prep-or-adv ].

intrans-with-obl-pp-qval := intrans-qval-sup & with-obl-pp-qval.

intrans-with-2obl-pp-qval := intrans-qval-sup & with-2obl-pp-qval.

trans-with-obl-pp-qval := trans-qval-sup & with-obl-pp-qval.

trans-with-2obl-pp-qval := trans-qval-sup & with-2obl-pp-qval.

ditrans-with-obl-pp-qval := ditrans-qval & with-obl-pp-qval.



;;;;;
;;;;;   VALENCE
;;;;;

;empty-ncomps-val := valence &
;  [ COMPS < > ].

;subj-empty-ncomps-val := empty-ncomps-val &
;  [ SUBJ < [] > ].

;v-val := valence &
;  [ ICOMPS list ].

;absolute-v-val := v-val & empty-ncomps-val.

empty-icomps-v-val := valence &
  [ ICOMPS < > ].

intrans-v-val := valence &
  [ COMPS < > ].

trans-v-val := valence &
  [ COMPS < [], ... > ].

; TODO: something needed to exclude adverbs from serving as second object - 'kastet den ut' gets 6 parses with that.
ditrans-v-val := valence &
  [ COMPS < [ LOCAL[ CONT.HOOK.INDEX ref-ind ] ], [], ... > ].

;;;;;
;;;;;   CAT
;;;;;

qval-cat := cat &
  [ QVAL qval-valence ].

;; The following cat-types link the synsems on the valence lists to functional
;; categories. For example is the synsem on the SUBJ list of verbs linked to 
;; the functional category SUBJECT in 'v-cat'. 
;; The cat-types also carry information about the length of the valence lists.

lex-cat := qval-cat &
  [ VAL.SUBJ < #1 >,
    QVAL.SUBJECT #1 ].

p-cat := lex-cat &
  [ VAL.COMPS < #1 >,
    QVAL.DOBJECT #1 ].

empty-icomps-cat := lex-cat &
  [ VAL.ICOMPS < > ].

icomps-cat := lex-cat &
  [ VAL.ICOMPS <  #1 >,
    QVAL.OBL1 #1 ].

intrans-cat := lex-cat &
  [ VAL intrans-v-val,
    QVAL intrans-qval-sup ].

intrans-empty-icomps-cat := intrans-cat & empty-icomps-cat &
  [ QVAL intrans-qval ].

trans-cat := lex-cat &
  [ VAL.COMPS < #1, ... >,
    QVAL.DOBJECT #1,
    VAL trans-v-val,
    QVAL trans-qval-sup ].

trans-empty-icomps-cat := trans-cat & empty-icomps-cat.

trans-1ncomps-empty-icomps-cat := trans-empty-icomps-cat &
  [ VAL.COMPS < [] > ].


ditrans-cat := lex-cat &
  [ QVAL [ DOBJECT #1,
           IOBJECT #2 ],
    VAL ditrans-v-val &
         [ COMPS < #2, #1 > ] ].

ditrans-empty-icomps-cat := ditrans-cat & 
                            empty-icomps-cat &
  [ VAL.COMPS < [], [] > ].

;; "renne halvfull"

intrans-secpred-cat := lex-cat &
  [ VAL valence,
    QVAL intrans-secpred-qval ].

intrans-ncomps-secpred-cat := intrans-secpred-cat &
  [ VAL.COMPS < #1 >,
    QVAL intrans-secpred-qval & [ PREDIC #1 ] ].

; for "se syk[PREDIC1] ut[PREDIC2]"
intrans-ncomps-doublesecpred1-cat := intrans-secpred-cat &
  [ VAL.COMPS < #1, #2 >,
    QVAL intrans-doublesecpred-qval & [ PREDIC #1,
                                        PREDIC2 #2 ] ].

; for "se  ut[PREDIC2] til √• besvime[PREDIC1]"
intrans-ncomps-doublesecpred2-cat := intrans-secpred-cat &
  [ VAL.COMPS < #2, #1 >,
    QVAL intrans-doublesecpred-qval & [ PREDIC #1,
                                        PREDIC2 #2 ] ].

;intrans-icomps-secpred-cat := intrans-secpred-cat &
;  [ VAL.ICOMPS < #1 >,
;    QVAL intrans-secpred-qval & [ PREDIC #1 ] ].

trans-secpred-cat := trans-cat &
  [ VAL valence,
    QVAL trans-secpred-qval].

trans-invertsecpred-cat := lex-cat &
  [ VAL.COMPS < #2, #1 >,
    QVAL trans2-secpred-qval & [ DOBJECT #1,
                                 PREDIC #2 ]].



;; "sparke d√∏ren l√∏s"

trans-ncomps-secpred-cat := trans-secpred-cat &
  [ QVAL trans-secpred-qval & 
         [ PREDIC #2 ],
    VAL trans-v-val &
         [ COMPS < [ ], #2  > ] ].

;trans-icomps-secpred-cat := trans-secpred-cat &
;  [ QVAL trans-secpred-qval & 
;         [ PREDIC #2 ],
;    VAL trans-v-val &
;         [ COMPS < [ LOCAL [ CONT.HOOK.INDEX ref-ind ] ] >,
;           ICOMPS < #2  > ] ].

trans-ncomps-secpred-empty-icomps-cat := trans-ncomps-secpred-cat &
                                           trans-empty-icomps-cat.

trans-nosecpred-empty-icomps-cat :=  trans-1ncomps-empty-icomps-cat.

with-icomps-pp-cat := lex-cat &
  [ VAL.ICOMPS < #1, ...>,
    QVAL with-obl-pp-qval & [ OBL1 #1 & [ LOCAL.CAT [ HEAD prep-ultra,
                                                      VAL.COMPS <> ] ] ] ].

intrans-with-icomps-pp-cat := with-icomps-pp-cat & intrans-cat &
  [ QVAL with-obl-pp-qval ].

with-1icomps-pp-cat := with-icomps-pp-cat &
  [ VAL.ICOMPS < [] > ].

intrans-with-1icomps-pp-cat := with-1icomps-pp-cat & 
                               intrans-with-icomps-pp-cat.

with-2icomps-pp-cat := with-icomps-pp-cat &
  [ VAL.ICOMPS < [], #1 >,
    QVAL.OBL2 #1 ].

intrans-with-2icomps-pp-cat := with-2icomps-pp-cat & 
                               intrans-with-icomps-pp-cat.

trans-with-icomps-pp-cat := trans-cat & with-icomps-pp-cat.

trans-with-1icomps-pp-cat := trans-with-icomps-pp-cat & 
                               with-1icomps-pp-cat &
  [ VAL.COMPS < [] > ].

trans-with-2icomps-pp-cat := trans-with-icomps-pp-cat & 
                               with-2icomps-pp-cat &
  [ VAL.COMPS < [] > ].

ditrans-with-icomps-pp-cat := ditrans-cat & with-icomps-pp-cat.
;  [ VAL.ICOMPS < #1, ...>,
;    QVAL ditrans-with-obl-pp-qval & [ OBL1 #1 ] ].

ditrans-with-1icomps-pp-cat := ditrans-with-icomps-pp-cat &
                                         with-1icomps-pp-cat &
  [ VAL.COMPS < [], [] > ].

; presumably not needed
;ditrans-with-2icomps-pp-cat := ditrans-with-icomps-pp-cat &
;                                         with-2icomps-pp-cat &
;  [ VAL.COMPS < [], [] > ].

;ditrans-with-2ncomps-1icomps-pp-cat := ditrans-cat &
;                                         with-1icomps-pp-cat &
;  [ VAL.COMPS < [], [] > ].


;;;;;;;;;;;;;; LEXICAL RULES
#|
; SYNSEM.LOCAL.OBJ-DEL-APPLIED + is in order to avoid feeding with obj-del rules
passive-lexeme := const-ltol-rule & verb-general-lexeme &
[ INFLECTION #infl,
  SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VOICE passive,
                                       KEYS.KEY mainvb ],
                         VAL [ SUBJ < canonical-synsem & [ LOCAL.CONT.HOOK.INDEX #1] >,
                               SPR #spr ] ],
                   CONT.HOOK.XARG #1,
                   CONT.HOOK.VARG #4 ],
           LKEYS #keys,
           NON-LOCAL #non-local ],
	   SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
  ARGS < [ INFLECTION #infl,
           SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VOICE active ],
                                  VAL [ SUBJ < canonical-synsem &
                                               [LOCAL.CONT.HOOK.INDEX #4  ] >,
                                        SPR #spr ] ] ],
                    LKEYS #keys,
                    NON-LOCAL #non-local ],
	   SYNSEM.LOCAL.OBJ-DEL-APPLIED - ] >,
  C-CONT.RELS <! !> ].
|#

; SYNSEM.LOCAL.OBJ-DEL-APPLIED + is in order to avoid feeding with obj-del rules
; this is a verb-lexeme, but cannot inherit from 'verb-general-lexeme' because this does not allow any C-CONT RELS addidions
passive-lexeme := const-ltol-rule & lbl-ltop-lex-item-3rel &
[ INFLECTION #infl,
  SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VOICE passive,
                                       KEYS.KEY mainvb ],
                         VAL [ SUBJ < canonical-synsem & [ LOCAL.CONT.HOOK.INDEX #1] >,
                               SPR #spr ] ],
                   CONT.HOOK.XARG #1,
                   CONT.HOOK.VARG #4,
		   CONT.HCONS #hcons ],
           LKEYS #keys,
           NON-LOCAL #non-local ],
	   SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
   SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    SYNSEM.LOCAL.HEAD-SUBJ-APPLIED -,
    SYNSEM.LOCAL.COMPS-BEGUN -,				;; Added to avoid s-final. EAA030811
    SYNSEM.BIND unbnd,
  ARGS < [ INFLECTION #infl,
           SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VOICE active ],
                                  VAL [ SUBJ < canonical-synsem &
                                               [LOCAL.CONT.HOOK.INDEX #4  ] >,
                                        SPR #spr ] ] ],
                    LKEYS #keys,
                    NON-LOCAL #non-local ],
	   SYNSEM.LOCAL.OBJ-DEL-APPLIED - ] >,
  C-CONT.RELS <! indef-q-rel & [ PRED "_udef_q_rel",
				 ARG0 #4,
				 RSTR #5 ], pron_rel & [ PRED "_understood-agent_rel",
							 LBL #6,
							 ARG0 #4 ] !>,
  C-CONT.HCONS #hcons & <! [ HARG #5,
			     LARG #6] !> ].

                                              
passive-ncomps1-sup := passive-lexeme &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #5,
                                    LOCAL.CAT.HEAD nominal ] >,
                           COMPS #1,
                           ICOMPS #3 ],
;    SYNSEM.LOCAL.CONT.HOOK [XARG #5],
    SYNSEM.LOCAL.CAN-PASTPART-ADJ #bool,
    SYNSEM.NON-LOCAL.SLASH <! !>,
    ARGS < [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX event-or-ref-index ] >,
                                    COMPS < [ LOCAL.CONT.HOOK.INDEX #5,
                                              LOCAL.CAT.HEAD nominal,
                                              LOCAL.BINDING.BOUND - ]. #1 >,
                                    ICOMPS #3 ],
             SYNSEM.LOCAL.CAN-PASTPART-ADJ #bool ] >].

passive-ncomps1 := passive-ncomps1-sup &
  [ SYNSEM.LOCAL.CONT.HOOK hook,
    ARGS < [SYNSEM.LOCAL.CONT.HOOK hook] > ].

passive-dir-ncomps1 := passive-ncomps1-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.DIRARG #5,
    ARGS < [SYNSEM.LOCAL.CONT.HOOK dir-hook & [ DIRARG #5 ]] > ].

; make a 'passive-dir-ncomps1' - needs some VARG regulations.
; same for subject-dir-presentational.
; 'ut' may need some tuning also

passive-ncomps2 := passive-lexeme &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #6,
                                    LOCAL.CAT.HEAD nominal  ] >,
                           COMPS < #5 . #1 >,
                           ICOMPS #3 ],
    SYNSEM.LOCAL.CONT.HOOK.XARG #6,
    SYNSEM.LOCAL.CAN-PASTPART-ADJ -,
    SYNSEM.LOCAL.CONT.HOOK hook,
    ARGS < [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX event-or-ref-index ] >,
                                    COMPS < #5 . < [ LOCAL.CONT.HOOK.INDEX #6,
                                                     LOCAL.CAT.HEAD nominal ] . #1 > >,
                                    ICOMPS #3],
             SYNSEM.LOCAL.CONT.HOOK hook ]   > ].

;  [ SYNSEM  [ LOCAL.CAT trans-cat & [QVAL [SUBJECT.LOCAL [ CAT.HEAD expl-pron,
;                                                           CONT.HOOK.INDEX #3 & expl-ind  ],
                                           
subject-presentational-passive-sup := passive-lexeme &
  [ SYNSEM  [ LOCAL.CAT trans-cat & [QVAL [SUBJECT.LOCAL [ CAT.HEAD expl-pron,
                                                           CONT.HOOK.INDEX #3 & ref-ind  ],
                                           DOBJECT.LOCAL [CAT.HEAD.DEF -,
;                                                          CAT.HEAD.PRESENTED +,
                                                          CONT.HOOK.INDEX #2]],
                                     VAL.COMPS < #dobject & [] >,
                                     VAL.ICOMPS #icomps  ],
              LOCAL.CONT.HOOK.XARG #3 ],
    SYNSEM.LOCAL.CAN-PASTPART-ADJ -,
    ARGS < [ SYNSEM.LOCAL.CAT [ VAL [ COMPS < [ LOCAL.CONT.HOOK.INDEX ref-ind ] >,
                                      ICOMPS #icomps ],
                                QVAL.DOBJECT #dobject ],
             SYNSEM.LKEYS.KEYREL [ARG1 #1,
                                  ARG2 #2],
             SYNSEM.LOCAL.CONT.HOOK.XARG #1 ]>].

subject-presentational-passive := subject-presentational-passive-sup &
  [ ARGS < [SYNSEM.LOCAL.CONT.HOOK hook] > ].
subject-dir-presentational-passive := subject-presentational-passive-sup &
  [ SYNSEM.LOCAL.CONT.HOOK.DIRARG #5,
    ARGS < [SYNSEM.LOCAL.CONT.HOOK dir-hook & [ DIRARG #5 ]] > ].



; be revised on model of subject-presentational-passive
; NB replace 'passive-lexeme' here to comply with new def of impersonal-presentational-synsem
#|
impersonal-presentational-passive := passive-lexeme &
  [ SYNSEM  impersonal-presentational-synsem &
            [ LOCAL.CAT [ VAL [ COMPS #ncomps,
                                ICOMPS #icomps ],
                          QVAL.DOBJECT #dobject ] ],
    ARGS < [ SYNSEM.LOCAL.CAT [ VAL [ COMPS #ncomps,
                                      ICOMPS #icomps ],
                                QVAL.DOBJECT #dobject ] ] > ].
|#

impersonal-presentational-passive := const-ltol-rule & lbl-ltop-lex-item-4rel &
  [ INFLECTION #infl,
    SYNSEM  [ LOCAL [ CAT [ HEAD verb & [ VOICE passive,
                                       KEYS.KEY mainvb ],
                         VAL [ SUBJ < canonical-synsem & [ LOCAL.CONT.HOOK.INDEX #1] >,
                               SPR #spr ] ],
                   CONT.HOOK.XARG #1,
                   CONT.HOOK.VARG #4,
		   CONT.HCONS #hcons ],
           LKEYS #keys,
           NON-LOCAL #non-local ],
    SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
    SYNSEM.LOCAL.CAT.HEAD verb-all,
    SYNSEM.LOCAL.CAT lex-cat & [VAL [ SUBJ < [] >,
                                       SPR list,
                                       SPEC <>]],
    SYNSEM.LKEYS.KEYREL event-relation,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.REL-CL-SOM-INIT -,
    SYNSEM.LOCAL.HEAD-SUBJ-APPLIED -,
    SYNSEM.LOCAL.COMPS-BEGUN -,				;; Added to avoid s-final. EAA030811
    SYNSEM.BIND unbnd,
    SYNSEM.LOCAL.CAN-PASTPART-ADJ -,
    SYNSEM  lex-synsem &
            [ LOCAL.CAT lex-cat & [QVAL.SUBJECT [ LOCAL [ CAT.HEAD expl-pron,
                                                CONT [ HOOK.INDEX #10 & ref-ind ] ] ]],
	      LOCAL.CONT.HOOK.XARG #10,
	      LOCAL.CONT.HOOK.LTOP #20,
	      LOCAL.CAT [ VAL [ COMPS #ncomps,
;				COMPS <>,
                                ICOMPS #icomps ],
                          QVAL.DOBJECT #dobject ] ],
    ARGS < [ INFLECTION #infl,
	     SYNSEM [ LOCAL [ CAT [ HEAD verb & [ VOICE active ],
				    VAL [ SUBJ < canonical-synsem &
                                               [LOCAL.CONT.HOOK.INDEX #4  ] >,
					  SPR #spr ] ] ],
		      LKEYS #keys,
		      NON-LOCAL #non-local ],
	     SYNSEM.LOCAL.CAT [ VAL [ COMPS #ncomps,
                                      ICOMPS #icomps ],
                                QVAL.DOBJECT #dobject & [LOCAL.CAT.HEAD.DEF -,
							 LOCAL.CAT.HEAD.DEFINITE -]],
	     SYNSEM.LOCAL.OBJ-DEL-APPLIED - ] >,
    C-CONT.RELS <! indef-q-rel & [ PRED "_udef_q_rel",
				   ARG0 #4,
				   RSTR #5 ], pron_rel & [ PRED "_understood-agent_rel",
							   LBL #6,
							   ARG0 #4 ], [PRED "intro-sit-rel",
									   ARG1 #10,
									   ARG2 #20] !>,
    C-CONT.HCONS #hcons & <! [ HARG #5,
			       LARG #6] !>  ].

; be revised on model of subject-presentational-passive
;                                                           CONT.HOOK.INDEX #3 & expl-ind  ],
io-presentational-passive := passive-lexeme &
  [ SYNSEM  [ LOCAL.CAT ditrans-cat & [QVAL [SUBJECT.LOCAL [ CAT.HEAD expl-pron,
                                                           CONT.HOOK.INDEX #3 & ref-ind  ],
                                           DOBJECT.LOCAL [CAT.HEAD.DEF -,
                                                          CONT.HOOK.INDEX #2,
                                                          CAT.HEAD.PRESENTED +],
                                           IOBJECT.LOCAL [CONT.HOOK.INDEX #4]],
                                     VAL.COMPS < #iobject & [], #dobject & [] >,
                                     VAL.ICOMPS #icomps  ],
              LOCAL.CONT.HOOK.XARG #3 ],
    SYNSEM.LOCAL.CAN-PASTPART-ADJ -,
    ARGS < [ SYNSEM.LOCAL.CAT [ VAL [ COMPS < #iobject & [ LOCAL.CONT.HOOK.INDEX #4 ], #dobject & [ LOCAL.CONT.HOOK.INDEX #2 ] >,
                                      ICOMPS #icomps ],
                                QVAL.IOBJECT #iobject,
                                QVAL.DOBJECT #dobject ],
             SYNSEM.LKEYS.KEYREL [ARG1 #1,
                                  ARG2 #2,
                                  ARG3 #4],
             SYNSEM.LOCAL.CONT.HOOK.XARG #1 ]>].




passive-obl := passive-lexeme &
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #5 & ref-ind,
                                    LOCAL.CAT.HEAD nominal ] >,
                           ICOMPS < [LOCAL.CAT.VAL.COMPS <>,
                                     LOCAL.CAT.HEAD prep & [ KEYS.KEY #4 & fct-pass-spec ],
                                     LOCAL.BINDING.BOUND -,
                                     LOCAL.DERIVED-HEAD +,
                                     LOCAL.CONT.HOOK.VARG #5,
                                     LOCAL. CONT.HOOK.LTOP #lbl]. #1 >,
                           COMPS #3 ],
    SYNSEM.LOCAL.CONT.HOOK.XARG #5,
    SYNSEM.LOCAL.CAN-PASTPART-ADJ -,
    SYNSEM.NON-LOCAL.SLASH <! !>,
    ARGS < [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX event-or-ref-index ] >,
                                    ICOMPS < [LOCAL.CAT.QVAL.DOBJECT[ LOCAL.CONT.HOOK.INDEX #5],
                                              LOCAL.CAT.HEAD prep & [ KEYS.KEY #4 ],
                                              LOCAL.BINDING.BOUND -,
                                              LOCAL. CONT.HOOK.VARG #5,
                                              LOCAL. CONT.HOOK.LTOP #lbl ]. #1 >,
                                    COMPS #3 ]  ] >].

; to be constructed (shaped from an io and an obl version
;                                               CONT.HOOK.INDEX expl-ind  ],
presentational-obl-passive := passive-lexeme &
  [ SYNSEM  [ LOCAL.CAT [QVAL [SUBJECT.LOCAL [ CAT.HEAD expl-pron,
                                               CONT.HOOK.INDEX ref-ind  ],
                               OBL1[LOCAL.CAT.VAL.COMPS < [LOCAL.CONT.HOOK.INDEX #5] >,
                                    LOCAL.CAT.HEAD prep & [ KEYS.KEY #4 & fct-actv-spec ],
                                    LOCAL.BINDING.BOUND -]]],
              LOCAL.CAT.VAL.COMPS #3,
              LOCAL.CAT.VAL.ICOMPS #7],
    SYNSEM.NON-LOCAL.SLASH <! !>,                                   
    SYNSEM.LOCAL.CAN-PASTPART-ADJ -,
    ARGS < [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX event-or-ref-index ] >,
                                    ICOMPS < [LOCAL.CAT.QVAL.DOBJECT[ LOCAL.CONT.HOOK.INDEX #5],
                                              LOCAL.CAT.HEAD prep & [ KEYS.KEY #4 ],
                                              LOCAL.BINDING.BOUND - ] >,
                                    COMPS #3,
                                    ICOMPS #7]  ]>].


; most likely one needs a KEYS.KEY specification to restrict this to only be used in connection with pass-obl
; ,                      KEYS.KEY fct-pass-spec
prep-word-sel-red := reg-mod-lex-item & word-to-word-rule &
  [ SYNSEM arg2-qvalcomps-synsem & [LOCAL [CAT [HEAD #3 & prep-ultra & [ KEYS.KEY #4 ] ],
                                           XCAT [HEAD #3 ]]],
    SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    SYNSEM.LOCAL [ CONT.HOOK.VARG #2,
		   CONT.HOOK.LTOP #lbl],
    EXTRACTED-FROM -,
    SYNSEM.BIND unbnd,
    SYNSEM.LOCAL.CAT.HEAD [SELECTED +,
                           KEYS.KEY fct-pass-spec,
                           MOD < [ LOCAL.CONT.HOOK.INDEX.SORT referential-thing ]>],
    SYNSEM.LOCAL.DERIVED-HEAD +,
    ARGS < prep-word-sel & [ SYNSEM.LOCAL [ CONT.HOOK.VARG #2,
					    CONT.HOOK.LTOP #lbl ],
                             SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY #4 & fct-spec,
                             SYNSEM.LKEYS.KEYREL arg12-relation & [LBL #lbl,
								   ARG2 #2 ] ] >,
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !>  ].


; seemed necessary earlier on




obj-del-cum-dir-verb-lxm := verb-lexeme  & const-ltol-rule &
  [ SYNSEM lex-synsem & [LOCAL.CAT.HEAD verb],
    SYNSEM.LOCAL.CONT.HOOK.DIRARG #3,
    SYNSEM.LOCAL.CAT.VAL.SUBJ #2,
    SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
    DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    DTR.SYNSEM trans-arg1-2dir-synsem,
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #3 ] >,
    DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
    DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #2 & cons,
    DTR.SYNSEM.LOCAL.CONT.HOOK.DIRARG #3,
    DTR.SYNSEM.LOCAL.OBJ-DEL-APPLIED - ].


#|
obj-del-cum-dir-verb-lxm := verb-lexeme  & const-ltol-rule &
  [ SYNSEM lex-synsem & [LOCAL.CAT.HEAD verb],
    SYNSEM.LOCAL.CONT.HOOK.VARG #3,
    SYNSEM.LOCAL.CAT.VAL.SUBJ #2,
    SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CAT.HEAD prep-or-adv,
                                   LOCAL.CONT.HOOK.XARG #3 ] >,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    DTR.SYNSEM trans-arg1-2dir-synsem,
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #3 ] >,
    DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #2 & cons,
    DTR.SYNSEM.LOCAL.CONT.HOOK.VARG #3].
|#

obj-del-stnd-verb-lxm := verb-lexeme  & const-ltol-rule &
  [ SYNSEM lex-synsem & [LOCAL.CAT.HEAD verb],
    SYNSEM.LOCAL.CAT.VAL.SUBJ #2,
    SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #4,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
    DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [ LOCAL.CONT.HOOK.INDEX #3 & ref-ind,
				       LOCAL.CAT.HEAD nom,
				       LOCAL.BINDING.REFL-I - ] >,
    DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #2 & cons,
    DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #4,
    DTR.SYNSEM.LKEYS.KEYREL.ARG2 #3,
    DTR.SYNSEM.LOCAL.OBJ-DEL-APPLIED - ].

obj-del-ditr-verb-lxm := verb-lexeme  & const-ltol-rule &
  [ SYNSEM lex-synsem & [LOCAL.CAT.HEAD verb],
    SYNSEM.LOCAL.CAT.VAL.SUBJ #2,
    SYNSEM.LOCAL.CAT.VAL.COMPS < #4 >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS #4,
    SYNSEM.LOCAL.CONT.HCONS <! !>,
    SYNSEM.LOCAL.OBJ-DEL-APPLIED +,
    DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < #4, [ LOCAL.CONT.HOOK.INDEX #3 ] >,
    DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #2 & cons,
    DTR.SYNSEM.LOCAL.CAT.VAL.ICOMPS #4,
    DTR.SYNSEM.LKEYS.KEYREL.ARG2 #3,
    DTR.SYNSEM.LOCAL.OBJ-DEL-APPLIED - ].

;;;;;;;;;; FOR-NONHEADED NPÓ´û

presparticpl-adj-lxm := adj-lxm & infl-ltol-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj-reg,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE prespartcpl,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    ARGS < verb-general-lexeme & [SYNSEM [LOCAL.CONT.HOOK.XARG #1,
                                                 LOCAL.CAT.HEAD.VOICE active]] >,
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !> ].

pastparticpl-adj-word := adjective-word-2 & word-to-word-rule &
  [ SYNSEM.LOCAL.CAT.HEAD adj-reg,
    SYNSEM.LOCAL.CONT.HOOK #2,
    SYNSEM.LOCAL.CONT.HOOK.XARG #1,
    SYNSEM.LOCAL.AGR #1,
    SYNSEM.LOCAL.CAT.VAL.COMPS <>,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ -, ; to prevent absurd noun formations
    SYNSEM.NON-LOCAL #nl,
    ARGS <  infl-perf-part-verb-word & 
            [SYNSEM.LOCAL.CAT.HEAD.VOICE passive,
             SYNSEM.LOCAL.CAN-PASTPART-ADJ +,
             SYNSEM.LOCAL.CAT.VAL.COMPS <>,
             SYNSEM.LOCAL.CAT.VAL.ICOMPS <>,
             SYNSEM.LOCAL.CONT.HOOK.XARG #1,
	     SYNSEM.LOCAL.CONT.HOOK #2,
	     SYNSEM.NON-LOCAL #nl ] >,
    C-CONT.RELS <! !>,
    C-CONT.HCONS <! !> ].


wk-pastpt-adj-word := pastparticpl-adj-word & infl-wtow-rule &  
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [LOCAL.CAT.HEAD noun & [DEF + ],
                                   LOCAL.CAT.VAL.SPR < [] > ] >,
                            WEAK +,
                            DEGREE positive ]].

str-pastpt-adj-word := pastparticpl-adj-word &
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD < [LOCAL.CAT.HEAD noun & [DEF - ,
                                                          DEFINITE -]]>,
                            WEAK -,
                            DEGREE positive ]].
                                    
strsg-pastpt-adj-word := str-pastpt-adj-word & const-wtow-rule &			 [ SYNSEM.LOCAL.AGR.PNG.NG sg ].    
strpl-pastpt-adj-word := str-pastpt-adj-word & infl-wtow-rule &			 [ SYNSEM.LOCAL.AGR.PNG.NG pl ].


; not utilized
;non-headed-np-phrase := phrasal &
;  [ SYNSEM.LOCAL.CAT.HEAD np-head,
;    SYNSEM.LOCAL.CONT.RELS #2 ,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
;    ARGS < [ SYNSEM.LOCAL.CAT.HEAD adj,
;             SYNSEM.LOCAL.CONT.HOOK.XARG #1,
;             SYNSEM.LOCAL.CONT.RELS #2 ] >,
;    C-CONT.RELS <! !>,
;    C-CONT.HCONS <! !> ].

mod-to-n-rule := const-wtow-rule & noun-word &
  [ SYNSEM.LOCAL.CONT.HOOK.LTOP #4,
    SYNSEM.LKEYS.KEYREL.LBL #4,
    SYNSEM.CAN-WTOW -,
    SYNSEM.LOCAL.CAT.HEAD np-head,
;    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
        		       LAST #last ],
			HCONS [ LIST #scfirst,
				LAST #sclast ] ],
    SYNSEM.LKEYS.KEYREL #5,
    SYNSEM.LOCAL.DERIVED-HEAD bool,
    SYNSEM.NON-LOCAL #nonloc,
    DTR word & 
        [ SYNSEM.CAN-WTOW +,
          SYNSEM.LOCAL.CAT.HEAD adjectival,
          SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
 ;         SYNSEM.LOCAL.CONT.HOOK.XARG #1,
          SYNSEM.LKEYS.KEYREL #5,
          SYNSEM.LOCAL.CONT[ RELS [ LIST #first,
				    LAST #middle ],
			     HCONS [ LIST #scfirst,
				     LAST #scmiddle ] ],
	  SYNSEM.NON-LOCAL #nonloc],
    C-CONT[ RELS [ LIST #middle,
		    LAST #last ],
	     HCONS [ LIST #scmiddle,
		     LAST #sclast ] ] ].

; removed 'adjective-word & 
;        '
; so that also apply to superlatives
; have changed from DEFINITE #3 to DEF #3
adj-to-n-rule := mod-to-n-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SORT referential-thing,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1,
    SYNSEM.LOCAL.CAT.HEAD [ DEF #3,
                            DEFINITE -,
                            EXPLETIVE -,
                            KEYS.KEY absnoun ],
    SYNSEM.LOCAL.CAT.VAL.SPEC #4,
    SYNSEM.NON-LOCAL #nl,
    INFL-MORPH #6,
    DTR [ SYNSEM.LOCAL.CAT.HEAD adj-reg & [ WEAK #3,
                                            KEYS.KEY propt ],
          SYNSEM.LOCAL.CONT.HOOK.XARG #1,
          SYNSEM.LOCAL.CAT.VAL.SPEC #4,
          SYNSEM.NON-LOCAL #nl,
	  INFL-MORPH #6 ]].

; omitted ,
;                       AGR.PNG.NG pl  in DTR spec
adj-to-bare-n-rule := adj-to-n-rule &
  [ C-CONT.RELS <! indef-q-rel & [ PRED "_indef_q_rel",
                                   ARG0 #1,
                                   RSTR #2 ], 
		 arg0-relation & [ LBL #3,
				   ARG0 #1,
				   PRED "_uspec-entity_n_rel" ] !>,
          C-CONT.HCONS <! [ HARG #2,
                            LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.HOOK hook & [INDEX #1 & [ WH - ]],
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF -,
                       HEAD.BARE +,
                       VAL.SPR <> ],
    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LOCAL.DERIVED-BARE-N-FROM-ADJ +,
    DTR.SYNSEM.LOCAL [ DERIVED-BARE-N-FROM-ADJ +,
		       CONT.HOOK.LTOP #3 ] ].


#|
; duplicate
adj-to-bare-n-rule := adj-to-n-rule &
  [ C-CONT.RELS <! indef-q-rel & [ PRED "_indef_q_rel",
                                   ARG0 #1,
                                   RSTR #2 ] !>,
          C-CONT.HCONS <! [ HARG #2,
                            LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.HOOK hook & [INDEX #1 & [ WH - ]],
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF -,
                       HEAD.BARE +,
                       VAL.SPR <> ],
    SYNSEM.LOCAL.DERIVED-HEAD +,
    DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #3 ].
|#


adj-to-n-cum-quantifier-rule := adj-to-n-rule &
  [ C-CONT.RELS <! arg0-relation & [ LBL #3,
				     ARG0 #1,
				     PRED "_uspec-entity_n_rel" ]!>,
    C-CONT.HCONS <! !>,
    SYNSEM.LOCAL.CAT [ VAL.SPR < [LOCAL.CAT.HEAD quant] > ],
    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LOCAL.CONT.HOOK hook & [INDEX #1 & [ WH - ]],
    DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #3].

adj-to-n-cum-indefarticle-rule := adj-to-n-rule &
  [ C-CONT.RELS <! arg0-relation & [ LBL #3,
				     ARG0 #1,
				     PRED "_uspec-entity_n_rel" ]!>,
    C-CONT.HCONS <! !>,
    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LOCAL.CAT [ VAL.SPR < [LOCAL.CAT.HEAD art] > ],
    SYNSEM.LOCAL.CONT.HOOK hook & [INDEX #1 & [ WH - ]],
    DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #3].

adj-to-n-cum-defdem-rule := adj-to-n-rule &
  [ C-CONT.RELS <! indef-q-rel & [ PRED "_def_q_rel",
                                   ARG0 #1,
                                   RSTR #2 ], 
		 arg0-relation & [ LBL #3,
			      ARG0 #1,
			      PRED "_uspec-entity_n_rel" ] !>,
          C-CONT.HCONS <! [ HARG #2,
                            LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.HOOK hook & [INDEX #1 & [ WH - ]],
;    SYNSEM.LOCAL.CAT.HEAD adj,
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF +,
                       VAL.SPR < [LOCAL.CAT.HEAD det] > ],
    SYNSEM.LOCAL.DERIVED-HEAD +,
    DTR.SYNSEM.LOCAL [ CONT.HOOK.LTOP #3 ] ].

adj-to-n-cum-card-rule := adj-to-n-rule &
  [ C-CONT.RELS <! indef-q-rel & [ PRED "_def_q_rel",
                                   ARG0 #1,
                                   RSTR #2 ], 
		 arg0-relation & [ LBL #3,
			      ARG0 #1,
			      PRED "_uspec-entity_n_rel" ] !>,
          C-CONT.HCONS <! [ HARG #2,
                            LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.HOOK hook & [INDEX #1 & [ WH - ]],
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF +,
                       VAL.SPR < [LOCAL.CAT.HEAD card] > ],
    SYNSEM.LOCAL.DERIVED-HEAD +,
    DTR.SYNSEM.LOCAL [ CONT.HOOK.LTOP #3 ] ].


; the specification 'SORT referential-thing' blocks "to egg" from 
; meaning 'two dozens of egg'. 
;removed from DTR:  SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind, 
;          
; there is some overlap between these types, applying to words, and
; the subsumption of cardnum and noun under card-nom, designed for complex
; cardinals like in "kommer tjue tretti" 'comes (at) 20.30'
card-to-bare-n-rule := mod-to-n-rule &
  [ C-CONT.RELS <! indef-q-rel & [ PRED "_indef_q_rel",
                                   ARG0 #1,
                                   RSTR #2 ], 
		 arg0-relation & [ LBL #3,
				   ARG0 #1,
				   PRED "_uspec-entity_n_rel"] !>,
          C-CONT.HCONS <! [ HARG #2,
                            LARG #3 ] !>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absnoun,
    SYNSEM.LOCAL.CONT.HOOK hook & [XARG #1 & [ WH -]],
    SYNSEM.LOCAL.SPEC-TO-BARE-N +,
    SYNSEM.LOCAL.CARD-TO-BARE-N +,
    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF -,
                       HEAD.BARE +,
                       VAL.SPR <> ],
    DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
    DTR cardinal-word & 
        [ SYNSEM.LOCAL.CAT.HEAD cardnum,
          SYNSEM.LOCAL.CONT.HOOK.XARG #1,
	  SYNSEM.LOCAL.CARD-TO-BARE-N +] ].

;;;

card-to-n-cum-defdem-rule := mod-to-n-rule &
  [ C-CONT.RELS <! indef-q-rel & [ PRED "_indef_q_rel",
                                   ARG0 #1,
                                   RSTR #2 ], 
		 arg0-relation & [ LBL #3,
				   ARG0 #1,
				   PRED "_uspec-entity_n_rel"] !>,
          C-CONT.HCONS <! [ HARG #2,
                            LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absnoun,
    SYNSEM.LOCAL.CONT.HOOK hook & [XARG #1 & [ WH -]],
    SYNSEM.LOCAL.SPEC-TO-BARE-N +,
    SYNSEM.LOCAL.CARD-TO-BARE-N +,
    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF +,
                       HEAD.BARE +,
                       VAL.SPR < [LOCAL.CAT.HEAD det]> ],
    DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
    DTR cardinal-word & 
        [ SYNSEM.LOCAL.CAT.HEAD cardnum,
          SYNSEM.LOCAL.CONT.HOOK.XARG #1] ].
;;;
card-to-nonbare-n-rule := mod-to-n-rule &
  [ C-CONT.RELS <! !>,
    C-CONT.HCONS <! !>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absnoun,
    SYNSEM.LOCAL.CAT [ VAL.SPR < expressed-synsem >,
                       VAL.SPEC <>],
;    SYNSEM.LOCAL.CONT.HOOK hook & [INDEX.PNG.PERS #1],
;    SYNSEM.LOCAL.CARD-TO-NONBARE-N +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind, 
    SYNSEM.LOCAL.DERIVED-HEAD +,
    DTR word & lbl-ltop-lex-item & 
        [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind, 
          SYNSEM.LOCAL.CAT.HEAD cardnum ]].

card-to-name-of-card-rule := mod-to-n-rule &
  [ C-CONT.RELS <! def-q-rel & [ PRED "_def_q_rel",
                                   ARG0 #4,
                                   RSTR #2 ], 
		 arg0-relation & [ LBL #3,
				   ARG0 #4,
				   PRED "_name-of-card_n_rel"] !>,
          C-CONT.HCONS <! [ HARG #2,
                            LARG #3 ] !>,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #4 & [ WH -,
					SORT referential-thing],
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY name-of-card,
    SYNSEM.LOCAL.CONT.HOOK hook & [XARG.PNG.PERS #1,
				   XARG.PNG.NG sg],
    SYNSEM.LOCAL.SPEC-TO-BARE-N +,
    SYNSEM.LOCAL.CARD-TO-BARE-N +,
;    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF +,
                       HEAD.BARE +,
                       VAL.SPR <> ],
    DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
    DTR cardinal-word & 
        [ SYNSEM.LOCAL.CAT.HEAD cardnum,
          SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.PERS #1] ].

; motivated mainly by "andre" as in "andre kommer"; so perhaps rather a special lexical entry for "andre" for such uses
ord-to-bare-n-rule := mod-to-n-rule &
  [ C-CONT.RELS <! indef-q-rel & [ PRED "_indef_q_rel",
                                   ARG0 #1,
                                   RSTR #2 ] !>,
          C-CONT.HCONS <! [ HARG #2,
                            LARG #3 ] !>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absnoun,
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [ WH -],
    SYNSEM.LOCAL.CAT [ HEAD.DEFINITE -,
                       HEAD.DEF -,
                       HEAD.BARE +,
                       VAL.SPR <> ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [ SORT referential-thing ],
    SYNSEM.LOCAL.POSSPRON-TO-BARE-N +,
    SYNSEM.LOCAL.SPEC-TO-BARE-N +,
    SYNSEM.LOCAL.CARD-TO-BARE-N +,
    DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #3,
    DTR ordinal-word & 
        [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind ]].

; SYNSEM.LOCAL.POSSPRON-TO-BARE-N + in order to forestall 'apposition-rule' in "tredje juni"
ord-to-nonbare-n-rule := mod-to-n-rule &
  [ C-CONT.RELS <! !>,
    C-CONT.HCONS <! !>,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absnoun,
    SYNSEM.LOCAL.CAT [ VAL.SPR < [] > ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & [ SORT referential-thing ],
    SYNSEM.LOCAL.POSSPRON-TO-BARE-N +,
    DTR ordinal-word & 
        [ SYNSEM.LOCAL.CONT.HOOK.INDEX #1 & ref-ind ]].




spec-to-n-rule := const-wtow-rule & noun-word & rule &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absnoun,
    SYNSEM.LOCAL.CONT.HOOK.LTOP #4,
    SYNSEM.LKEYS.KEYREL.LBL #4,
    SYNSEM.CAN-WTOW -,
    SYNSEM.LOCAL.CAT.HEAD np-head,
    SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
        		       LAST #last ],
			HCONS [ LIST #scfirst,
				LAST #sclast ] ],
    SYNSEM.LOCAL.SPEC-TO-BARE-N +,
    SYNSEM.LOCAL.DERIVED-HEAD +,
    SYNSEM.LKEYS.KEYREL #5,
    C-CONT[ RELS [ LIST #middle,
		    LAST #last ],
	     HCONS [ LIST #scmiddle,
		     LAST #sclast ] ],
    SYNSEM.LOCAL.CAT.HEAD [ DEFINITE -,
                            DEF  #bool ],
    SYNSEM.LOCAL.CAT [ VAL [COMPS <>,
                            SPEC <> ]],
    SYNSEM.LOCAL.CONT.HOOK.INDEX [ WH -,
                                   SORT referential-thing ],
    SYNSEM.LOCAL.BINDING.BOUND -,
    SYNSEM.LOCAL.DERIVED-HEAD bool,
    DTR   [ SYNSEM.CAN-WTOW +,
            SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.DEF #bool ] >,
                  SYNSEM.LKEYS.KEYREL #5,
                  SYNSEM.LOCAL.CONT[ RELS [ LIST #first,
                                            LAST #middle ],
                                     HCONS [ LIST #scfirst,
                                             LAST #scmiddle ] ]]].

spec-to-bare-n-rule := spec-to-n-rule & 
  [ SYNSEM.LOCAL.CAT [ VAL [SPR < >]]].

spec-to-nonbare-n-rule := spec-to-n-rule & 
  [ SYNSEM.LOCAL.CAT [ VAL [SPR < [] >]]].

; 'absnoun' to make sure the N is not mistaken as a relational noun, with "av" in ingen av guttene' getting extra parses
indefquant-to-bare-n-rule := spec-to-bare-n-rule &
  [ SYNSEM.LOCAL.CONT.HOOK hook & [INDEX #1 & [ SORT full-thing ]],
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY absnoun,
    DTR.SYNSEM.LOCAL.CAT.HEAD quantor,
    DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #3 ] >,
    DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,                          
    C-CONT.HCONS <!  !>,
    C-CONT.RELS <! [PRED "_pron_rel",
                    LBL #3,
                    ARG0 #1] !> ].

; SYNSEM.LOCAL.CARD-TO-BARE-N + in order for apposition-rule to not produce "hver gutt"
indefquant-to-nonbare-n-rule := spec-to-nonbare-n-rule &
  [ SYNSEM.LOCAL.CONT.HOOK hook & [INDEX #1 & [ SORT referential-thing ]],
    SYNSEM.LOCAL.CARD-TO-BARE-N +,
    DTR.SYNSEM.LOCAL.CAT.HEAD q,
    DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #3 ] >,
    DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #1,                          
    C-CONT.HCONS <!  !>,
    C-CONT.RELS <! [PRED "_pron_rel",
                    LBL #3,
                    ARG0 #1] !> ].


posspron-to-bare-n-rule := spec-to-bare-n-rule &
  [ SYNSEM.LOCAL.CONT.HOOK [INDEX #1 ],    
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    SYNSEM.LOCAL.POSSPRON-TO-BARE-N +,
    RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind,
    DTR.SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    DTR.SYNSEM.LOCAL.CAT.HEAD posspron,
    DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    DTR.SYNSEM.LOCAL.BINDING [ REFL-I -, REFL-II - ],
    C-CONT [ RELS <! poss-rel & [ ARG1 #2,
                                  ARG2 #1], def-q-rel & [ ARG0 #1,
                                                          RSTR #6 ], 
		   [PRED "_pron_rel",
                    LBL #7,
                    ARG0 #1]  !>,
             HCONS <! [HARG #6,
                       LARG #7] !>] ].

posspron-to-nonbare-n-rule := spec-to-nonbare-n-rule &
  [ SYNSEM.LOCAL.CONT.HOOK [INDEX #1,
                            LTOP #7 ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8,
    SYNSEM.LOCAL.POSSPRON-TO-BARE-N -,
    RULE [ NEEDS-CARD -,
            NOMORE-CARD bool ],
    DTR [ SYNSEM.LOCAL.CAT.VAL.SPEC <[LOCAL.CONT.HOOK.INDEX #1]>,
          SYNSEM.LOCAL.CAT.VAL.COMPS < >,
          SYNSEM.LOCAL.CONT.HOOK.INDEX #2 & ref-ind, 
          SYNSEM.LOCAL.CAT.HEAD posspron,
          SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NG #8],
    C-CONT [ RELS <! poss-rel & [ ARG1 #2,
                                  ARG2 #1], def-q-rel & [ ARG0 #1,
                                                          RSTR #6 ]  !>,
             HCONS <! [HARG #6,
                       LARG #7] !>]  ].

;; personal names [FIXME]

firstname_m_le := mascsg-proper-name-word.
firstname_f_le := femsg-proper-name-word.
etternavn_le := proper-name-word.


; For verbs, most of the inflectional effects are introduced at word level. The values under verb_inflection are inscribed under INFL-MORPH (which is a sign feature). The 'governing' phonological properties could have been given under INFLECTION, since they are lexeme properties - and INFLECTION and INFL-MORPH need not be coindexed. However, in the long run that may seem natural - so ideally, the feature PHON should house the relevant specification of infinitive 'stem' forms. For now, though, we try with INFLECTION as housing info that somehow affects the choice of inflectional rules - that is consistent with design so far.

; moved to matrix.tdl
;phon := inflection.

; just for immediate troll-purposes
proprium := inflection.

finstr := phon.
finstr-dd := finstr.
finstr-tt := finstr.
nonfstr := phon.
nonfstr-ic := phon.

;; Introduced to make a distinction between "-et", "-de" and "-te"-verbs. EAA. 050711
;; The type nonfstr-strong is implemented to make sure that strong verbs only follow strong patterns.
nonfstr-et_or_te := nonfstr.
nonfstr-de := nonfstr.
nonfstr-strong := nonfstr.

nonfstr-et := nonfstr-et_or_te.
nonfstr-te := nonfstr-et_or_te.


;; for nouns
;; if neut: infl_nlong or infl_nshort

; moved to matrix.tdl
;inflection := sort.

; see out.txt.new - nominal features to noun_inflection
;inflection := sort &
;[GEND gen, NUMB num, DEFINITENESS definiteness, MK *top*].

definiteness := *top*.
ind := definiteness.
def := definiteness.


nominal_inflection := inflection &
[GEND gen, NUMB num, MK *top*].

noun_inflection := nominal_inflection &
[DEFINITENESS definiteness].

;infl_mabbrev := noun_inflection. [unused]

infl_m_f := noun_inflection.

infl_m_nshort := noun_inflection.
infl_m_fshort := final-full-long-or-short.

infl_m :=  infl_m_nshort & infl_m_fshort & [GEND m].
infl_f :=  infl_m_fshort & [GEND f].
infl_n := noun_inflection & [GEND n].
infl_nlong := infl_n.
infl_nshort := infl_n & infl_m_nshort.

;final-full-mm := noun_inflection.
;final-full := noun_inflection.
light-e-sup := noun_inflection.

; for m & f nouns
final-full-mm := infl_m_f.
final-full-long-or-short := infl_m_f.
final-full := final-full-long-or-short.
infl_mshort := infl_m.
infl_fshort := infl_f.
light-e-mf-sup := infl_m_f & light-e-sup.
light-e := light-e-mf-sup.
light-e-short := light-e-mf-sup.
; for plural nouns part of collocations or otherwise normally plural - just as a mark
light-e-ic := noun_inflection.
; for def-sg nouns part of collocations or otherwise normally definite - just as a mark
finalfull-ic := inflection.
title-ic := inflection.
xx := inflection.
interj := inflection.
subst_fork-t := inflection.
subst_fork := inflection.
konj_fork := inflection.

; for neuter nouns
final-full-mm-nshort := infl_nshort & final-full-mm.
final-full-mm-nlong := infl_nlong & final-full-mm.
final-full-nshort := infl_nshort & final-full-n.
final-full-nlong := infl_nlong & final-full-n.
; where both long and short is allowed
final-full-n := final-full & infl_n.

light-e-nshort := light-e-sup & infl_nshort.
light-e-nlong := light-e-sup & infl_nlong.

;;;;;;;;;;;;;;;;


verb_inflection := inflection &
[ TEMPUS tense, MODUS mood, DIATHESIS voice ].


adjective_inflection := nominal_inflection &
[ WEAKFORM bool,
  DEG degree ].


; first rule deletes first np on COMPS list: i.e., an np, preceded by nothing.
; so, it applies also to io in dobleobj
; second rule deletes both nps on COMPS list: i.e., two nps, preceded by nothing.
; so, no iteration of the first rule
deriv-pot := avm &
  [ CAN-OBJ-DEL bool,
    CAN-DOUBL-OBJ-DEL bool].

; datter
kinship-status := class.
; nabo
sociofunct-status := class.
; fot
phys-part-of-status := class.
; hovedstad
role-in-system-status := class.
; halvdel, delmengde
role-in-partition-status := class.
; inntrykk, resultat
role-in-situation-status := class.


; discourse
; moved to matrix
;discmode := sort.
single-developer := discmode.
presented-developer := discmode.
interact-developer := discmode.
scenic-developer := discmode.
question := discmode.
response := discmode.
added-info := discmode.

disc-add-phrase := basic-head-mod-phrase-simple & head-final &
   [ DISC-MODE #2 & discmode,
     SYNSEM.LOCAL.CAT.VAL [SUBJ antilist,
			   COMPS <>,
			   SPR <>,
			   SPEC <>],
     SYNSEM.LOCAL.CAT.QVAL #qval,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #3 & [E.MOOD #1],
     SYNSEM.LOCAL.CONT.HOOK.INDEX.DISC-MOVE #2,
     SYNSEM.NON-LOCAL.SLASH <! !>,
     SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    SYNSEM.LOCAL.BND-RESP #bresp,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bresp,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    ARGS < [], [ SYNSEM.LOCAL.CONT.HOOK.INDEX #3 & [E.MOOD #1],
		  SYNSEM.LOCAL.CAT.QVAL #qval ] > ].

disc-firstadd-phrase := disc-add-phrase &
   [ ARGS < period-mod-phrase, 
	  period-mod-phrase > ].

disc-secondadd-phrase := disc-add-phrase &
   [ ARGS < disc-add-phrase, 
	  period-mod-phrase > ].

disc-firstsingdeveloper-phrase := disc-firstadd-phrase &
   [ DISC-MODE single-developer,
     C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #2 & [PNG.PERS #p] ] !>,
     ARGS < [ SYNSEM.LOCAL.CAT.QVAL intrans-qval & [SUBJECT.LOCAL.CONT.HOOK.INDEX #1 & ref-ind ]], 
	   [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL [CONT.HOOK.INDEX #2,
						 CAT.HEAD pers-pron]]> ].
disc-mediasresdeveloper-phrase := disc-firstadd-phrase &
   [ DISC-MODE interact-developer,
     C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #2 & [PNG.PERS #p]], 
		  [ PRED "coreferential_rel",
		      ARG1 #3 & [PNG.PERS #q],
		      ARG2 #4 & [PNG.PERS #q]] !>,
     ARGS < [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1 & ref-ind,
	      SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #3 & ref-ind ], 
	   [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL [CONT.HOOK.INDEX #2,
						 CAT.HEAD pers-pron],
	     SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CONT.HOOK.INDEX #4,
						  CAT.HEAD pers-pron,
						  CTXT pron-discbnd ]]> ].

disc-presentdeveloper-phrase := disc-firstadd-phrase &
   [ DISC-MODE presented-developer,
     C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #2 & [PNG.PERS #p] ] !>,
     ARGS < [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.PRESENTED +,
	      SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1 ], 
	    [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL [CONT.HOOK.INDEX #2,
						 CAT.HEAD pers-pron],
	      SYNSEM.LOCAL.CAT.HEAD.INV - ]> ].

disc-scenedeveloper-pres-phrase := disc-firstadd-phrase &
   [ DISC-MODE scenic-developer,
     C-CONT.RELS <! !>,
     ARGS < [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.PRESENTED + ], 
	    [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.PRESENTED + ]> ].

disc-scenedeveloper-reg-phrase := disc-firstadd-phrase &
   [ DISC-MODE scenic-developer,
     C-CONT.RELS <! !>,
     ARGS < [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD.PRESENTED + ], 
	    [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD noun,
	      SYNSEM.LOCAL.CAT.HEAD.INV - ] > ].

disc-secondsingdeveloper-phrase := disc-secondadd-phrase &
   [ DISC-MODE single-developer,
     C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #2 & [PNG.PERS #p] ] !>,
     ARGS < [ DISC-MODE single-developer,
	      SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1 & ref-ind ], 
	   [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL [CONT.HOOK.INDEX #2,
						 CAT.HEAD pers-pron]]> ].

disc-secondpresdeveloper-phrase := disc-secondadd-phrase &
   [ DISC-MODE single-developer,
     C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #2 & [PNG.PERS #p] ] !>,
     ARGS < [ DISC-MODE presented-developer,
	      SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1 & ref-ind ], 
	   [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL [CONT.HOOK.INDEX #2,
						 CAT.HEAD pers-pron]]> ].

disc-secondscenedeveloper-pron-phrase := disc-secondadd-phrase &
   [ DISC-MODE interact-developer,
     C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #2 & [PNG.PERS #p] ], 
		  [ PRED "coreferential_rel",
		      ARG1 #3 & [PNG.PERS #q],
		      ARG2 #4 & [PNG.PERS #q] ] !>,
     ARGS < [ DISC-MODE scenic-developer,
	      SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1 & ref-ind,
	      SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #3 & ref-ind ], 
	   [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL [CONT.HOOK.INDEX #2,
						 CAT.HEAD pers-pron],
	     SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CONT.HOOK.INDEX #4,
						  CAT.HEAD pers-pron,
						  CTXT pron-discbnd ]]> ].

disc-secondscenedeveloper-reg-phrase := disc-secondadd-phrase &
   [ DISC-MODE interact-developer,
     C-CONT.RELS <! !>,
     ARGS < [ DISC-MODE scenic-developer ], 
	   [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CAT.HEAD noun & [DEF +],
	     SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CAT.HEAD noun & [DEF +]]> ].

disc-secondscenedeveloper-mix-phrase := disc-secondadd-phrase &
   [ DISC-MODE interact-developer,
     C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #3 & [PNG.PERS #p],
		      ARG2 #4 & [PNG.PERS #p] ] !>,
     ARGS < [ DISC-MODE scenic-developer,
	      SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #3 & ref-ind ], 
	   [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL [CONT.HOOK.INDEX #4,
						  CAT.HEAD pers-pron ]]> ].

; det ligger en mann i sengen. han smiler. han sover.
; en mann ligger i sengen. han smiler. han sover.
; det kom en gutt. han sitter n√• i stolen.
; #det kom en gutt. det ligger en mann. [scenic]
; #det kom en gutt. gutten sitter i stolen. [scenic]
; *det kom en gutt. I stolen sitter han.
; det kommer en gutt. mannen v√•kner. han ser ham.
; det kommer en gutt. mannen v√•kner. mannen ser gutten.
; det kommer en gutt. mannen v√•kner. mannen ser ham.
; *det kommer en gutt. mannen v√•kner. han ser mannen.
; Kari ser Ola. Hun unng√•r ham.
; *Kari ser Ola. Jeg unng√•r ham.

disc-shortcontinuation-phrase := basic-head-mod-phrase-simple & head-initial &
   [ SYNSEM.LOCAL.CAT.VAL [SUBJ antilist,
			   COMPS <>,
			   SPR <>,
			   SPEC <>],
     SYNSEM.LOCAL.CAT.QVAL #qval,
     SYNSEM.LOCAL.CONT.HOOK.INDEX #3 & [E.MOOD #1],
     SYNSEM.LOCAL.CONT.HOOK.INDEX.DISC-MOVE #2,
     SYNSEM.NON-LOCAL.SLASH <! !>,
     SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    SYNSEM.LOCAL.BND-RESP #bresp,
    HEAD-DTR.SYNSEM.LOCAL.BND-RESP #bresp,
    HEAD-DTR.SYNSEM.LOCAL.WAIT-BND-RESP #resp,
    ARGS < [ SYNSEM.LOCAL.CONT.HOOK.INDEX #3 & [E.MOOD #1],
	      SYNSEM.LOCAL.CONT.HOOK.INDEX.DISC-MOVE #2,
	      SYNSEM.LOCAL.CAT.QVAL #qval ], 
	    [  ] >,
     C-CONT.HCONS <! !> ].

disc-shortresponse-phrase := disc-shortcontinuation-phrase &
   [ SYNSEM.LOCAL.CONT.HOOK.INDEX.DISC-MOVE question ].

disc-shortaddedinfo-phrase := disc-shortcontinuation-phrase &
   [ SYNSEM.LOCAL.CONT.HOOK.INDEX.DISC-MOVE added-info ].

disc-shortphr-subj-response-phrase := disc-shortresponse-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH +],
	      SYNSEM.LOCAL.CONT.HOOK.XARG #1 ], 
	    [ DISC-MODE response,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

disc-shortphr-obj-response-phrase := disc-shortresponse-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH +],
	      SYNSEM.LOCAL.CONT.HOOK.VARG #1 ],
	    [ DISC-MODE response,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

disc-shortphr-obl-response-phrase := disc-shortresponse-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL with-obl-pp-qval & [OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH +] ]], 
	    [ DISC-MODE response,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

disc-shortphr-auxembobj-response-phrase := disc-shortresponse-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL.PREDIC.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH +],
	      SYNSEM.LOCAL.CAT.QVAL.PREDIC.LOCAL.CONT.HOOK.VARG #1 ], 
	    [ DISC-MODE response,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

disc-shortphr-auxembobl-response-phrase := disc-shortresponse-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL.PREDIC.LOCAL.CAT.QVAL with-obl-pp-qval & [OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH +] ]], 
	    [ DISC-MODE response,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

disc-shortaddedinfo-subj-phrase := disc-shortaddedinfo-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL.SUBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH -],
	      SYNSEM.LOCAL.CONT.HOOK.XARG #1 ], 
	    [ DISC-MODE added-info,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

disc-shortaddedinfo-obj-phrase := disc-shortaddedinfo-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH -],
	      SYNSEM.LOCAL.CONT.HOOK.VARG #1 ], 
	    [ DISC-MODE added-info,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

disc-shortaddedinfo-obl-phrase := disc-shortaddedinfo-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL with-obl-pp-qval & [OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH -] ] ], 
	    [ DISC-MODE added-info,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

disc-shortaddedinfo-auxembobj-phrase := disc-shortaddedinfo-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL.PREDIC.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH -],
	      SYNSEM.LOCAL.CAT.QVAL.PREDIC.LOCAL.CONT.HOOK.VARG #1 ], 
	    [ DISC-MODE added-info,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

disc-shortaddedinfo-auxembobl-phrase := disc-shortaddedinfo-phrase &
   [ C-CONT.RELS <! [ PRED "coreferential_rel",
		      ARG1 #1 & [PNG.PERS #p],
		      ARG2 #8 & [PNG.PERS #p] ] !>,
     ARGS < period-mod-phrase &
	    [ SYNSEM.LOCAL.CAT.QVAL.PREDIC.LOCAL.CAT.QVAL with-obl-pp-qval & [OBL1.LOCAL.CAT.QVAL.DOBJECT.LOCAL.CONT.HOOK.INDEX #1 & [WH -] ] ], 
	    [ DISC-MODE added-info,
	      SYNSEM.LOCAL.CAT.HEAD nom,
	      SYNSEM.LOCAL.CONT.HOOK.INDEX #8 ] > ].

parenthesis-opener := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD parenthesis,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY start-parenth,
    SYNSEM.LOCAL.CAT.VAL.SUBJ < >,
    SYNSEM.LOCAL.CAT.VAL.SPR < >,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #1,
				  LOCAL.CAT.VAL.COMPS <>,
				  LOCAL.CAT.VAL.SUBJ <>,
				  LOCAL.CAT.VAL.SPR < >,
				  LOCAL.CAT.VAL.SPEC <>,
				  LOCAL.CAT.VAL.ICOMPS <>]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD.KEYS.KEY end-parenth ] >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
    SYNSEM.LKEYS.KEYREL.PRED "parenthetical_rel",
    SYNSEM.LKEYS.KEYREL arg1-relation & [ARG1 #1],
    SYNSEM.LOCAL.CONT.HCONS <! !>].

parenthesis-closer := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD parenthesis,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY end-parenth,
    SYNSEM.LOCAL.CAT.VAL.SUBJ < >,
    SYNSEM.LOCAL.CAT.VAL.SPR < >,
    SYNSEM.LOCAL.CAT.VAL.SPEC < >,
    SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
    SYNSEM.LKEYS.KEYREL.PRED "end-parenthetical_rel",
    SYNSEM.LOCAL.CONT.HCONS <! !>].

quotation-opener := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD quotation-mark,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY start-quote,
    SYNSEM.LOCAL.CAT.VAL.SUBJ < >,
    SYNSEM.LOCAL.CAT.VAL.SPR < >,
    SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CONT.HOOK.LTOP #1,
				  LOCAL.CAT.VAL.COMPS <>,
				  LOCAL.CAT.VAL.SUBJ <>,
				  LOCAL.CAT.VAL.SPR < >,
				  LOCAL.CAT.VAL.SPEC <>,
				  LOCAL.CAT.VAL.ICOMPS <>]>,
    SYNSEM.LOCAL.CAT.VAL.COMPS <[LOCAL.CAT.HEAD.KEYS.KEY end-quote ] >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
    SYNSEM.LKEYS.KEYREL.PRED "quotation_rel",
    SYNSEM.LKEYS.KEYREL arg1-relation & [ARG1 #1],
    SYNSEM.LOCAL.CONT.HCONS <! !>].

quotation-closer := lbl-ltop-lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD quotation-mark,
    SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY end-quote,
    SYNSEM.LOCAL.CAT.VAL.SUBJ < >,
    SYNSEM.LOCAL.CAT.VAL.SPR < >,
    SYNSEM.LOCAL.CAT.VAL.SPEC < >,
    SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    SYNSEM.LOCAL.CAT.VAL.ICOMPS < >,
    SYNSEM.LKEYS.KEYREL.PRED "end-quotation_rel",
    SYNSEM.LOCAL.CONT.HCONS <! !>].


clause :+ 
[ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].


;; EAA 300711: These types has been passed over from mal-types,
;; as NorSource types inherit from these.

var-m_noid-basic-head-mod-phrase-simple := basic-head-mod-phrase-simple-sup.

var-m_noid-head-mod-phrase-simple := head-mod-phrase-simple-sup & var-m_noid-basic-head-mod-phrase-simple.

var-m_noid-adj-head-phrase := adj-head-phrase-sup & var-m_noid-head-mod-phrase-simple &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #head,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD #head ] >, 
    C-CONT.RELS <! !>  ].

var-cc_opn-adj-head-phrase := adj-head-phrase-sup & head-mod-phrase-simple & 
[ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD #head,
  NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD #head ] > ].

var-cc_opn-m_noid-adj-head-phrase := adj-head-phrase-sup & var-m_noid-head-mod-phrase-simple.

var-m_noid-a-mod-phrase := a-mod-phrase-sup & var-m_noid-adj-head-phrase &
[C-CONT [RELS <! !>,
         HCONS <! !>]]. 

var-cc_opn-a-mod-phrase := a-mod-phrase-sup & var-cc_opn-adj-head-phrase.

var-cc_opn-m_noid-a-mod-phrase := a-mod-phrase-sup & var-cc_opn-m_noid-adj-head-phrase.


var-m_noid-adjective-mod-phrase := adjective-mod-phrase-sup & var-m_noid-a-mod-phrase.

var-cc_opn-adjective-mod-phrase := adjective-mod-phrase-sup & var-cc_opn-a-mod-phrase.

var-cc_opn-m_noid-adjective-mod-phrase := adjective-mod-phrase-sup & var-cc_opn-m_noid-a-mod-phrase.

;; Mal-addenda that has to touch NorSource proper. (But no adverse effects). EAA010811

adj-no_gd := adj-reg.
